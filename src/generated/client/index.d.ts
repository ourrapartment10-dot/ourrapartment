/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model RefreshToken
 *
 */
export type RefreshToken =
  $Result.DefaultSelection<Prisma.$RefreshTokenPayload>;
/**
 * Model PushSubscription
 *
 */
export type PushSubscription =
  $Result.DefaultSelection<Prisma.$PushSubscriptionPayload>;
/**
 * Model Notification
 *
 */
export type Notification =
  $Result.DefaultSelection<Prisma.$NotificationPayload>;
/**
 * Model Property
 *
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>;
/**
 * Model Announcement
 *
 */
export type Announcement =
  $Result.DefaultSelection<Prisma.$AnnouncementPayload>;
/**
 * Model AnnouncementLike
 *
 */
export type AnnouncementLike =
  $Result.DefaultSelection<Prisma.$AnnouncementLikePayload>;
/**
 * Model AnnouncementComment
 *
 */
export type AnnouncementComment =
  $Result.DefaultSelection<Prisma.$AnnouncementCommentPayload>;
/**
 * Model ApartmentConfig
 *
 */
export type ApartmentConfig =
  $Result.DefaultSelection<Prisma.$ApartmentConfigPayload>;
/**
 * Model Poll
 *
 */
export type Poll = $Result.DefaultSelection<Prisma.$PollPayload>;
/**
 * Model PollOption
 *
 */
export type PollOption = $Result.DefaultSelection<Prisma.$PollOptionPayload>;
/**
 * Model PollVote
 *
 */
export type PollVote = $Result.DefaultSelection<Prisma.$PollVotePayload>;
/**
 * Model Facility
 *
 */
export type Facility = $Result.DefaultSelection<Prisma.$FacilityPayload>;
/**
 * Model FacilityBooking
 *
 */
export type FacilityBooking =
  $Result.DefaultSelection<Prisma.$FacilityBookingPayload>;
/**
 * Model Complaint
 *
 */
export type Complaint = $Result.DefaultSelection<Prisma.$ComplaintPayload>;
/**
 * Model Payment
 *
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>;
/**
 * Model CommunityFinance
 *
 */
export type CommunityFinance =
  $Result.DefaultSelection<Prisma.$CommunityFinancePayload>;
/**
 * Model Message
 *
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>;

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
    USER: 'USER';
    ADMIN: 'ADMIN';
    SUPER_ADMIN: 'SUPER_ADMIN';
    RESIDENT: 'RESIDENT';
  };

  export type UserRole = (typeof UserRole)[keyof typeof UserRole];

  export const UserStatus: {
    PENDING: 'PENDING';
    APPROVED: 'APPROVED';
    REJECTED: 'REJECTED';
    DEACTIVATED: 'DEACTIVATED';
  };

  export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

  export const FacilityBookingStatus: {
    PENDING: 'PENDING';
    APPROVED: 'APPROVED';
    REJECTED: 'REJECTED';
    CANCELLED: 'CANCELLED';
  };

  export type FacilityBookingStatus =
    (typeof FacilityBookingStatus)[keyof typeof FacilityBookingStatus];

  export const PaymentStatus: {
    PENDING: 'PENDING';
    PENDING_VERIFICATION: 'PENDING_VERIFICATION';
    COMPLETED: 'COMPLETED';
    FAILED: 'FAILED';
    REFUNDED: 'REFUNDED';
  };

  export type PaymentStatus =
    (typeof PaymentStatus)[keyof typeof PaymentStatus];

  export const PaymentType: {
    MAINTENANCE: 'MAINTENANCE';
    FACILITY: 'FACILITY';
    EVENT: 'EVENT';
    OTHER: 'OTHER';
  };

  export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType];

  export const PaymentMethod: {
    CASH: 'CASH';
    CARD: 'CARD';
    UPI: 'UPI';
    BANK_TRANSFER: 'BANK_TRANSFER';
    ONLINE: 'ONLINE';
  };

  export type PaymentMethod =
    (typeof PaymentMethod)[keyof typeof PaymentMethod];

  export const AuthProvider: {
    CREDENTIALS: 'CREDENTIALS';
    GOOGLE: 'GOOGLE';
  };

  export type AuthProvider = (typeof AuthProvider)[keyof typeof AuthProvider];

  export const BlockNamingConvention: {
    NUMERIC: 'NUMERIC';
    ALPHABETIC: 'ALPHABETIC';
  };

  export type BlockNamingConvention =
    (typeof BlockNamingConvention)[keyof typeof BlockNamingConvention];

  export const ComplaintType: {
    PUBLIC: 'PUBLIC';
    PRIVATE: 'PRIVATE';
  };

  export type ComplaintType =
    (typeof ComplaintType)[keyof typeof ComplaintType];

  export const ComplaintStatus: {
    OPEN: 'OPEN';
    RESOLVED: 'RESOLVED';
  };

  export type ComplaintStatus =
    (typeof ComplaintStatus)[keyof typeof ComplaintStatus];
}

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type UserStatus = $Enums.UserStatus;

export const UserStatus: typeof $Enums.UserStatus;

export type FacilityBookingStatus = $Enums.FacilityBookingStatus;

export const FacilityBookingStatus: typeof $Enums.FacilityBookingStatus;

export type PaymentStatus = $Enums.PaymentStatus;

export const PaymentStatus: typeof $Enums.PaymentStatus;

export type PaymentType = $Enums.PaymentType;

export const PaymentType: typeof $Enums.PaymentType;

export type PaymentMethod = $Enums.PaymentMethod;

export const PaymentMethod: typeof $Enums.PaymentMethod;

export type AuthProvider = $Enums.AuthProvider;

export const AuthProvider: typeof $Enums.AuthProvider;

export type BlockNamingConvention = $Enums.BlockNamingConvention;

export const BlockNamingConvention: typeof $Enums.BlockNamingConvention;

export type ComplaintType = $Enums.ComplaintType;

export const ComplaintType: typeof $Enums.ComplaintType;

export type ComplaintStatus = $Enums.ComplaintStatus;

export const ComplaintStatus: typeof $Enums.ComplaintStatus;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions
    ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
      ? Prisma.GetEvents<ClientOptions['log']>
      : never
    : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

  /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(
    optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>
  );
  $on<V extends U>(
    eventType: V,
    callback: (
      event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent
    ) => void
  ): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(
    arg: [...P]
  ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

  $transaction<R>(
    fn: (
      prisma: Omit<PrismaClient, runtime.ITXClientDenyList>
    ) => $Utils.JsPromise<R>,
    options?: { maxWait?: number; timeout?: number }
  ): $Utils.JsPromise<R>;

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(
    command: Prisma.InputJsonObject
  ): Prisma.PrismaPromise<Prisma.JsonObject>;

  $extends: $Extensions.ExtendsHook<
    'extends',
    Prisma.TypeMapCb<ClientOptions>,
    ExtArgs,
    $Utils.Call<
      Prisma.TypeMapCb<ClientOptions>,
      {
        extArgs: ExtArgs;
      }
    >
  >;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more RefreshTokens
   * const refreshTokens = await prisma.refreshToken.findMany()
   * ```
   */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pushSubscription`: Exposes CRUD operations for the **PushSubscription** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PushSubscriptions
   * const pushSubscriptions = await prisma.pushSubscription.findMany()
   * ```
   */
  get pushSubscription(): Prisma.PushSubscriptionDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Notifications
   * const notifications = await prisma.notification.findMany()
   * ```
   */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Properties
   * const properties = await prisma.property.findMany()
   * ```
   */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcement`: Exposes CRUD operations for the **Announcement** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Announcements
   * const announcements = await prisma.announcement.findMany()
   * ```
   */
  get announcement(): Prisma.AnnouncementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.announcementLike`: Exposes CRUD operations for the **AnnouncementLike** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AnnouncementLikes
   * const announcementLikes = await prisma.announcementLike.findMany()
   * ```
   */
  get announcementLike(): Prisma.AnnouncementLikeDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.announcementComment`: Exposes CRUD operations for the **AnnouncementComment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more AnnouncementComments
   * const announcementComments = await prisma.announcementComment.findMany()
   * ```
   */
  get announcementComment(): Prisma.AnnouncementCommentDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.apartmentConfig`: Exposes CRUD operations for the **ApartmentConfig** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more ApartmentConfigs
   * const apartmentConfigs = await prisma.apartmentConfig.findMany()
   * ```
   */
  get apartmentConfig(): Prisma.ApartmentConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.poll`: Exposes CRUD operations for the **Poll** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Polls
   * const polls = await prisma.poll.findMany()
   * ```
   */
  get poll(): Prisma.PollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollOption`: Exposes CRUD operations for the **PollOption** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PollOptions
   * const pollOptions = await prisma.pollOption.findMany()
   * ```
   */
  get pollOption(): Prisma.PollOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pollVote`: Exposes CRUD operations for the **PollVote** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more PollVotes
   * const pollVotes = await prisma.pollVote.findMany()
   * ```
   */
  get pollVote(): Prisma.PollVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facility`: Exposes CRUD operations for the **Facility** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Facilities
   * const facilities = await prisma.facility.findMany()
   * ```
   */
  get facility(): Prisma.FacilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.facilityBooking`: Exposes CRUD operations for the **FacilityBooking** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more FacilityBookings
   * const facilityBookings = await prisma.facilityBooking.findMany()
   * ```
   */
  get facilityBooking(): Prisma.FacilityBookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complaint`: Exposes CRUD operations for the **Complaint** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Complaints
   * const complaints = await prisma.complaint.findMany()
   * ```
   */
  get complaint(): Prisma.ComplaintDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Payments
   * const payments = await prisma.payment.findMany()
   * ```
   */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.communityFinance`: Exposes CRUD operations for the **CommunityFinance** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more CommunityFinances
   * const communityFinances = await prisma.communityFinance.findMany()
   * ```
   */
  get communityFinance(): Prisma.CommunityFinanceDelegate<
    ExtArgs,
    ClientOptions
  >;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
   * Example usage:
   * ```ts
   * // Fetch zero or more Messages
   * const messages = await prisma.message.findMany()
   * ```
   */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF;

  export type PrismaPromise<T> = $Public.PrismaPromise<T>;

  /**
   * Validator
   */
  export import validator = runtime.Public.validator;

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
  export import PrismaClientValidationError = runtime.PrismaClientValidationError;

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag;
  export import empty = runtime.empty;
  export import join = runtime.join;
  export import raw = runtime.raw;
  export import Sql = runtime.Sql;

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal;

  export type DecimalJsLike = runtime.DecimalJsLike;

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics;
  export type Metric<T> = runtime.Metric<T>;
  export type MetricHistogram = runtime.MetricHistogram;
  export type MetricHistogramBucket = runtime.MetricHistogramBucket;

  /**
   * Extensions
   */
  export import Extension = $Extensions.UserArgs;
  export import getExtensionContext = runtime.Extensions.getExtensionContext;
  export import Args = $Public.Args;
  export import Payload = $Public.Payload;
  export import Result = $Public.Result;
  export import Exact = $Public.Exact;

  /**
   * Prisma Client JS version: 6.19.2
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string;
  };

  export const prismaVersion: PrismaVersion;

  /**
   * Utility Types
   */

  export import Bytes = runtime.Bytes;
  export import JsonObject = runtime.JsonObject;
  export import JsonArray = runtime.JsonArray;
  export import JsonValue = runtime.JsonValue;
  export import InputJsonObject = runtime.InputJsonObject;
  export import InputJsonArray = runtime.InputJsonArray;
  export import InputJsonValue = runtime.InputJsonValue;

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
     * Type of `Prisma.DbNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class DbNull {
      private DbNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.JsonNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class JsonNull {
      private JsonNull: never;
      private constructor();
    }

    /**
     * Type of `Prisma.AnyNull`.
     *
     * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
     *
     * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
     */
    class AnyNull {
      private AnyNull: never;
      private constructor();
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull;

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull;

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull;

  type SelectAndInclude = {
    select: any;
    include: any;
  };

  type SelectAndOmit = {
    select: any;
    omit: any;
  };

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> =
    T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<
    T extends (...args: any) => $Utils.JsPromise<any>,
  > = PromiseType<ReturnType<T>>;

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
    [P in K]: T[P];
  };

  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
  }[keyof T];

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
  };

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & (T extends SelectAndInclude
    ? 'Please either choose `select` or `include`.'
    : T extends SelectAndOmit
      ? 'Please either choose `select` or `omit`.'
      : {});

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  } & K;

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> = T extends object
    ? U extends object
      ? (Without<T, U> & U) | (Without<U, T> & T)
      : U
    : T;

  /**
   * Is T a Record?
   */
  type IsObject<T extends any> =
    T extends Array<any>
      ? False
      : T extends Date
        ? False
        : T extends Uint8Array
          ? False
          : T extends BigInt
            ? False
            : T extends object
              ? True
              : False;

  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
    }[K];

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<
    __Either<O, K>
  >;

  type _Either<O extends object, K extends Key, strict extends Boolean> = {
    1: EitherStrict<O, K>;
    0: EitherLoose<O, K>;
  }[strict];

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = O extends unknown ? _Either<O, K, strict> : never;

  export type Union = any;

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
  } & {};

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never;

  export type Overwrite<O extends object, O1 extends object> = {
    [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<
    Overwrite<
      U,
      {
        [K in keyof U]-?: At<U, K>;
      }
    >
  >;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O
    ? O[K]
    : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown
    ? AtStrict<O, K>
    : never;
  export type At<
    O extends object,
    K extends Key,
    strict extends Boolean = 1,
  > = {
    1: AtStrict<O, K>;
    0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function
    ? A
    : {
        [K in keyof A]: A[K];
      } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
      ?
          | (K extends keyof O ? { [P in K]: O[P] } & O : O)
          | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
      : never
  >;

  type _Strict<U, _U = U> = U extends unknown
    ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
    : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False;

  // /**
  // 1
  // */
  export type True = 1;

  /**
  0
  */
  export type False = 0;

  export type Not<B extends Boolean> = {
    0: 1;
    1: 0;
  }[B];

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
      ? 1
      : 0;

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >;

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0;
      1: 1;
    };
    1: {
      0: 1;
      1: 1;
    };
  }[B1][B2];

  export type Keys<U extends Union> = U extends unknown ? keyof U : never;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object
    ? {
        [P in keyof T]: P extends keyof O ? O[P] : never;
      }
    : never;

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>,
  > = IsObject<T> extends True ? U : T;

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<
            UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never
          >
        : never
      : {} extends FieldPaths<T[K]>
        ? never
        : K;
  }[keyof T];

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<
    T,
    K extends Enumerable<keyof T> | keyof T,
  > = Prisma__Pick<T, MaybeTupleToUnion<K>>;

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}`
    ? never
    : T;

  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

  type FieldRefInputType<Model, FieldType> = Model extends never
    ? never
    : FieldRef<Model, FieldType>;

  export const ModelName: {
    User: 'User';
    RefreshToken: 'RefreshToken';
    PushSubscription: 'PushSubscription';
    Notification: 'Notification';
    Property: 'Property';
    Announcement: 'Announcement';
    AnnouncementLike: 'AnnouncementLike';
    AnnouncementComment: 'AnnouncementComment';
    ApartmentConfig: 'ApartmentConfig';
    Poll: 'Poll';
    PollOption: 'PollOption';
    PollVote: 'PollVote';
    Facility: 'Facility';
    FacilityBooking: 'FacilityBooking';
    Complaint: 'Complaint';
    Payment: 'Payment';
    CommunityFinance: 'CommunityFinance';
    Message: 'Message';
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName];

  export type Datasources = {
    db?: Datasource;
  };

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<
    { extArgs: $Extensions.InternalArgs },
    $Utils.Record<string, any>
  > {
    returns: Prisma.TypeMap<
      this['params']['extArgs'],
      ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
    >;
  }

  export type TypeMap<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > = {
    globalOmitOptions: {
      omit: GlobalOmitOptions;
    };
    meta: {
      modelProps:
        | 'user'
        | 'refreshToken'
        | 'pushSubscription'
        | 'notification'
        | 'property'
        | 'announcement'
        | 'announcementLike'
        | 'announcementComment'
        | 'apartmentConfig'
        | 'poll'
        | 'pollOption'
        | 'pollVote'
        | 'facility'
        | 'facilityBooking'
        | 'complaint'
        | 'payment'
        | 'communityFinance'
        | 'message';
      txIsolationLevel: never;
    };
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>;
        fields: Prisma.UserFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
          };
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$UserPayload>;
          };
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateUser>;
          };
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>;
            result: $Utils.Optional<UserGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.UserCountArgs<ExtArgs>;
            result: $Utils.Optional<UserCountAggregateOutputType> | number;
          };
        };
      };
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>;
        fields: Prisma.RefreshTokenFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[];
          };
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>;
          };
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateRefreshToken>;
          };
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>;
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.RefreshTokenFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.RefreshTokenAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<RefreshTokenCountAggregateOutputType>
              | number;
          };
        };
      };
      PushSubscription: {
        payload: Prisma.$PushSubscriptionPayload<ExtArgs>;
        fields: Prisma.PushSubscriptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PushSubscriptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          findFirst: {
            args: Prisma.PushSubscriptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PushSubscriptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          findMany: {
            args: Prisma.PushSubscriptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>[];
          };
          create: {
            args: Prisma.PushSubscriptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          createMany: {
            args: Prisma.PushSubscriptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PushSubscriptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          update: {
            args: Prisma.PushSubscriptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          deleteMany: {
            args: Prisma.PushSubscriptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PushSubscriptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PushSubscriptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PushSubscriptionPayload>;
          };
          aggregate: {
            args: Prisma.PushSubscriptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePushSubscription>;
          };
          groupBy: {
            args: Prisma.PushSubscriptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PushSubscriptionGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PushSubscriptionFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PushSubscriptionAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PushSubscriptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PushSubscriptionCountAggregateOutputType>
              | number;
          };
        };
      };
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>;
        fields: Prisma.NotificationFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[];
          };
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>;
          };
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateNotification>;
          };
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>;
            result: $Utils.Optional<NotificationGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.NotificationFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.NotificationAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<NotificationCountAggregateOutputType>
              | number;
          };
        };
      };
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>;
        fields: Prisma.PropertyFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[];
          };
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>;
          };
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateProperty>;
          };
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PropertyGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PropertyFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PropertyAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>;
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number;
          };
        };
      };
      Announcement: {
        payload: Prisma.$AnnouncementPayload<ExtArgs>;
        fields: Prisma.AnnouncementFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnnouncementFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnnouncementFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findFirst: {
            args: Prisma.AnnouncementFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnnouncementFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          findMany: {
            args: Prisma.AnnouncementFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>[];
          };
          create: {
            args: Prisma.AnnouncementCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          createMany: {
            args: Prisma.AnnouncementCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnnouncementDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          update: {
            args: Prisma.AnnouncementUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          deleteMany: {
            args: Prisma.AnnouncementDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnnouncementUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnnouncementUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementPayload>;
          };
          aggregate: {
            args: Prisma.AnnouncementAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnnouncement>;
          };
          groupBy: {
            args: Prisma.AnnouncementGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AnnouncementFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AnnouncementAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AnnouncementCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnnouncementCountAggregateOutputType>
              | number;
          };
        };
      };
      AnnouncementLike: {
        payload: Prisma.$AnnouncementLikePayload<ExtArgs>;
        fields: Prisma.AnnouncementLikeFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnnouncementLikeFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnnouncementLikeFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          findFirst: {
            args: Prisma.AnnouncementLikeFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnnouncementLikeFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          findMany: {
            args: Prisma.AnnouncementLikeFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>[];
          };
          create: {
            args: Prisma.AnnouncementLikeCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          createMany: {
            args: Prisma.AnnouncementLikeCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnnouncementLikeDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          update: {
            args: Prisma.AnnouncementLikeUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          deleteMany: {
            args: Prisma.AnnouncementLikeDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnnouncementLikeUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnnouncementLikeUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementLikePayload>;
          };
          aggregate: {
            args: Prisma.AnnouncementLikeAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnnouncementLike>;
          };
          groupBy: {
            args: Prisma.AnnouncementLikeGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementLikeGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AnnouncementLikeFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AnnouncementLikeAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AnnouncementLikeCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnnouncementLikeCountAggregateOutputType>
              | number;
          };
        };
      };
      AnnouncementComment: {
        payload: Prisma.$AnnouncementCommentPayload<ExtArgs>;
        fields: Prisma.AnnouncementCommentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.AnnouncementCommentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.AnnouncementCommentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          findFirst: {
            args: Prisma.AnnouncementCommentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.AnnouncementCommentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          findMany: {
            args: Prisma.AnnouncementCommentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>[];
          };
          create: {
            args: Prisma.AnnouncementCommentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          createMany: {
            args: Prisma.AnnouncementCommentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.AnnouncementCommentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          update: {
            args: Prisma.AnnouncementCommentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          deleteMany: {
            args: Prisma.AnnouncementCommentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.AnnouncementCommentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.AnnouncementCommentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$AnnouncementCommentPayload>;
          };
          aggregate: {
            args: Prisma.AnnouncementCommentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateAnnouncementComment>;
          };
          groupBy: {
            args: Prisma.AnnouncementCommentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<AnnouncementCommentGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.AnnouncementCommentFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.AnnouncementCommentAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.AnnouncementCommentCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<AnnouncementCommentCountAggregateOutputType>
              | number;
          };
        };
      };
      ApartmentConfig: {
        payload: Prisma.$ApartmentConfigPayload<ExtArgs>;
        fields: Prisma.ApartmentConfigFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ApartmentConfigFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ApartmentConfigFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          findFirst: {
            args: Prisma.ApartmentConfigFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ApartmentConfigFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          findMany: {
            args: Prisma.ApartmentConfigFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>[];
          };
          create: {
            args: Prisma.ApartmentConfigCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          createMany: {
            args: Prisma.ApartmentConfigCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ApartmentConfigDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          update: {
            args: Prisma.ApartmentConfigUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          deleteMany: {
            args: Prisma.ApartmentConfigDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ApartmentConfigUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ApartmentConfigUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ApartmentConfigPayload>;
          };
          aggregate: {
            args: Prisma.ApartmentConfigAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateApartmentConfig>;
          };
          groupBy: {
            args: Prisma.ApartmentConfigGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ApartmentConfigGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ApartmentConfigFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ApartmentConfigAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ApartmentConfigCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<ApartmentConfigCountAggregateOutputType>
              | number;
          };
        };
      };
      Poll: {
        payload: Prisma.$PollPayload<ExtArgs>;
        fields: Prisma.PollFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PollFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PollFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          findFirst: {
            args: Prisma.PollFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PollFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          findMany: {
            args: Prisma.PollFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>[];
          };
          create: {
            args: Prisma.PollCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          createMany: {
            args: Prisma.PollCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PollDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          update: {
            args: Prisma.PollUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          deleteMany: {
            args: Prisma.PollDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PollUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PollUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollPayload>;
          };
          aggregate: {
            args: Prisma.PollAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePoll>;
          };
          groupBy: {
            args: Prisma.PollGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PollGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PollFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PollAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PollCountArgs<ExtArgs>;
            result: $Utils.Optional<PollCountAggregateOutputType> | number;
          };
        };
      };
      PollOption: {
        payload: Prisma.$PollOptionPayload<ExtArgs>;
        fields: Prisma.PollOptionFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PollOptionFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PollOptionFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          findFirst: {
            args: Prisma.PollOptionFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PollOptionFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          findMany: {
            args: Prisma.PollOptionFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>[];
          };
          create: {
            args: Prisma.PollOptionCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          createMany: {
            args: Prisma.PollOptionCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PollOptionDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          update: {
            args: Prisma.PollOptionUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          deleteMany: {
            args: Prisma.PollOptionDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PollOptionUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PollOptionUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollOptionPayload>;
          };
          aggregate: {
            args: Prisma.PollOptionAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePollOption>;
          };
          groupBy: {
            args: Prisma.PollOptionGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PollOptionGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PollOptionFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PollOptionAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PollOptionCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<PollOptionCountAggregateOutputType>
              | number;
          };
        };
      };
      PollVote: {
        payload: Prisma.$PollVotePayload<ExtArgs>;
        fields: Prisma.PollVoteFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PollVoteFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PollVoteFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          findFirst: {
            args: Prisma.PollVoteFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PollVoteFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          findMany: {
            args: Prisma.PollVoteFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>[];
          };
          create: {
            args: Prisma.PollVoteCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          createMany: {
            args: Prisma.PollVoteCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PollVoteDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          update: {
            args: Prisma.PollVoteUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          deleteMany: {
            args: Prisma.PollVoteDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PollVoteUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PollVoteUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PollVotePayload>;
          };
          aggregate: {
            args: Prisma.PollVoteAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePollVote>;
          };
          groupBy: {
            args: Prisma.PollVoteGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PollVoteGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PollVoteFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PollVoteAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PollVoteCountArgs<ExtArgs>;
            result: $Utils.Optional<PollVoteCountAggregateOutputType> | number;
          };
        };
      };
      Facility: {
        payload: Prisma.$FacilityPayload<ExtArgs>;
        fields: Prisma.FacilityFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FacilityFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FacilityFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          findFirst: {
            args: Prisma.FacilityFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FacilityFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          findMany: {
            args: Prisma.FacilityFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>[];
          };
          create: {
            args: Prisma.FacilityCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          createMany: {
            args: Prisma.FacilityCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FacilityDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          update: {
            args: Prisma.FacilityUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          deleteMany: {
            args: Prisma.FacilityDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FacilityUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FacilityUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityPayload>;
          };
          aggregate: {
            args: Prisma.FacilityAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFacility>;
          };
          groupBy: {
            args: Prisma.FacilityGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FacilityGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FacilityFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FacilityAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FacilityCountArgs<ExtArgs>;
            result: $Utils.Optional<FacilityCountAggregateOutputType> | number;
          };
        };
      };
      FacilityBooking: {
        payload: Prisma.$FacilityBookingPayload<ExtArgs>;
        fields: Prisma.FacilityBookingFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.FacilityBookingFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.FacilityBookingFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          findFirst: {
            args: Prisma.FacilityBookingFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.FacilityBookingFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          findMany: {
            args: Prisma.FacilityBookingFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>[];
          };
          create: {
            args: Prisma.FacilityBookingCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          createMany: {
            args: Prisma.FacilityBookingCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.FacilityBookingDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          update: {
            args: Prisma.FacilityBookingUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          deleteMany: {
            args: Prisma.FacilityBookingDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.FacilityBookingUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.FacilityBookingUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$FacilityBookingPayload>;
          };
          aggregate: {
            args: Prisma.FacilityBookingAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateFacilityBooking>;
          };
          groupBy: {
            args: Prisma.FacilityBookingGroupByArgs<ExtArgs>;
            result: $Utils.Optional<FacilityBookingGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.FacilityBookingFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.FacilityBookingAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.FacilityBookingCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<FacilityBookingCountAggregateOutputType>
              | number;
          };
        };
      };
      Complaint: {
        payload: Prisma.$ComplaintPayload<ExtArgs>;
        fields: Prisma.ComplaintFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.ComplaintFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.ComplaintFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          findFirst: {
            args: Prisma.ComplaintFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.ComplaintFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          findMany: {
            args: Prisma.ComplaintFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>[];
          };
          create: {
            args: Prisma.ComplaintCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          createMany: {
            args: Prisma.ComplaintCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.ComplaintDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          update: {
            args: Prisma.ComplaintUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          deleteMany: {
            args: Prisma.ComplaintDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.ComplaintUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.ComplaintUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$ComplaintPayload>;
          };
          aggregate: {
            args: Prisma.ComplaintAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateComplaint>;
          };
          groupBy: {
            args: Prisma.ComplaintGroupByArgs<ExtArgs>;
            result: $Utils.Optional<ComplaintGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.ComplaintFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.ComplaintAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.ComplaintCountArgs<ExtArgs>;
            result: $Utils.Optional<ComplaintCountAggregateOutputType> | number;
          };
        };
      };
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>;
        fields: Prisma.PaymentFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[];
          };
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>;
          };
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregatePayment>;
          };
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>;
            result: $Utils.Optional<PaymentGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.PaymentFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.PaymentAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>;
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number;
          };
        };
      };
      CommunityFinance: {
        payload: Prisma.$CommunityFinancePayload<ExtArgs>;
        fields: Prisma.CommunityFinanceFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.CommunityFinanceFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.CommunityFinanceFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          findFirst: {
            args: Prisma.CommunityFinanceFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.CommunityFinanceFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          findMany: {
            args: Prisma.CommunityFinanceFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>[];
          };
          create: {
            args: Prisma.CommunityFinanceCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          createMany: {
            args: Prisma.CommunityFinanceCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.CommunityFinanceDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          update: {
            args: Prisma.CommunityFinanceUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          deleteMany: {
            args: Prisma.CommunityFinanceDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.CommunityFinanceUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.CommunityFinanceUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$CommunityFinancePayload>;
          };
          aggregate: {
            args: Prisma.CommunityFinanceAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateCommunityFinance>;
          };
          groupBy: {
            args: Prisma.CommunityFinanceGroupByArgs<ExtArgs>;
            result: $Utils.Optional<CommunityFinanceGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.CommunityFinanceFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.CommunityFinanceAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.CommunityFinanceCountArgs<ExtArgs>;
            result:
              | $Utils.Optional<CommunityFinanceCountAggregateOutputType>
              | number;
          };
        };
      };
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>;
        fields: Prisma.MessageFieldRefs;
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null;
          };
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[];
          };
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>;
            result: BatchPayload;
          };
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>;
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>;
          };
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>;
            result: $Utils.Optional<AggregateMessage>;
          };
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>;
            result: $Utils.Optional<MessageGroupByOutputType>[];
          };
          findRaw: {
            args: Prisma.MessageFindRawArgs<ExtArgs>;
            result: JsonObject;
          };
          aggregateRaw: {
            args: Prisma.MessageAggregateRawArgs<ExtArgs>;
            result: JsonObject;
          };
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>;
            result: $Utils.Optional<MessageCountAggregateOutputType> | number;
          };
        };
      };
    };
  } & {
    other: {
      payload: any;
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject;
          result: Prisma.JsonObject;
        };
      };
    };
  };
  export const defineExtension: $Extensions.ExtendsHook<
    'define',
    Prisma.TypeMapCb,
    $Extensions.DefaultArgs
  >;
  export type DefaultPrismaClient = PrismaClient;
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources;
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string;
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat;
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     *
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     *
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     *
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[];
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number;
      timeout?: number;
    };
    /**
     * Global configuration for omitting model fields by default.
     *
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig;
  }
  export type GlobalOmitConfig = {
    user?: UserOmit;
    refreshToken?: RefreshTokenOmit;
    pushSubscription?: PushSubscriptionOmit;
    notification?: NotificationOmit;
    property?: PropertyOmit;
    announcement?: AnnouncementOmit;
    announcementLike?: AnnouncementLikeOmit;
    announcementComment?: AnnouncementCommentOmit;
    apartmentConfig?: ApartmentConfigOmit;
    poll?: PollOmit;
    pollOption?: PollOptionOmit;
    pollVote?: PollVoteOmit;
    facility?: FacilityOmit;
    facilityBooking?: FacilityBookingOmit;
    complaint?: ComplaintOmit;
    payment?: PaymentOmit;
    communityFinance?: CommunityFinanceOmit;
    message?: MessageOmit;
  };

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error';
  export type LogDefinition = {
    level: LogLevel;
    emit: 'stdout' | 'event';
  };

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> =
    T extends Array<LogLevel | LogDefinition> ? GetLogType<T[number]> : never;

  export type QueryEvent = {
    timestamp: Date;
    query: string;
    params: string;
    duration: number;
    target: string;
  };

  export type LogEvent = {
    timestamp: Date;
    message: string;
    target: string;
  };
  /* End Types for Logging */

  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy';

  // tested in getLogLevel.test.ts
  export function getLogLevel(
    log: Array<LogLevel | LogDefinition>
  ): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<
    Prisma.DefaultPrismaClient,
    runtime.ITXClientDenyList
  >;

  export type Datasource = {
    url?: string;
  };

  /**
   * Count Types
   */

  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    refreshTokens: number;
    pushSubscriptions: number;
    notifications: number;
    approvals: number;
    announcements: number;
    announcementLikes: number;
    announcementComments: number;
    createdPolls: number;
    pollVotes: number;
    facilityBookings: number;
    complaints: number;
    payments: number;
    recordedFinances: number;
    messages: number;
  };

  export type UserCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    refreshTokens?: boolean | UserCountOutputTypeCountRefreshTokensArgs;
    pushSubscriptions?: boolean | UserCountOutputTypeCountPushSubscriptionsArgs;
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs;
    approvals?: boolean | UserCountOutputTypeCountApprovalsArgs;
    announcements?: boolean | UserCountOutputTypeCountAnnouncementsArgs;
    announcementLikes?: boolean | UserCountOutputTypeCountAnnouncementLikesArgs;
    announcementComments?:
      | boolean
      | UserCountOutputTypeCountAnnouncementCommentsArgs;
    createdPolls?: boolean | UserCountOutputTypeCountCreatedPollsArgs;
    pollVotes?: boolean | UserCountOutputTypeCountPollVotesArgs;
    facilityBookings?: boolean | UserCountOutputTypeCountFacilityBookingsArgs;
    complaints?: boolean | UserCountOutputTypeCountComplaintsArgs;
    payments?: boolean | UserCountOutputTypeCountPaymentsArgs;
    recordedFinances?: boolean | UserCountOutputTypeCountRecordedFinancesArgs;
    messages?: boolean | UserCountOutputTypeCountMessagesArgs;
  };

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRefreshTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RefreshTokenWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPushSubscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PushSubscriptionWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountApprovalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementLikeWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAnnouncementCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementCommentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCreatedPollsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPollVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollVoteWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFacilityBookingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacilityBookingWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountComplaintsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ComplaintWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRecordedFinancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommunityFinanceWhereInput;
  };

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageWhereInput;
  };

  /**
   * Count Type AnnouncementCountOutputType
   */

  export type AnnouncementCountOutputType = {
    likes: number;
    comments: number;
  };

  export type AnnouncementCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    likes?: boolean | AnnouncementCountOutputTypeCountLikesArgs;
    comments?: boolean | AnnouncementCountOutputTypeCountCommentsArgs;
  };

  // Custom InputTypes
  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementCountOutputType
     */
    select?: AnnouncementCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeCountLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementLikeWhereInput;
  };

  /**
   * AnnouncementCountOutputType without action
   */
  export type AnnouncementCountOutputTypeCountCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementCommentWhereInput;
  };

  /**
   * Count Type PollCountOutputType
   */

  export type PollCountOutputType = {
    options: number;
    votes: number;
  };

  export type PollCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    options?: boolean | PollCountOutputTypeCountOptionsArgs;
    votes?: boolean | PollCountOutputTypeCountVotesArgs;
  };

  // Custom InputTypes
  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollCountOutputType
     */
    select?: PollCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeCountOptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollOptionWhereInput;
  };

  /**
   * PollCountOutputType without action
   */
  export type PollCountOutputTypeCountVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollVoteWhereInput;
  };

  /**
   * Count Type PollOptionCountOutputType
   */

  export type PollOptionCountOutputType = {
    votes: number;
  };

  export type PollOptionCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    votes?: boolean | PollOptionCountOutputTypeCountVotesArgs;
  };

  // Custom InputTypes
  /**
   * PollOptionCountOutputType without action
   */
  export type PollOptionCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOptionCountOutputType
     */
    select?: PollOptionCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * PollOptionCountOutputType without action
   */
  export type PollOptionCountOutputTypeCountVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollVoteWhereInput;
  };

  /**
   * Count Type FacilityCountOutputType
   */

  export type FacilityCountOutputType = {
    bookings: number;
  };

  export type FacilityCountOutputTypeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    bookings?: boolean | FacilityCountOutputTypeCountBookingsArgs;
  };

  // Custom InputTypes
  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityCountOutputType
     */
    select?: FacilityCountOutputTypeSelect<ExtArgs> | null;
  };

  /**
   * FacilityCountOutputType without action
   */
  export type FacilityCountOutputTypeCountBookingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacilityBookingWhereInput;
  };

  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  export type UserMinAggregateOutputType = {
    id: string | null;
    email: string | null;
    phone: string | null;
    name: string | null;
    password: string | null;
    role: $Enums.UserRole | null;
    status: $Enums.UserStatus | null;
    rejectionReason: string | null;
    provider: $Enums.AuthProvider | null;
    image: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    approvedById: string | null;
    notificationsEnabled: boolean | null;
  };

  export type UserMaxAggregateOutputType = {
    id: string | null;
    email: string | null;
    phone: string | null;
    name: string | null;
    password: string | null;
    role: $Enums.UserRole | null;
    status: $Enums.UserStatus | null;
    rejectionReason: string | null;
    provider: $Enums.AuthProvider | null;
    image: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    approvedById: string | null;
    notificationsEnabled: boolean | null;
  };

  export type UserCountAggregateOutputType = {
    id: number;
    email: number;
    phone: number;
    name: number;
    password: number;
    role: number;
    status: number;
    rejectionReason: number;
    provider: number;
    image: number;
    createdAt: number;
    updatedAt: number;
    approvedById: number;
    notificationsEnabled: number;
    _all: number;
  };

  export type UserMinAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    name?: true;
    password?: true;
    role?: true;
    status?: true;
    rejectionReason?: true;
    provider?: true;
    image?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedById?: true;
    notificationsEnabled?: true;
  };

  export type UserMaxAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    name?: true;
    password?: true;
    role?: true;
    status?: true;
    rejectionReason?: true;
    provider?: true;
    image?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedById?: true;
    notificationsEnabled?: true;
  };

  export type UserCountAggregateInputType = {
    id?: true;
    email?: true;
    phone?: true;
    name?: true;
    password?: true;
    role?: true;
    status?: true;
    rejectionReason?: true;
    provider?: true;
    image?: true;
    createdAt?: true;
    updatedAt?: true;
    approvedById?: true;
    notificationsEnabled?: true;
    _all?: true;
  };

  export type UserAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Users
     **/
    _count?: true | UserCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: UserMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: UserMaxAggregateInputType;
  };

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
    [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>;
  };

  export type UserGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: UserWhereInput;
    orderBy?:
      | UserOrderByWithAggregationInput
      | UserOrderByWithAggregationInput[];
    by: UserScalarFieldEnum[] | UserScalarFieldEnum;
    having?: UserScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: UserCountAggregateInputType | true;
    _min?: UserMinAggregateInputType;
    _max?: UserMaxAggregateInputType;
  };

  export type UserGroupByOutputType = {
    id: string;
    email: string;
    phone: string | null;
    name: string;
    password: string | null;
    role: $Enums.UserRole;
    status: $Enums.UserStatus;
    rejectionReason: string | null;
    provider: $Enums.AuthProvider;
    image: string | null;
    createdAt: Date;
    updatedAt: Date;
    approvedById: string | null;
    notificationsEnabled: boolean;
    _count: UserCountAggregateOutputType | null;
    _min: UserMinAggregateOutputType | null;
    _max: UserMaxAggregateOutputType | null;
  };

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> & {
        [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], UserGroupByOutputType[P]>
          : GetScalarType<T[P], UserGroupByOutputType[P]>;
      }
    >
  >;

  export type UserSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      email?: boolean;
      phone?: boolean;
      name?: boolean;
      password?: boolean;
      role?: boolean;
      status?: boolean;
      rejectionReason?: boolean;
      provider?: boolean;
      image?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      approvedById?: boolean;
      notificationsEnabled?: boolean;
      refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>;
      pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>;
      notifications?: boolean | User$notificationsArgs<ExtArgs>;
      property?: boolean | User$propertyArgs<ExtArgs>;
      approvedBy?: boolean | User$approvedByArgs<ExtArgs>;
      approvals?: boolean | User$approvalsArgs<ExtArgs>;
      announcements?: boolean | User$announcementsArgs<ExtArgs>;
      announcementLikes?: boolean | User$announcementLikesArgs<ExtArgs>;
      announcementComments?: boolean | User$announcementCommentsArgs<ExtArgs>;
      createdPolls?: boolean | User$createdPollsArgs<ExtArgs>;
      pollVotes?: boolean | User$pollVotesArgs<ExtArgs>;
      facilityBookings?: boolean | User$facilityBookingsArgs<ExtArgs>;
      complaints?: boolean | User$complaintsArgs<ExtArgs>;
      payments?: boolean | User$paymentsArgs<ExtArgs>;
      recordedFinances?: boolean | User$recordedFinancesArgs<ExtArgs>;
      messages?: boolean | User$messagesArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['user']
  >;

  export type UserSelectScalar = {
    id?: boolean;
    email?: boolean;
    phone?: boolean;
    name?: boolean;
    password?: boolean;
    role?: boolean;
    status?: boolean;
    rejectionReason?: boolean;
    provider?: boolean;
    image?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    approvedById?: boolean;
    notificationsEnabled?: boolean;
  };

  export type UserOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'email'
    | 'phone'
    | 'name'
    | 'password'
    | 'role'
    | 'status'
    | 'rejectionReason'
    | 'provider'
    | 'image'
    | 'createdAt'
    | 'updatedAt'
    | 'approvedById'
    | 'notificationsEnabled',
    ExtArgs['result']['user']
  >;
  export type UserInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    refreshTokens?: boolean | User$refreshTokensArgs<ExtArgs>;
    pushSubscriptions?: boolean | User$pushSubscriptionsArgs<ExtArgs>;
    notifications?: boolean | User$notificationsArgs<ExtArgs>;
    property?: boolean | User$propertyArgs<ExtArgs>;
    approvedBy?: boolean | User$approvedByArgs<ExtArgs>;
    approvals?: boolean | User$approvalsArgs<ExtArgs>;
    announcements?: boolean | User$announcementsArgs<ExtArgs>;
    announcementLikes?: boolean | User$announcementLikesArgs<ExtArgs>;
    announcementComments?: boolean | User$announcementCommentsArgs<ExtArgs>;
    createdPolls?: boolean | User$createdPollsArgs<ExtArgs>;
    pollVotes?: boolean | User$pollVotesArgs<ExtArgs>;
    facilityBookings?: boolean | User$facilityBookingsArgs<ExtArgs>;
    complaints?: boolean | User$complaintsArgs<ExtArgs>;
    payments?: boolean | User$paymentsArgs<ExtArgs>;
    recordedFinances?: boolean | User$recordedFinancesArgs<ExtArgs>;
    messages?: boolean | User$messagesArgs<ExtArgs>;
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $UserPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'User';
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[];
      pushSubscriptions: Prisma.$PushSubscriptionPayload<ExtArgs>[];
      notifications: Prisma.$NotificationPayload<ExtArgs>[];
      property: Prisma.$PropertyPayload<ExtArgs> | null;
      approvedBy: Prisma.$UserPayload<ExtArgs> | null;
      approvals: Prisma.$UserPayload<ExtArgs>[];
      announcements: Prisma.$AnnouncementPayload<ExtArgs>[];
      announcementLikes: Prisma.$AnnouncementLikePayload<ExtArgs>[];
      announcementComments: Prisma.$AnnouncementCommentPayload<ExtArgs>[];
      createdPolls: Prisma.$PollPayload<ExtArgs>[];
      pollVotes: Prisma.$PollVotePayload<ExtArgs>[];
      facilityBookings: Prisma.$FacilityBookingPayload<ExtArgs>[];
      complaints: Prisma.$ComplaintPayload<ExtArgs>[];
      payments: Prisma.$PaymentPayload<ExtArgs>[];
      recordedFinances: Prisma.$CommunityFinancePayload<ExtArgs>[];
      messages: Prisma.$MessagePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        email: string;
        phone: string | null;
        name: string;
        password: string | null;
        role: $Enums.UserRole;
        status: $Enums.UserStatus;
        rejectionReason: string | null;
        provider: $Enums.AuthProvider;
        image: string | null;
        createdAt: Date;
        updatedAt: Date;
        approvedById: string | null;
        notificationsEnabled: boolean;
      },
      ExtArgs['result']['user']
    >;
    composites: {};
  };

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> =
    $Result.GetResult<Prisma.$UserPayload, S>;

  type UserCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: UserCountAggregateInputType | true;
  };

  export interface UserDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['User'];
      meta: { name: 'User' };
    };
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
      args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     *
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     *
     */
    findMany<T extends UserFindManyArgs>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     *
     */
    create<T extends UserCreateArgs>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends UserCreateManyArgs>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     *
     */
    delete<T extends UserDeleteArgs>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends UserUpdateArgs>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends UserDeleteManyArgs>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends UserUpdateManyArgs>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
     **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends UserAggregateArgs>(
      args: Subset<T, UserAggregateArgs>
    ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetUserGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the User model
     */
    readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    refreshTokens<T extends User$refreshTokensArgs<ExtArgs> = {}>(
      args?: Subset<T, User$refreshTokensArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$RefreshTokenPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    pushSubscriptions<T extends User$pushSubscriptionsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$pushSubscriptionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PushSubscriptionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$notificationsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$NotificationPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    property<T extends User$propertyArgs<ExtArgs> = {}>(
      args?: Subset<T, User$propertyArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    approvedBy<T extends User$approvedByArgs<ExtArgs> = {}>(
      args?: Subset<T, User$approvedByArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    approvals<T extends User$approvalsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$approvalsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    announcements<T extends User$announcementsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$announcementsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    announcementLikes<T extends User$announcementLikesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$announcementLikesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementLikePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    announcementComments<T extends User$announcementCommentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$announcementCommentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementCommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    createdPolls<T extends User$createdPollsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$createdPollsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PollPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    pollVotes<T extends User$pollVotesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$pollVotesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PollVotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    facilityBookings<T extends User$facilityBookingsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$facilityBookingsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FacilityBookingPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    complaints<T extends User$complaintsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$complaintsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$ComplaintPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    payments<T extends User$paymentsArgs<ExtArgs> = {}>(
      args?: Subset<T, User$paymentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PaymentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    recordedFinances<T extends User$recordedFinancesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$recordedFinancesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$CommunityFinancePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    messages<T extends User$messagesArgs<ExtArgs> = {}>(
      args?: Subset<T, User$messagesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$MessagePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<'User', 'String'>;
    readonly email: FieldRef<'User', 'String'>;
    readonly phone: FieldRef<'User', 'String'>;
    readonly name: FieldRef<'User', 'String'>;
    readonly password: FieldRef<'User', 'String'>;
    readonly role: FieldRef<'User', 'UserRole'>;
    readonly status: FieldRef<'User', 'UserStatus'>;
    readonly rejectionReason: FieldRef<'User', 'String'>;
    readonly provider: FieldRef<'User', 'AuthProvider'>;
    readonly image: FieldRef<'User', 'String'>;
    readonly createdAt: FieldRef<'User', 'DateTime'>;
    readonly updatedAt: FieldRef<'User', 'DateTime'>;
    readonly approvedById: FieldRef<'User', 'String'>;
    readonly notificationsEnabled: FieldRef<'User', 'Boolean'>;
  }

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User findMany
   */
  export type UserFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Users from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Users.
     */
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User create
   */
  export type UserCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>;
  };

  /**
   * User createMany
   */
  export type UserCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[];
  };

  /**
   * User update
   */
  export type UserUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to update.
     */
    limit?: number;
  };

  /**
   * User upsert
   */
  export type UserUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput;
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>;
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
  };

  /**
   * User delete
   */
  export type UserDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput;
  };

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput;
    /**
     * Limit how many Users to delete.
     */
    limit?: number;
  };

  /**
   * User findRaw
   */
  export type UserFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * User.refreshTokens
   */
  export type User$refreshTokensArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    where?: RefreshTokenWhereInput;
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    cursor?: RefreshTokenWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * User.pushSubscriptions
   */
  export type User$pushSubscriptionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    where?: PushSubscriptionWhereInput;
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    cursor?: PushSubscriptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * User.notifications
   */
  export type User$notificationsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    cursor?: NotificationWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * User.property
   */
  export type User$propertyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    where?: PropertyWhereInput;
  };

  /**
   * User.approvedBy
   */
  export type User$approvedByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * User.approvals
   */
  export type User$approvalsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
    cursor?: UserWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
  };

  /**
   * User.announcements
   */
  export type User$announcementsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    where?: AnnouncementWhereInput;
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    cursor?: AnnouncementWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * User.announcementLikes
   */
  export type User$announcementLikesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    where?: AnnouncementLikeWhereInput;
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    cursor?: AnnouncementLikeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AnnouncementLikeScalarFieldEnum
      | AnnouncementLikeScalarFieldEnum[];
  };

  /**
   * User.announcementComments
   */
  export type User$announcementCommentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    where?: AnnouncementCommentWhereInput;
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    cursor?: AnnouncementCommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AnnouncementCommentScalarFieldEnum
      | AnnouncementCommentScalarFieldEnum[];
  };

  /**
   * User.createdPolls
   */
  export type User$createdPollsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    where?: PollWhereInput;
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[];
    cursor?: PollWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[];
  };

  /**
   * User.pollVotes
   */
  export type User$pollVotesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    where?: PollVoteWhereInput;
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    cursor?: PollVoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * User.facilityBookings
   */
  export type User$facilityBookingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    where?: FacilityBookingWhereInput;
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    cursor?: FacilityBookingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | FacilityBookingScalarFieldEnum
      | FacilityBookingScalarFieldEnum[];
  };

  /**
   * User.complaints
   */
  export type User$complaintsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    where?: ComplaintWhereInput;
    orderBy?:
      | ComplaintOrderByWithRelationInput
      | ComplaintOrderByWithRelationInput[];
    cursor?: ComplaintWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[];
  };

  /**
   * User.payments
   */
  export type User$paymentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    cursor?: PaymentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * User.recordedFinances
   */
  export type User$recordedFinancesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    where?: CommunityFinanceWhereInput;
    orderBy?:
      | CommunityFinanceOrderByWithRelationInput
      | CommunityFinanceOrderByWithRelationInput[];
    cursor?: CommunityFinanceWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | CommunityFinanceScalarFieldEnum
      | CommunityFinanceScalarFieldEnum[];
  };

  /**
   * User.messages
   */
  export type User$messagesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    cursor?: MessageWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * User without action
   */
  export type UserDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
  };

  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null;
    _min: RefreshTokenMinAggregateOutputType | null;
    _max: RefreshTokenMaxAggregateOutputType | null;
  };

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    revoked: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null;
    token: string | null;
    userId: string | null;
    expiresAt: Date | null;
    revoked: boolean | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type RefreshTokenCountAggregateOutputType = {
    id: number;
    token: number;
    userId: number;
    expiresAt: number;
    revoked: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type RefreshTokenMinAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    revoked?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RefreshTokenMaxAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    revoked?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type RefreshTokenCountAggregateInputType = {
    id?: true;
    token?: true;
    userId?: true;
    expiresAt?: true;
    revoked?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type RefreshTokenAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned RefreshTokens
     **/
    _count?: true | RefreshTokenCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: RefreshTokenMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: RefreshTokenMaxAggregateInputType;
  };

  export type GetRefreshTokenAggregateType<
    T extends RefreshTokenAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>;
  };

  export type RefreshTokenGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: RefreshTokenWhereInput;
    orderBy?:
      | RefreshTokenOrderByWithAggregationInput
      | RefreshTokenOrderByWithAggregationInput[];
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum;
    having?: RefreshTokenScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: RefreshTokenCountAggregateInputType | true;
    _min?: RefreshTokenMinAggregateInputType;
    _max?: RefreshTokenMaxAggregateInputType;
  };

  export type RefreshTokenGroupByOutputType = {
    id: string;
    token: string;
    userId: string;
    expiresAt: Date;
    revoked: boolean;
    createdAt: Date;
    updatedAt: Date;
    _count: RefreshTokenCountAggregateOutputType | null;
    _min: RefreshTokenMinAggregateOutputType | null;
    _max: RefreshTokenMaxAggregateOutputType | null;
  };

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<RefreshTokenGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof RefreshTokenGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>;
        }
      >
    >;

  export type RefreshTokenSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      token?: boolean;
      userId?: boolean;
      expiresAt?: boolean;
      revoked?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['refreshToken']
  >;

  export type RefreshTokenSelectScalar = {
    id?: boolean;
    token?: boolean;
    userId?: boolean;
    expiresAt?: boolean;
    revoked?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type RefreshTokenOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'token'
    | 'userId'
    | 'expiresAt'
    | 'revoked'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['refreshToken']
  >;
  export type RefreshTokenInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $RefreshTokenPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'RefreshToken';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        token: string;
        userId: string;
        expiresAt: Date;
        revoked: boolean;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['refreshToken']
    >;
    composites: {};
  };

  type RefreshTokenGetPayload<
    S extends boolean | null | undefined | RefreshTokenDefaultArgs,
  > = $Result.GetResult<Prisma.$RefreshTokenPayload, S>;

  type RefreshTokenCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    RefreshTokenFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: RefreshTokenCountAggregateInputType | true;
  };

  export interface RefreshTokenDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'];
      meta: { name: 'RefreshToken' };
    };
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(
      args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(
      args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(
      args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     *
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     *
     */
    findMany<T extends RefreshTokenFindManyArgs>(
      args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     *
     */
    create<T extends RefreshTokenCreateArgs>(
      args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends RefreshTokenCreateManyArgs>(
      args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     *
     */
    delete<T extends RefreshTokenDeleteArgs>(
      args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends RefreshTokenUpdateArgs>(
      args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(
      args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(
      args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(
      args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>
    ): Prisma__RefreshTokenClient<
      $Result.GetResult<
        Prisma.$RefreshTokenPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * @param {RefreshTokenFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const refreshToken = await prisma.refreshToken.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: RefreshTokenFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a RefreshToken.
     * @param {RefreshTokenAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const refreshToken = await prisma.refreshToken.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: RefreshTokenAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
     **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends RefreshTokenAggregateArgs>(
      args: Subset<T, RefreshTokenAggregateArgs>
    ): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>;

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetRefreshTokenGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the RefreshToken model
     */
    readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<'RefreshToken', 'String'>;
    readonly token: FieldRef<'RefreshToken', 'String'>;
    readonly userId: FieldRef<'RefreshToken', 'String'>;
    readonly expiresAt: FieldRef<'RefreshToken', 'DateTime'>;
    readonly revoked: FieldRef<'RefreshToken', 'Boolean'>;
    readonly createdAt: FieldRef<'RefreshToken', 'DateTime'>;
    readonly updatedAt: FieldRef<'RefreshToken', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?:
      | RefreshTokenOrderByWithRelationInput
      | RefreshTokenOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` RefreshTokens.
     */
    skip?: number;
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[];
  };

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>;
  };

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[];
  };

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>;
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<
      RefreshTokenUpdateManyMutationInput,
      RefreshTokenUncheckedUpdateManyInput
    >;
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput;
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number;
  };

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput;
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>;
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>;
  };

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput;
  };

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput;
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number;
  };

  /**
   * RefreshToken findRaw
   */
  export type RefreshTokenFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * RefreshToken aggregateRaw
   */
  export type RefreshTokenAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null;
  };

  /**
   * Model PushSubscription
   */

  export type AggregatePushSubscription = {
    _count: PushSubscriptionCountAggregateOutputType | null;
    _min: PushSubscriptionMinAggregateOutputType | null;
    _max: PushSubscriptionMaxAggregateOutputType | null;
  };

  export type PushSubscriptionMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    endpoint: string | null;
    p256dh: string | null;
    auth: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PushSubscriptionMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    endpoint: string | null;
    p256dh: string | null;
    auth: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PushSubscriptionCountAggregateOutputType = {
    id: number;
    userId: number;
    endpoint: number;
    p256dh: number;
    auth: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PushSubscriptionMinAggregateInputType = {
    id?: true;
    userId?: true;
    endpoint?: true;
    p256dh?: true;
    auth?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PushSubscriptionMaxAggregateInputType = {
    id?: true;
    userId?: true;
    endpoint?: true;
    p256dh?: true;
    auth?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PushSubscriptionCountAggregateInputType = {
    id?: true;
    userId?: true;
    endpoint?: true;
    p256dh?: true;
    auth?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PushSubscriptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PushSubscription to aggregate.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PushSubscriptions
     **/
    _count?: true | PushSubscriptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PushSubscriptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PushSubscriptionMaxAggregateInputType;
  };

  export type GetPushSubscriptionAggregateType<
    T extends PushSubscriptionAggregateArgs,
  > = {
    [P in keyof T & keyof AggregatePushSubscription]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePushSubscription[P]>
      : GetScalarType<T[P], AggregatePushSubscription[P]>;
  };

  export type PushSubscriptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PushSubscriptionWhereInput;
    orderBy?:
      | PushSubscriptionOrderByWithAggregationInput
      | PushSubscriptionOrderByWithAggregationInput[];
    by: PushSubscriptionScalarFieldEnum[] | PushSubscriptionScalarFieldEnum;
    having?: PushSubscriptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PushSubscriptionCountAggregateInputType | true;
    _min?: PushSubscriptionMinAggregateInputType;
    _max?: PushSubscriptionMaxAggregateInputType;
  };

  export type PushSubscriptionGroupByOutputType = {
    id: string;
    userId: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt: Date;
    updatedAt: Date;
    _count: PushSubscriptionCountAggregateOutputType | null;
    _min: PushSubscriptionMinAggregateOutputType | null;
    _max: PushSubscriptionMaxAggregateOutputType | null;
  };

  type GetPushSubscriptionGroupByPayload<
    T extends PushSubscriptionGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PushSubscriptionGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof PushSubscriptionGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>
          : GetScalarType<T[P], PushSubscriptionGroupByOutputType[P]>;
      }
    >
  >;

  export type PushSubscriptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      endpoint?: boolean;
      p256dh?: boolean;
      auth?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['pushSubscription']
  >;

  export type PushSubscriptionSelectScalar = {
    id?: boolean;
    userId?: boolean;
    endpoint?: boolean;
    p256dh?: boolean;
    auth?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PushSubscriptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'endpoint'
    | 'p256dh'
    | 'auth'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['pushSubscription']
  >;
  export type PushSubscriptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PushSubscriptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PushSubscription';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        endpoint: string;
        p256dh: string;
        auth: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['pushSubscription']
    >;
    composites: {};
  };

  type PushSubscriptionGetPayload<
    S extends boolean | null | undefined | PushSubscriptionDefaultArgs,
  > = $Result.GetResult<Prisma.$PushSubscriptionPayload, S>;

  type PushSubscriptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PushSubscriptionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PushSubscriptionCountAggregateInputType | true;
  };

  export interface PushSubscriptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PushSubscription'];
      meta: { name: 'PushSubscription' };
    };
    /**
     * Find zero or one PushSubscription that matches the filter.
     * @param {PushSubscriptionFindUniqueArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PushSubscriptionFindUniqueArgs>(
      args: SelectSubset<T, PushSubscriptionFindUniqueArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PushSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PushSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PushSubscriptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PushSubscriptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PushSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PushSubscriptionFindFirstArgs>(
      args?: SelectSubset<T, PushSubscriptionFindFirstArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PushSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindFirstOrThrowArgs} args - Arguments to find a PushSubscription
     * @example
     * // Get one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PushSubscriptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PushSubscriptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany()
     *
     * // Get first 10 PushSubscriptions
     * const pushSubscriptions = await prisma.pushSubscription.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pushSubscriptionWithIdOnly = await prisma.pushSubscription.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PushSubscriptionFindManyArgs>(
      args?: SelectSubset<T, PushSubscriptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PushSubscription.
     * @param {PushSubscriptionCreateArgs} args - Arguments to create a PushSubscription.
     * @example
     * // Create one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.create({
     *   data: {
     *     // ... data to create a PushSubscription
     *   }
     * })
     *
     */
    create<T extends PushSubscriptionCreateArgs>(
      args: SelectSubset<T, PushSubscriptionCreateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PushSubscriptions.
     * @param {PushSubscriptionCreateManyArgs} args - Arguments to create many PushSubscriptions.
     * @example
     * // Create many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PushSubscriptionCreateManyArgs>(
      args?: SelectSubset<T, PushSubscriptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PushSubscription.
     * @param {PushSubscriptionDeleteArgs} args - Arguments to delete one PushSubscription.
     * @example
     * // Delete one PushSubscription
     * const PushSubscription = await prisma.pushSubscription.delete({
     *   where: {
     *     // ... filter to delete one PushSubscription
     *   }
     * })
     *
     */
    delete<T extends PushSubscriptionDeleteArgs>(
      args: SelectSubset<T, PushSubscriptionDeleteArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PushSubscription.
     * @param {PushSubscriptionUpdateArgs} args - Arguments to update one PushSubscription.
     * @example
     * // Update one PushSubscription
     * const pushSubscription = await prisma.pushSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PushSubscriptionUpdateArgs>(
      args: SelectSubset<T, PushSubscriptionUpdateArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PushSubscriptions.
     * @param {PushSubscriptionDeleteManyArgs} args - Arguments to filter PushSubscriptions to delete.
     * @example
     * // Delete a few PushSubscriptions
     * const { count } = await prisma.pushSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PushSubscriptionDeleteManyArgs>(
      args?: SelectSubset<T, PushSubscriptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PushSubscriptions
     * const pushSubscription = await prisma.pushSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PushSubscriptionUpdateManyArgs>(
      args: SelectSubset<T, PushSubscriptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PushSubscription.
     * @param {PushSubscriptionUpsertArgs} args - Arguments to update or create a PushSubscription.
     * @example
     * // Update or create a PushSubscription
     * const pushSubscription = await prisma.pushSubscription.upsert({
     *   create: {
     *     // ... data to create a PushSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PushSubscription we want to update
     *   }
     * })
     */
    upsert<T extends PushSubscriptionUpsertArgs>(
      args: SelectSubset<T, PushSubscriptionUpsertArgs<ExtArgs>>
    ): Prisma__PushSubscriptionClient<
      $Result.GetResult<
        Prisma.$PushSubscriptionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PushSubscriptions that matches the filter.
     * @param {PushSubscriptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pushSubscription = await prisma.pushSubscription.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: PushSubscriptionFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a PushSubscription.
     * @param {PushSubscriptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pushSubscription = await prisma.pushSubscription.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: PushSubscriptionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of PushSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionCountArgs} args - Arguments to filter PushSubscriptions to count.
     * @example
     * // Count the number of PushSubscriptions
     * const count = await prisma.pushSubscription.count({
     *   where: {
     *     // ... the filter for the PushSubscriptions we want to count
     *   }
     * })
     **/
    count<T extends PushSubscriptionCountArgs>(
      args?: Subset<T, PushSubscriptionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PushSubscriptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PushSubscriptionAggregateArgs>(
      args: Subset<T, PushSubscriptionAggregateArgs>
    ): Prisma.PrismaPromise<GetPushSubscriptionAggregateType<T>>;

    /**
     * Group by PushSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PushSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PushSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PushSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: PushSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PushSubscriptionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPushSubscriptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PushSubscription model
     */
    readonly fields: PushSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PushSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PushSubscriptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PushSubscription model
   */
  interface PushSubscriptionFieldRefs {
    readonly id: FieldRef<'PushSubscription', 'String'>;
    readonly userId: FieldRef<'PushSubscription', 'String'>;
    readonly endpoint: FieldRef<'PushSubscription', 'String'>;
    readonly p256dh: FieldRef<'PushSubscription', 'String'>;
    readonly auth: FieldRef<'PushSubscription', 'String'>;
    readonly createdAt: FieldRef<'PushSubscription', 'DateTime'>;
    readonly updatedAt: FieldRef<'PushSubscription', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PushSubscription findUnique
   */
  export type PushSubscriptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription findUniqueOrThrow
   */
  export type PushSubscriptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription findFirst
   */
  export type PushSubscriptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription findFirstOrThrow
   */
  export type PushSubscriptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscription to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PushSubscriptions.
     */
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription findMany
   */
  export type PushSubscriptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter, which PushSubscriptions to fetch.
     */
    where?: PushSubscriptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PushSubscriptions to fetch.
     */
    orderBy?:
      | PushSubscriptionOrderByWithRelationInput
      | PushSubscriptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PushSubscriptions.
     */
    cursor?: PushSubscriptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PushSubscriptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PushSubscriptions.
     */
    skip?: number;
    distinct?:
      | PushSubscriptionScalarFieldEnum
      | PushSubscriptionScalarFieldEnum[];
  };

  /**
   * PushSubscription create
   */
  export type PushSubscriptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a PushSubscription.
     */
    data: XOR<
      PushSubscriptionCreateInput,
      PushSubscriptionUncheckedCreateInput
    >;
  };

  /**
   * PushSubscription createMany
   */
  export type PushSubscriptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PushSubscriptions.
     */
    data: PushSubscriptionCreateManyInput | PushSubscriptionCreateManyInput[];
  };

  /**
   * PushSubscription update
   */
  export type PushSubscriptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a PushSubscription.
     */
    data: XOR<
      PushSubscriptionUpdateInput,
      PushSubscriptionUncheckedUpdateInput
    >;
    /**
     * Choose, which PushSubscription to update.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription updateMany
   */
  export type PushSubscriptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PushSubscriptions.
     */
    data: XOR<
      PushSubscriptionUpdateManyMutationInput,
      PushSubscriptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PushSubscriptions to update
     */
    where?: PushSubscriptionWhereInput;
    /**
     * Limit how many PushSubscriptions to update.
     */
    limit?: number;
  };

  /**
   * PushSubscription upsert
   */
  export type PushSubscriptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the PushSubscription to update in case it exists.
     */
    where: PushSubscriptionWhereUniqueInput;
    /**
     * In case the PushSubscription found by the `where` argument doesn't exist, create a new PushSubscription with this data.
     */
    create: XOR<
      PushSubscriptionCreateInput,
      PushSubscriptionUncheckedCreateInput
    >;
    /**
     * In case the PushSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      PushSubscriptionUpdateInput,
      PushSubscriptionUncheckedUpdateInput
    >;
  };

  /**
   * PushSubscription delete
   */
  export type PushSubscriptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
    /**
     * Filter which PushSubscription to delete.
     */
    where: PushSubscriptionWhereUniqueInput;
  };

  /**
   * PushSubscription deleteMany
   */
  export type PushSubscriptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PushSubscriptions to delete
     */
    where?: PushSubscriptionWhereInput;
    /**
     * Limit how many PushSubscriptions to delete.
     */
    limit?: number;
  };

  /**
   * PushSubscription findRaw
   */
  export type PushSubscriptionFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PushSubscription aggregateRaw
   */
  export type PushSubscriptionAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PushSubscription without action
   */
  export type PushSubscriptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PushSubscription
     */
    select?: PushSubscriptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PushSubscription
     */
    omit?: PushSubscriptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PushSubscriptionInclude<ExtArgs> | null;
  };

  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  export type NotificationMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    read: boolean | null;
    link: string | null;
    createdAt: Date | null;
  };

  export type NotificationMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    title: string | null;
    message: string | null;
    type: string | null;
    read: boolean | null;
    link: string | null;
    createdAt: Date | null;
  };

  export type NotificationCountAggregateOutputType = {
    id: number;
    userId: number;
    title: number;
    message: number;
    type: number;
    read: number;
    link: number;
    createdAt: number;
    _all: number;
  };

  export type NotificationMinAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    read?: true;
    link?: true;
    createdAt?: true;
  };

  export type NotificationMaxAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    read?: true;
    link?: true;
    createdAt?: true;
  };

  export type NotificationCountAggregateInputType = {
    id?: true;
    userId?: true;
    title?: true;
    message?: true;
    type?: true;
    read?: true;
    link?: true;
    createdAt?: true;
    _all?: true;
  };

  export type NotificationAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Notifications
     **/
    _count?: true | NotificationCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: NotificationMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: NotificationMaxAggregateInputType;
  };

  export type GetNotificationAggregateType<
    T extends NotificationAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>;
  };

  export type NotificationGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: NotificationWhereInput;
    orderBy?:
      | NotificationOrderByWithAggregationInput
      | NotificationOrderByWithAggregationInput[];
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum;
    having?: NotificationScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: NotificationCountAggregateInputType | true;
    _min?: NotificationMinAggregateInputType;
    _max?: NotificationMaxAggregateInputType;
  };

  export type NotificationGroupByOutputType = {
    id: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    read: boolean;
    link: string | null;
    createdAt: Date;
    _count: NotificationCountAggregateOutputType | null;
    _min: NotificationMinAggregateOutputType | null;
    _max: NotificationMaxAggregateOutputType | null;
  };

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<NotificationGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof NotificationGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>;
        }
      >
    >;

  export type NotificationSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      title?: boolean;
      message?: boolean;
      type?: boolean;
      read?: boolean;
      link?: boolean;
      createdAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['notification']
  >;

  export type NotificationSelectScalar = {
    id?: boolean;
    userId?: boolean;
    title?: boolean;
    message?: boolean;
    type?: boolean;
    read?: boolean;
    link?: boolean;
    createdAt?: boolean;
  };

  export type NotificationOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'title'
    | 'message'
    | 'type'
    | 'read'
    | 'link'
    | 'createdAt',
    ExtArgs['result']['notification']
  >;
  export type NotificationInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $NotificationPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Notification';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        title: string;
        message: string;
        type: string;
        read: boolean;
        link: string | null;
        createdAt: Date;
      },
      ExtArgs['result']['notification']
    >;
    composites: {};
  };

  type NotificationGetPayload<
    S extends boolean | null | undefined | NotificationDefaultArgs,
  > = $Result.GetResult<Prisma.$NotificationPayload, S>;

  type NotificationCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    NotificationFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: NotificationCountAggregateInputType | true;
  };

  export interface NotificationDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Notification'];
      meta: { name: 'Notification' };
    };
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(
      args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(
      args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(
      args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     *
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     *
     */
    findMany<T extends NotificationFindManyArgs>(
      args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     *
     */
    create<T extends NotificationCreateArgs>(
      args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends NotificationCreateManyArgs>(
      args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     *
     */
    delete<T extends NotificationDeleteArgs>(
      args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends NotificationUpdateArgs>(
      args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends NotificationDeleteManyArgs>(
      args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends NotificationUpdateManyArgs>(
      args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(
      args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>
    ): Prisma__NotificationClient<
      $Result.GetResult<
        Prisma.$NotificationPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Notifications that matches the filter.
     * @param {NotificationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const notification = await prisma.notification.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: NotificationFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Notification.
     * @param {NotificationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const notification = await prisma.notification.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: NotificationAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
     **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends NotificationAggregateArgs>(
      args: Subset<T, NotificationAggregateArgs>
    ): Prisma.PrismaPromise<GetNotificationAggregateType<T>>;

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetNotificationGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Notification model
     */
    readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<'Notification', 'String'>;
    readonly userId: FieldRef<'Notification', 'String'>;
    readonly title: FieldRef<'Notification', 'String'>;
    readonly message: FieldRef<'Notification', 'String'>;
    readonly type: FieldRef<'Notification', 'String'>;
    readonly read: FieldRef<'Notification', 'Boolean'>;
    readonly link: FieldRef<'Notification', 'String'>;
    readonly createdAt: FieldRef<'Notification', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Notifications to fetch.
     */
    orderBy?:
      | NotificationOrderByWithRelationInput
      | NotificationOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Notifications.
     */
    skip?: number;
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[];
  };

  /**
   * Notification create
   */
  export type NotificationCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
  };

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[];
  };

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyInput
    >;
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to update.
     */
    limit?: number;
  };

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput;
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>;
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>;
  };

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput;
  };

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput;
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number;
  };

  /**
   * Notification findRaw
   */
  export type NotificationFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Notification aggregateRaw
   */
  export type NotificationAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null;
  };

  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null;
    _min: PropertyMinAggregateOutputType | null;
    _max: PropertyMaxAggregateOutputType | null;
  };

  export type PropertyMinAggregateOutputType = {
    id: string | null;
    block: string | null;
    floor: string | null;
    flatNumber: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PropertyMaxAggregateOutputType = {
    id: string | null;
    block: string | null;
    floor: string | null;
    flatNumber: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PropertyCountAggregateOutputType = {
    id: number;
    block: number;
    floor: number;
    flatNumber: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PropertyMinAggregateInputType = {
    id?: true;
    block?: true;
    floor?: true;
    flatNumber?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PropertyMaxAggregateInputType = {
    id?: true;
    block?: true;
    floor?: true;
    flatNumber?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PropertyCountAggregateInputType = {
    id?: true;
    block?: true;
    floor?: true;
    flatNumber?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PropertyAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Properties to fetch.
     */
    orderBy?:
      | PropertyOrderByWithRelationInput
      | PropertyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Properties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Properties
     **/
    _count?: true | PropertyCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PropertyMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PropertyMaxAggregateInputType;
  };

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
    [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>;
  };

  export type PropertyGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PropertyWhereInput;
    orderBy?:
      | PropertyOrderByWithAggregationInput
      | PropertyOrderByWithAggregationInput[];
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum;
    having?: PropertyScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PropertyCountAggregateInputType | true;
    _min?: PropertyMinAggregateInputType;
    _max?: PropertyMaxAggregateInputType;
  };

  export type PropertyGroupByOutputType = {
    id: string;
    block: string;
    floor: string;
    flatNumber: string;
    userId: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: PropertyCountAggregateOutputType | null;
    _min: PropertyMinAggregateOutputType | null;
    _max: PropertyMaxAggregateOutputType | null;
  };

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PropertyGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PropertyGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>;
        }
      >
    >;

  export type PropertySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      block?: boolean;
      floor?: boolean;
      flatNumber?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | Property$userArgs<ExtArgs>;
    },
    ExtArgs['result']['property']
  >;

  export type PropertySelectScalar = {
    id?: boolean;
    block?: boolean;
    floor?: boolean;
    flatNumber?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PropertyOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'block'
    | 'floor'
    | 'flatNumber'
    | 'userId'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['property']
  >;
  export type PropertyInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | Property$userArgs<ExtArgs>;
  };

  export type $PropertyPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Property';
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        block: string;
        floor: string;
        flatNumber: string;
        userId: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['property']
    >;
    composites: {};
  };

  type PropertyGetPayload<
    S extends boolean | null | undefined | PropertyDefaultArgs,
  > = $Result.GetResult<Prisma.$PropertyPayload, S>;

  type PropertyCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PropertyCountAggregateInputType | true;
  };

  export interface PropertyDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Property'];
      meta: { name: 'Property' };
    };
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(
      args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(
      args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     *
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PropertyFindManyArgs>(
      args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     *
     */
    create<T extends PropertyCreateArgs>(
      args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PropertyCreateManyArgs>(
      args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     *
     */
    delete<T extends PropertyDeleteArgs>(
      args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PropertyUpdateArgs>(
      args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PropertyDeleteManyArgs>(
      args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PropertyUpdateManyArgs>(
      args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(
      args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>
    ): Prisma__PropertyClient<
      $Result.GetResult<
        Prisma.$PropertyPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Properties that matches the filter.
     * @param {PropertyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const property = await prisma.property.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PropertyFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Property.
     * @param {PropertyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const property = await prisma.property.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: PropertyAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
     **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PropertyAggregateArgs>(
      args: Subset<T, PropertyAggregateArgs>
    ): Prisma.PrismaPromise<GetPropertyAggregateType<T>>;

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPropertyGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Property model
     */
    readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends Property$userArgs<ExtArgs> = {}>(
      args?: Subset<T, Property$userArgs<ExtArgs>>
    ): Prisma__UserClient<
      $Result.GetResult<
        Prisma.$UserPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<'Property', 'String'>;
    readonly block: FieldRef<'Property', 'String'>;
    readonly floor: FieldRef<'Property', 'String'>;
    readonly flatNumber: FieldRef<'Property', 'String'>;
    readonly userId: FieldRef<'Property', 'String'>;
    readonly createdAt: FieldRef<'Property', 'DateTime'>;
    readonly updatedAt: FieldRef<'Property', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput;
  };

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput;
  };

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Properties to fetch.
     */
    orderBy?:
      | PropertyOrderByWithRelationInput
      | PropertyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Properties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[];
  };

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Properties to fetch.
     */
    orderBy?:
      | PropertyOrderByWithRelationInput
      | PropertyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Properties.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[];
  };

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Properties to fetch.
     */
    orderBy?:
      | PropertyOrderByWithRelationInput
      | PropertyOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Properties.
     */
    skip?: number;
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[];
  };

  /**
   * Property create
   */
  export type PropertyCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>;
  };

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[];
  };

  /**
   * Property update
   */
  export type PropertyUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>;
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput;
  };

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Properties.
     */
    data: XOR<
      PropertyUpdateManyMutationInput,
      PropertyUncheckedUpdateManyInput
    >;
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput;
    /**
     * Limit how many Properties to update.
     */
    limit?: number;
  };

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput;
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>;
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>;
  };

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput;
  };

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput;
    /**
     * Limit how many Properties to delete.
     */
    limit?: number;
  };

  /**
   * Property findRaw
   */
  export type PropertyFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Property aggregateRaw
   */
  export type PropertyAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Property.user
   */
  export type Property$userArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null;
    where?: UserWhereInput;
  };

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null;
  };

  /**
   * Model Announcement
   */

  export type AggregateAnnouncement = {
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  export type AnnouncementMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    content: string | null;
    imageUrl: string | null;
    authorId: string | null;
    commentsEnabled: boolean | null;
    isPinned: boolean | null;
    pinnedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    content: string | null;
    imageUrl: string | null;
    authorId: string | null;
    commentsEnabled: boolean | null;
    isPinned: boolean | null;
    pinnedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementCountAggregateOutputType = {
    id: number;
    title: number;
    content: number;
    imageUrl: number;
    authorId: number;
    commentsEnabled: number;
    isPinned: number;
    pinnedAt: number;
    expiresAt: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AnnouncementMinAggregateInputType = {
    id?: true;
    title?: true;
    content?: true;
    imageUrl?: true;
    authorId?: true;
    commentsEnabled?: true;
    isPinned?: true;
    pinnedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementMaxAggregateInputType = {
    id?: true;
    title?: true;
    content?: true;
    imageUrl?: true;
    authorId?: true;
    commentsEnabled?: true;
    isPinned?: true;
    pinnedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementCountAggregateInputType = {
    id?: true;
    title?: true;
    content?: true;
    imageUrl?: true;
    authorId?: true;
    commentsEnabled?: true;
    isPinned?: true;
    pinnedAt?: true;
    expiresAt?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AnnouncementAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcement to aggregate.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Announcements
     **/
    _count?: true | AnnouncementCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnnouncementMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type GetAnnouncementAggregateType<
    T extends AnnouncementAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnnouncement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncement[P]>
      : GetScalarType<T[P], AggregateAnnouncement[P]>;
  };

  export type AnnouncementGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementWhereInput;
    orderBy?:
      | AnnouncementOrderByWithAggregationInput
      | AnnouncementOrderByWithAggregationInput[];
    by: AnnouncementScalarFieldEnum[] | AnnouncementScalarFieldEnum;
    having?: AnnouncementScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnnouncementCountAggregateInputType | true;
    _min?: AnnouncementMinAggregateInputType;
    _max?: AnnouncementMaxAggregateInputType;
  };

  export type AnnouncementGroupByOutputType = {
    id: string;
    title: string;
    content: string;
    imageUrl: string | null;
    authorId: string;
    commentsEnabled: boolean;
    isPinned: boolean;
    pinnedAt: Date | null;
    expiresAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    _count: AnnouncementCountAggregateOutputType | null;
    _min: AnnouncementMinAggregateOutputType | null;
    _max: AnnouncementMaxAggregateOutputType | null;
  };

  type GetAnnouncementGroupByPayload<T extends AnnouncementGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<AnnouncementGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof AnnouncementGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>
            : GetScalarType<T[P], AnnouncementGroupByOutputType[P]>;
        }
      >
    >;

  export type AnnouncementSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      content?: boolean;
      imageUrl?: boolean;
      authorId?: boolean;
      commentsEnabled?: boolean;
      isPinned?: boolean;
      pinnedAt?: boolean;
      expiresAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      author?: boolean | UserDefaultArgs<ExtArgs>;
      likes?: boolean | Announcement$likesArgs<ExtArgs>;
      comments?: boolean | Announcement$commentsArgs<ExtArgs>;
      poll?: boolean | Announcement$pollArgs<ExtArgs>;
      _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['announcement']
  >;

  export type AnnouncementSelectScalar = {
    id?: boolean;
    title?: boolean;
    content?: boolean;
    imageUrl?: boolean;
    authorId?: boolean;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: boolean;
    expiresAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AnnouncementOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'content'
    | 'imageUrl'
    | 'authorId'
    | 'commentsEnabled'
    | 'isPinned'
    | 'pinnedAt'
    | 'expiresAt'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['announcement']
  >;
  export type AnnouncementInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    author?: boolean | UserDefaultArgs<ExtArgs>;
    likes?: boolean | Announcement$likesArgs<ExtArgs>;
    comments?: boolean | Announcement$commentsArgs<ExtArgs>;
    poll?: boolean | Announcement$pollArgs<ExtArgs>;
    _count?: boolean | AnnouncementCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $AnnouncementPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Announcement';
    objects: {
      author: Prisma.$UserPayload<ExtArgs>;
      likes: Prisma.$AnnouncementLikePayload<ExtArgs>[];
      comments: Prisma.$AnnouncementCommentPayload<ExtArgs>[];
      poll: Prisma.$PollPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        content: string;
        imageUrl: string | null;
        authorId: string;
        commentsEnabled: boolean;
        isPinned: boolean;
        pinnedAt: Date | null;
        expiresAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['announcement']
    >;
    composites: {};
  };

  type AnnouncementGetPayload<
    S extends boolean | null | undefined | AnnouncementDefaultArgs,
  > = $Result.GetResult<Prisma.$AnnouncementPayload, S>;

  type AnnouncementCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnnouncementFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AnnouncementCountAggregateInputType | true;
  };

  export interface AnnouncementDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Announcement'];
      meta: { name: 'Announcement' };
    };
    /**
     * Find zero or one Announcement that matches the filter.
     * @param {AnnouncementFindUniqueArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementFindUniqueArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Announcement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementFindUniqueOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnnouncementFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Announcement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementFindFirstArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Announcement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindFirstOrThrowArgs} args - Arguments to find a Announcement
     * @example
     * // Get one Announcement
     * const announcement = await prisma.announcement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnouncementFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Announcements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Announcements
     * const announcements = await prisma.announcement.findMany()
     *
     * // Get first 10 Announcements
     * const announcements = await prisma.announcement.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const announcementWithIdOnly = await prisma.announcement.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnnouncementFindManyArgs>(
      args?: SelectSubset<T, AnnouncementFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Announcement.
     * @param {AnnouncementCreateArgs} args - Arguments to create a Announcement.
     * @example
     * // Create one Announcement
     * const Announcement = await prisma.announcement.create({
     *   data: {
     *     // ... data to create a Announcement
     *   }
     * })
     *
     */
    create<T extends AnnouncementCreateArgs>(
      args: SelectSubset<T, AnnouncementCreateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Announcements.
     * @param {AnnouncementCreateManyArgs} args - Arguments to create many Announcements.
     * @example
     * // Create many Announcements
     * const announcement = await prisma.announcement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnnouncementCreateManyArgs>(
      args?: SelectSubset<T, AnnouncementCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Announcement.
     * @param {AnnouncementDeleteArgs} args - Arguments to delete one Announcement.
     * @example
     * // Delete one Announcement
     * const Announcement = await prisma.announcement.delete({
     *   where: {
     *     // ... filter to delete one Announcement
     *   }
     * })
     *
     */
    delete<T extends AnnouncementDeleteArgs>(
      args: SelectSubset<T, AnnouncementDeleteArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Announcement.
     * @param {AnnouncementUpdateArgs} args - Arguments to update one Announcement.
     * @example
     * // Update one Announcement
     * const announcement = await prisma.announcement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnnouncementUpdateArgs>(
      args: SelectSubset<T, AnnouncementUpdateArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Announcements.
     * @param {AnnouncementDeleteManyArgs} args - Arguments to filter Announcements to delete.
     * @example
     * // Delete a few Announcements
     * const { count } = await prisma.announcement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnnouncementDeleteManyArgs>(
      args?: SelectSubset<T, AnnouncementDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Announcements
     * const announcement = await prisma.announcement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnnouncementUpdateManyArgs>(
      args: SelectSubset<T, AnnouncementUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Announcement.
     * @param {AnnouncementUpsertArgs} args - Arguments to update or create a Announcement.
     * @example
     * // Update or create a Announcement
     * const announcement = await prisma.announcement.upsert({
     *   create: {
     *     // ... data to create a Announcement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Announcement we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementUpsertArgs>(
      args: SelectSubset<T, AnnouncementUpsertArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Announcements that matches the filter.
     * @param {AnnouncementFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const announcement = await prisma.announcement.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: AnnouncementFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Announcement.
     * @param {AnnouncementAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const announcement = await prisma.announcement.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AnnouncementAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Announcements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCountArgs} args - Arguments to filter Announcements to count.
     * @example
     * // Count the number of Announcements
     * const count = await prisma.announcement.count({
     *   where: {
     *     // ... the filter for the Announcements we want to count
     *   }
     * })
     **/
    count<T extends AnnouncementCountArgs>(
      args?: Subset<T, AnnouncementCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnnouncementAggregateArgs>(
      args: Subset<T, AnnouncementAggregateArgs>
    ): Prisma.PrismaPromise<GetAnnouncementAggregateType<T>>;

    /**
     * Group by Announcement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnnouncementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnnouncementGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAnnouncementGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Announcement model
     */
    readonly fields: AnnouncementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Announcement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    author<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    likes<T extends Announcement$likesArgs<ExtArgs> = {}>(
      args?: Subset<T, Announcement$likesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementLikePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    comments<T extends Announcement$commentsArgs<ExtArgs> = {}>(
      args?: Subset<T, Announcement$commentsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$AnnouncementCommentPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    poll<T extends Announcement$pollArgs<ExtArgs> = {}>(
      args?: Subset<T, Announcement$pollArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Announcement model
   */
  interface AnnouncementFieldRefs {
    readonly id: FieldRef<'Announcement', 'String'>;
    readonly title: FieldRef<'Announcement', 'String'>;
    readonly content: FieldRef<'Announcement', 'String'>;
    readonly imageUrl: FieldRef<'Announcement', 'String'>;
    readonly authorId: FieldRef<'Announcement', 'String'>;
    readonly commentsEnabled: FieldRef<'Announcement', 'Boolean'>;
    readonly isPinned: FieldRef<'Announcement', 'Boolean'>;
    readonly pinnedAt: FieldRef<'Announcement', 'DateTime'>;
    readonly expiresAt: FieldRef<'Announcement', 'DateTime'>;
    readonly createdAt: FieldRef<'Announcement', 'DateTime'>;
    readonly updatedAt: FieldRef<'Announcement', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Announcement findUnique
   */
  export type AnnouncementFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findUniqueOrThrow
   */
  export type AnnouncementFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement findFirst
   */
  export type AnnouncementFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findFirstOrThrow
   */
  export type AnnouncementFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcement to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Announcements.
     */
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement findMany
   */
  export type AnnouncementFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter, which Announcements to fetch.
     */
    where?: AnnouncementWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Announcements to fetch.
     */
    orderBy?:
      | AnnouncementOrderByWithRelationInput
      | AnnouncementOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Announcements.
     */
    cursor?: AnnouncementWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Announcements from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Announcements.
     */
    skip?: number;
    distinct?: AnnouncementScalarFieldEnum | AnnouncementScalarFieldEnum[];
  };

  /**
   * Announcement create
   */
  export type AnnouncementCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to create a Announcement.
     */
    data: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
  };

  /**
   * Announcement createMany
   */
  export type AnnouncementCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Announcements.
     */
    data: AnnouncementCreateManyInput | AnnouncementCreateManyInput[];
  };

  /**
   * Announcement update
   */
  export type AnnouncementUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The data needed to update a Announcement.
     */
    data: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
    /**
     * Choose, which Announcement to update.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement updateMany
   */
  export type AnnouncementUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Announcements.
     */
    data: XOR<
      AnnouncementUpdateManyMutationInput,
      AnnouncementUncheckedUpdateManyInput
    >;
    /**
     * Filter which Announcements to update
     */
    where?: AnnouncementWhereInput;
    /**
     * Limit how many Announcements to update.
     */
    limit?: number;
  };

  /**
   * Announcement upsert
   */
  export type AnnouncementUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * The filter to search for the Announcement to update in case it exists.
     */
    where: AnnouncementWhereUniqueInput;
    /**
     * In case the Announcement found by the `where` argument doesn't exist, create a new Announcement with this data.
     */
    create: XOR<AnnouncementCreateInput, AnnouncementUncheckedCreateInput>;
    /**
     * In case the Announcement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AnnouncementUpdateInput, AnnouncementUncheckedUpdateInput>;
  };

  /**
   * Announcement delete
   */
  export type AnnouncementDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    /**
     * Filter which Announcement to delete.
     */
    where: AnnouncementWhereUniqueInput;
  };

  /**
   * Announcement deleteMany
   */
  export type AnnouncementDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Announcements to delete
     */
    where?: AnnouncementWhereInput;
    /**
     * Limit how many Announcements to delete.
     */
    limit?: number;
  };

  /**
   * Announcement findRaw
   */
  export type AnnouncementFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Announcement aggregateRaw
   */
  export type AnnouncementAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Announcement.likes
   */
  export type Announcement$likesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    where?: AnnouncementLikeWhereInput;
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    cursor?: AnnouncementLikeWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AnnouncementLikeScalarFieldEnum
      | AnnouncementLikeScalarFieldEnum[];
  };

  /**
   * Announcement.comments
   */
  export type Announcement$commentsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    where?: AnnouncementCommentWhereInput;
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    cursor?: AnnouncementCommentWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | AnnouncementCommentScalarFieldEnum
      | AnnouncementCommentScalarFieldEnum[];
  };

  /**
   * Announcement.poll
   */
  export type Announcement$pollArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    where?: PollWhereInput;
  };

  /**
   * Announcement without action
   */
  export type AnnouncementDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
  };

  /**
   * Model AnnouncementLike
   */

  export type AggregateAnnouncementLike = {
    _count: AnnouncementLikeCountAggregateOutputType | null;
    _min: AnnouncementLikeMinAggregateOutputType | null;
    _max: AnnouncementLikeMaxAggregateOutputType | null;
  };

  export type AnnouncementLikeMinAggregateOutputType = {
    id: string | null;
    announcementId: string | null;
    userId: string | null;
    createdAt: Date | null;
  };

  export type AnnouncementLikeMaxAggregateOutputType = {
    id: string | null;
    announcementId: string | null;
    userId: string | null;
    createdAt: Date | null;
  };

  export type AnnouncementLikeCountAggregateOutputType = {
    id: number;
    announcementId: number;
    userId: number;
    createdAt: number;
    _all: number;
  };

  export type AnnouncementLikeMinAggregateInputType = {
    id?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
  };

  export type AnnouncementLikeMaxAggregateInputType = {
    id?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
  };

  export type AnnouncementLikeCountAggregateInputType = {
    id?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type AnnouncementLikeAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnnouncementLike to aggregate.
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementLikes to fetch.
     */
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnnouncementLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AnnouncementLikes
     **/
    _count?: true | AnnouncementLikeCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnnouncementLikeMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnnouncementLikeMaxAggregateInputType;
  };

  export type GetAnnouncementLikeAggregateType<
    T extends AnnouncementLikeAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnnouncementLike]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncementLike[P]>
      : GetScalarType<T[P], AggregateAnnouncementLike[P]>;
  };

  export type AnnouncementLikeGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementLikeWhereInput;
    orderBy?:
      | AnnouncementLikeOrderByWithAggregationInput
      | AnnouncementLikeOrderByWithAggregationInput[];
    by: AnnouncementLikeScalarFieldEnum[] | AnnouncementLikeScalarFieldEnum;
    having?: AnnouncementLikeScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnnouncementLikeCountAggregateInputType | true;
    _min?: AnnouncementLikeMinAggregateInputType;
    _max?: AnnouncementLikeMaxAggregateInputType;
  };

  export type AnnouncementLikeGroupByOutputType = {
    id: string;
    announcementId: string;
    userId: string;
    createdAt: Date;
    _count: AnnouncementLikeCountAggregateOutputType | null;
    _min: AnnouncementLikeMinAggregateOutputType | null;
    _max: AnnouncementLikeMaxAggregateOutputType | null;
  };

  type GetAnnouncementLikeGroupByPayload<
    T extends AnnouncementLikeGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementLikeGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof AnnouncementLikeGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AnnouncementLikeGroupByOutputType[P]>
          : GetScalarType<T[P], AnnouncementLikeGroupByOutputType[P]>;
      }
    >
  >;

  export type AnnouncementLikeSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      announcementId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['announcementLike']
  >;

  export type AnnouncementLikeSelectScalar = {
    id?: boolean;
    announcementId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
  };

  export type AnnouncementLikeOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'announcementId' | 'userId' | 'createdAt',
    ExtArgs['result']['announcementLike']
  >;
  export type AnnouncementLikeInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AnnouncementLikePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AnnouncementLike';
    objects: {
      announcement: Prisma.$AnnouncementPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        announcementId: string;
        userId: string;
        createdAt: Date;
      },
      ExtArgs['result']['announcementLike']
    >;
    composites: {};
  };

  type AnnouncementLikeGetPayload<
    S extends boolean | null | undefined | AnnouncementLikeDefaultArgs,
  > = $Result.GetResult<Prisma.$AnnouncementLikePayload, S>;

  type AnnouncementLikeCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnnouncementLikeFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AnnouncementLikeCountAggregateInputType | true;
  };

  export interface AnnouncementLikeDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AnnouncementLike'];
      meta: { name: 'AnnouncementLike' };
    };
    /**
     * Find zero or one AnnouncementLike that matches the filter.
     * @param {AnnouncementLikeFindUniqueArgs} args - Arguments to find a AnnouncementLike
     * @example
     * // Get one AnnouncementLike
     * const announcementLike = await prisma.announcementLike.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementLikeFindUniqueArgs>(
      args: SelectSubset<T, AnnouncementLikeFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AnnouncementLike that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementLikeFindUniqueOrThrowArgs} args - Arguments to find a AnnouncementLike
     * @example
     * // Get one AnnouncementLike
     * const announcementLike = await prisma.announcementLike.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementLikeFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnnouncementLikeFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnnouncementLike that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeFindFirstArgs} args - Arguments to find a AnnouncementLike
     * @example
     * // Get one AnnouncementLike
     * const announcementLike = await prisma.announcementLike.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementLikeFindFirstArgs>(
      args?: SelectSubset<T, AnnouncementLikeFindFirstArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnnouncementLike that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeFindFirstOrThrowArgs} args - Arguments to find a AnnouncementLike
     * @example
     * // Get one AnnouncementLike
     * const announcementLike = await prisma.announcementLike.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementLikeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnouncementLikeFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnnouncementLikes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnouncementLikes
     * const announcementLikes = await prisma.announcementLike.findMany()
     *
     * // Get first 10 AnnouncementLikes
     * const announcementLikes = await prisma.announcementLike.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const announcementLikeWithIdOnly = await prisma.announcementLike.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnnouncementLikeFindManyArgs>(
      args?: SelectSubset<T, AnnouncementLikeFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AnnouncementLike.
     * @param {AnnouncementLikeCreateArgs} args - Arguments to create a AnnouncementLike.
     * @example
     * // Create one AnnouncementLike
     * const AnnouncementLike = await prisma.announcementLike.create({
     *   data: {
     *     // ... data to create a AnnouncementLike
     *   }
     * })
     *
     */
    create<T extends AnnouncementLikeCreateArgs>(
      args: SelectSubset<T, AnnouncementLikeCreateArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AnnouncementLikes.
     * @param {AnnouncementLikeCreateManyArgs} args - Arguments to create many AnnouncementLikes.
     * @example
     * // Create many AnnouncementLikes
     * const announcementLike = await prisma.announcementLike.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnnouncementLikeCreateManyArgs>(
      args?: SelectSubset<T, AnnouncementLikeCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AnnouncementLike.
     * @param {AnnouncementLikeDeleteArgs} args - Arguments to delete one AnnouncementLike.
     * @example
     * // Delete one AnnouncementLike
     * const AnnouncementLike = await prisma.announcementLike.delete({
     *   where: {
     *     // ... filter to delete one AnnouncementLike
     *   }
     * })
     *
     */
    delete<T extends AnnouncementLikeDeleteArgs>(
      args: SelectSubset<T, AnnouncementLikeDeleteArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AnnouncementLike.
     * @param {AnnouncementLikeUpdateArgs} args - Arguments to update one AnnouncementLike.
     * @example
     * // Update one AnnouncementLike
     * const announcementLike = await prisma.announcementLike.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnnouncementLikeUpdateArgs>(
      args: SelectSubset<T, AnnouncementLikeUpdateArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AnnouncementLikes.
     * @param {AnnouncementLikeDeleteManyArgs} args - Arguments to filter AnnouncementLikes to delete.
     * @example
     * // Delete a few AnnouncementLikes
     * const { count } = await prisma.announcementLike.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnnouncementLikeDeleteManyArgs>(
      args?: SelectSubset<T, AnnouncementLikeDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AnnouncementLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnouncementLikes
     * const announcementLike = await prisma.announcementLike.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnnouncementLikeUpdateManyArgs>(
      args: SelectSubset<T, AnnouncementLikeUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AnnouncementLike.
     * @param {AnnouncementLikeUpsertArgs} args - Arguments to update or create a AnnouncementLike.
     * @example
     * // Update or create a AnnouncementLike
     * const announcementLike = await prisma.announcementLike.upsert({
     *   create: {
     *     // ... data to create a AnnouncementLike
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnouncementLike we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementLikeUpsertArgs>(
      args: SelectSubset<T, AnnouncementLikeUpsertArgs<ExtArgs>>
    ): Prisma__AnnouncementLikeClient<
      $Result.GetResult<
        Prisma.$AnnouncementLikePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnnouncementLikes that matches the filter.
     * @param {AnnouncementLikeFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const announcementLike = await prisma.announcementLike.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: AnnouncementLikeFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a AnnouncementLike.
     * @param {AnnouncementLikeAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const announcementLike = await prisma.announcementLike.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AnnouncementLikeAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of AnnouncementLikes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeCountArgs} args - Arguments to filter AnnouncementLikes to count.
     * @example
     * // Count the number of AnnouncementLikes
     * const count = await prisma.announcementLike.count({
     *   where: {
     *     // ... the filter for the AnnouncementLikes we want to count
     *   }
     * })
     **/
    count<T extends AnnouncementLikeCountArgs>(
      args?: Subset<T, AnnouncementLikeCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AnnouncementLikeCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AnnouncementLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnnouncementLikeAggregateArgs>(
      args: Subset<T, AnnouncementLikeAggregateArgs>
    ): Prisma.PrismaPromise<GetAnnouncementLikeAggregateType<T>>;

    /**
     * Group by AnnouncementLike.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementLikeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnnouncementLikeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementLikeGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementLikeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnnouncementLikeGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAnnouncementLikeGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AnnouncementLike model
     */
    readonly fields: AnnouncementLikeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnouncementLike.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementLikeClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    announcement<T extends AnnouncementDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AnnouncementDefaultArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      | $Result.GetResult<
          Prisma.$AnnouncementPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AnnouncementLike model
   */
  interface AnnouncementLikeFieldRefs {
    readonly id: FieldRef<'AnnouncementLike', 'String'>;
    readonly announcementId: FieldRef<'AnnouncementLike', 'String'>;
    readonly userId: FieldRef<'AnnouncementLike', 'String'>;
    readonly createdAt: FieldRef<'AnnouncementLike', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AnnouncementLike findUnique
   */
  export type AnnouncementLikeFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementLike to fetch.
     */
    where: AnnouncementLikeWhereUniqueInput;
  };

  /**
   * AnnouncementLike findUniqueOrThrow
   */
  export type AnnouncementLikeFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementLike to fetch.
     */
    where: AnnouncementLikeWhereUniqueInput;
  };

  /**
   * AnnouncementLike findFirst
   */
  export type AnnouncementLikeFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementLike to fetch.
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementLikes to fetch.
     */
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnnouncementLikes.
     */
    cursor?: AnnouncementLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnnouncementLikes.
     */
    distinct?:
      | AnnouncementLikeScalarFieldEnum
      | AnnouncementLikeScalarFieldEnum[];
  };

  /**
   * AnnouncementLike findFirstOrThrow
   */
  export type AnnouncementLikeFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementLike to fetch.
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementLikes to fetch.
     */
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnnouncementLikes.
     */
    cursor?: AnnouncementLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementLikes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnnouncementLikes.
     */
    distinct?:
      | AnnouncementLikeScalarFieldEnum
      | AnnouncementLikeScalarFieldEnum[];
  };

  /**
   * AnnouncementLike findMany
   */
  export type AnnouncementLikeFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementLikes to fetch.
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementLikes to fetch.
     */
    orderBy?:
      | AnnouncementLikeOrderByWithRelationInput
      | AnnouncementLikeOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AnnouncementLikes.
     */
    cursor?: AnnouncementLikeWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementLikes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementLikes.
     */
    skip?: number;
    distinct?:
      | AnnouncementLikeScalarFieldEnum
      | AnnouncementLikeScalarFieldEnum[];
  };

  /**
   * AnnouncementLike create
   */
  export type AnnouncementLikeCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * The data needed to create a AnnouncementLike.
     */
    data: XOR<
      AnnouncementLikeCreateInput,
      AnnouncementLikeUncheckedCreateInput
    >;
  };

  /**
   * AnnouncementLike createMany
   */
  export type AnnouncementLikeCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AnnouncementLikes.
     */
    data: AnnouncementLikeCreateManyInput | AnnouncementLikeCreateManyInput[];
  };

  /**
   * AnnouncementLike update
   */
  export type AnnouncementLikeUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * The data needed to update a AnnouncementLike.
     */
    data: XOR<
      AnnouncementLikeUpdateInput,
      AnnouncementLikeUncheckedUpdateInput
    >;
    /**
     * Choose, which AnnouncementLike to update.
     */
    where: AnnouncementLikeWhereUniqueInput;
  };

  /**
   * AnnouncementLike updateMany
   */
  export type AnnouncementLikeUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AnnouncementLikes.
     */
    data: XOR<
      AnnouncementLikeUpdateManyMutationInput,
      AnnouncementLikeUncheckedUpdateManyInput
    >;
    /**
     * Filter which AnnouncementLikes to update
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * Limit how many AnnouncementLikes to update.
     */
    limit?: number;
  };

  /**
   * AnnouncementLike upsert
   */
  export type AnnouncementLikeUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * The filter to search for the AnnouncementLike to update in case it exists.
     */
    where: AnnouncementLikeWhereUniqueInput;
    /**
     * In case the AnnouncementLike found by the `where` argument doesn't exist, create a new AnnouncementLike with this data.
     */
    create: XOR<
      AnnouncementLikeCreateInput,
      AnnouncementLikeUncheckedCreateInput
    >;
    /**
     * In case the AnnouncementLike was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AnnouncementLikeUpdateInput,
      AnnouncementLikeUncheckedUpdateInput
    >;
  };

  /**
   * AnnouncementLike delete
   */
  export type AnnouncementLikeDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
    /**
     * Filter which AnnouncementLike to delete.
     */
    where: AnnouncementLikeWhereUniqueInput;
  };

  /**
   * AnnouncementLike deleteMany
   */
  export type AnnouncementLikeDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnnouncementLikes to delete
     */
    where?: AnnouncementLikeWhereInput;
    /**
     * Limit how many AnnouncementLikes to delete.
     */
    limit?: number;
  };

  /**
   * AnnouncementLike findRaw
   */
  export type AnnouncementLikeFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnnouncementLike aggregateRaw
   */
  export type AnnouncementLikeAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnnouncementLike without action
   */
  export type AnnouncementLikeDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementLike
     */
    select?: AnnouncementLikeSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementLike
     */
    omit?: AnnouncementLikeOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementLikeInclude<ExtArgs> | null;
  };

  /**
   * Model AnnouncementComment
   */

  export type AggregateAnnouncementComment = {
    _count: AnnouncementCommentCountAggregateOutputType | null;
    _min: AnnouncementCommentMinAggregateOutputType | null;
    _max: AnnouncementCommentMaxAggregateOutputType | null;
  };

  export type AnnouncementCommentMinAggregateOutputType = {
    id: string | null;
    content: string | null;
    announcementId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementCommentMaxAggregateOutputType = {
    id: string | null;
    content: string | null;
    announcementId: string | null;
    userId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type AnnouncementCommentCountAggregateOutputType = {
    id: number;
    content: number;
    announcementId: number;
    userId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type AnnouncementCommentMinAggregateInputType = {
    id?: true;
    content?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementCommentMaxAggregateInputType = {
    id?: true;
    content?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type AnnouncementCommentCountAggregateInputType = {
    id?: true;
    content?: true;
    announcementId?: true;
    userId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type AnnouncementCommentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnnouncementComment to aggregate.
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementComments to fetch.
     */
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: AnnouncementCommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementComments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementComments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned AnnouncementComments
     **/
    _count?: true | AnnouncementCommentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: AnnouncementCommentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: AnnouncementCommentMaxAggregateInputType;
  };

  export type GetAnnouncementCommentAggregateType<
    T extends AnnouncementCommentAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateAnnouncementComment]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAnnouncementComment[P]>
      : GetScalarType<T[P], AggregateAnnouncementComment[P]>;
  };

  export type AnnouncementCommentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: AnnouncementCommentWhereInput;
    orderBy?:
      | AnnouncementCommentOrderByWithAggregationInput
      | AnnouncementCommentOrderByWithAggregationInput[];
    by:
      | AnnouncementCommentScalarFieldEnum[]
      | AnnouncementCommentScalarFieldEnum;
    having?: AnnouncementCommentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: AnnouncementCommentCountAggregateInputType | true;
    _min?: AnnouncementCommentMinAggregateInputType;
    _max?: AnnouncementCommentMaxAggregateInputType;
  };

  export type AnnouncementCommentGroupByOutputType = {
    id: string;
    content: string;
    announcementId: string;
    userId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: AnnouncementCommentCountAggregateOutputType | null;
    _min: AnnouncementCommentMinAggregateOutputType | null;
    _max: AnnouncementCommentMaxAggregateOutputType | null;
  };

  type GetAnnouncementCommentGroupByPayload<
    T extends AnnouncementCommentGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AnnouncementCommentGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof AnnouncementCommentGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], AnnouncementCommentGroupByOutputType[P]>
          : GetScalarType<T[P], AnnouncementCommentGroupByOutputType[P]>;
      }
    >
  >;

  export type AnnouncementCommentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      content?: boolean;
      announcementId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['announcementComment']
  >;

  export type AnnouncementCommentSelectScalar = {
    id?: boolean;
    content?: boolean;
    announcementId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type AnnouncementCommentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'content' | 'announcementId' | 'userId' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['announcementComment']
  >;
  export type AnnouncementCommentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    announcement?: boolean | AnnouncementDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $AnnouncementCommentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'AnnouncementComment';
    objects: {
      announcement: Prisma.$AnnouncementPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        content: string;
        announcementId: string;
        userId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['announcementComment']
    >;
    composites: {};
  };

  type AnnouncementCommentGetPayload<
    S extends boolean | null | undefined | AnnouncementCommentDefaultArgs,
  > = $Result.GetResult<Prisma.$AnnouncementCommentPayload, S>;

  type AnnouncementCommentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    AnnouncementCommentFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: AnnouncementCommentCountAggregateInputType | true;
  };

  export interface AnnouncementCommentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['AnnouncementComment'];
      meta: { name: 'AnnouncementComment' };
    };
    /**
     * Find zero or one AnnouncementComment that matches the filter.
     * @param {AnnouncementCommentFindUniqueArgs} args - Arguments to find a AnnouncementComment
     * @example
     * // Get one AnnouncementComment
     * const announcementComment = await prisma.announcementComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AnnouncementCommentFindUniqueArgs>(
      args: SelectSubset<T, AnnouncementCommentFindUniqueArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one AnnouncementComment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AnnouncementCommentFindUniqueOrThrowArgs} args - Arguments to find a AnnouncementComment
     * @example
     * // Get one AnnouncementComment
     * const announcementComment = await prisma.announcementComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AnnouncementCommentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, AnnouncementCommentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnnouncementComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentFindFirstArgs} args - Arguments to find a AnnouncementComment
     * @example
     * // Get one AnnouncementComment
     * const announcementComment = await prisma.announcementComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AnnouncementCommentFindFirstArgs>(
      args?: SelectSubset<T, AnnouncementCommentFindFirstArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first AnnouncementComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentFindFirstOrThrowArgs} args - Arguments to find a AnnouncementComment
     * @example
     * // Get one AnnouncementComment
     * const announcementComment = await prisma.announcementComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AnnouncementCommentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, AnnouncementCommentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnnouncementComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AnnouncementComments
     * const announcementComments = await prisma.announcementComment.findMany()
     *
     * // Get first 10 AnnouncementComments
     * const announcementComments = await prisma.announcementComment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const announcementCommentWithIdOnly = await prisma.announcementComment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends AnnouncementCommentFindManyArgs>(
      args?: SelectSubset<T, AnnouncementCommentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a AnnouncementComment.
     * @param {AnnouncementCommentCreateArgs} args - Arguments to create a AnnouncementComment.
     * @example
     * // Create one AnnouncementComment
     * const AnnouncementComment = await prisma.announcementComment.create({
     *   data: {
     *     // ... data to create a AnnouncementComment
     *   }
     * })
     *
     */
    create<T extends AnnouncementCommentCreateArgs>(
      args: SelectSubset<T, AnnouncementCommentCreateArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many AnnouncementComments.
     * @param {AnnouncementCommentCreateManyArgs} args - Arguments to create many AnnouncementComments.
     * @example
     * // Create many AnnouncementComments
     * const announcementComment = await prisma.announcementComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends AnnouncementCommentCreateManyArgs>(
      args?: SelectSubset<T, AnnouncementCommentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a AnnouncementComment.
     * @param {AnnouncementCommentDeleteArgs} args - Arguments to delete one AnnouncementComment.
     * @example
     * // Delete one AnnouncementComment
     * const AnnouncementComment = await prisma.announcementComment.delete({
     *   where: {
     *     // ... filter to delete one AnnouncementComment
     *   }
     * })
     *
     */
    delete<T extends AnnouncementCommentDeleteArgs>(
      args: SelectSubset<T, AnnouncementCommentDeleteArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one AnnouncementComment.
     * @param {AnnouncementCommentUpdateArgs} args - Arguments to update one AnnouncementComment.
     * @example
     * // Update one AnnouncementComment
     * const announcementComment = await prisma.announcementComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends AnnouncementCommentUpdateArgs>(
      args: SelectSubset<T, AnnouncementCommentUpdateArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more AnnouncementComments.
     * @param {AnnouncementCommentDeleteManyArgs} args - Arguments to filter AnnouncementComments to delete.
     * @example
     * // Delete a few AnnouncementComments
     * const { count } = await prisma.announcementComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends AnnouncementCommentDeleteManyArgs>(
      args?: SelectSubset<T, AnnouncementCommentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more AnnouncementComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AnnouncementComments
     * const announcementComment = await prisma.announcementComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends AnnouncementCommentUpdateManyArgs>(
      args: SelectSubset<T, AnnouncementCommentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one AnnouncementComment.
     * @param {AnnouncementCommentUpsertArgs} args - Arguments to update or create a AnnouncementComment.
     * @example
     * // Update or create a AnnouncementComment
     * const announcementComment = await prisma.announcementComment.upsert({
     *   create: {
     *     // ... data to create a AnnouncementComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AnnouncementComment we want to update
     *   }
     * })
     */
    upsert<T extends AnnouncementCommentUpsertArgs>(
      args: SelectSubset<T, AnnouncementCommentUpsertArgs<ExtArgs>>
    ): Prisma__AnnouncementCommentClient<
      $Result.GetResult<
        Prisma.$AnnouncementCommentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more AnnouncementComments that matches the filter.
     * @param {AnnouncementCommentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const announcementComment = await prisma.announcementComment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: AnnouncementCommentFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a AnnouncementComment.
     * @param {AnnouncementCommentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const announcementComment = await prisma.announcementComment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: AnnouncementCommentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of AnnouncementComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentCountArgs} args - Arguments to filter AnnouncementComments to count.
     * @example
     * // Count the number of AnnouncementComments
     * const count = await prisma.announcementComment.count({
     *   where: {
     *     // ... the filter for the AnnouncementComments we want to count
     *   }
     * })
     **/
    count<T extends AnnouncementCommentCountArgs>(
      args?: Subset<T, AnnouncementCommentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<
              T['select'],
              AnnouncementCommentCountAggregateOutputType
            >
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a AnnouncementComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends AnnouncementCommentAggregateArgs>(
      args: Subset<T, AnnouncementCommentAggregateArgs>
    ): Prisma.PrismaPromise<GetAnnouncementCommentAggregateType<T>>;

    /**
     * Group by AnnouncementComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AnnouncementCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends AnnouncementCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AnnouncementCommentGroupByArgs['orderBy'] }
        : { orderBy?: AnnouncementCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, AnnouncementCommentGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetAnnouncementCommentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the AnnouncementComment model
     */
    readonly fields: AnnouncementCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AnnouncementComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AnnouncementCommentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    announcement<T extends AnnouncementDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, AnnouncementDefaultArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      | $Result.GetResult<
          Prisma.$AnnouncementPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the AnnouncementComment model
   */
  interface AnnouncementCommentFieldRefs {
    readonly id: FieldRef<'AnnouncementComment', 'String'>;
    readonly content: FieldRef<'AnnouncementComment', 'String'>;
    readonly announcementId: FieldRef<'AnnouncementComment', 'String'>;
    readonly userId: FieldRef<'AnnouncementComment', 'String'>;
    readonly createdAt: FieldRef<'AnnouncementComment', 'DateTime'>;
    readonly updatedAt: FieldRef<'AnnouncementComment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * AnnouncementComment findUnique
   */
  export type AnnouncementCommentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementComment to fetch.
     */
    where: AnnouncementCommentWhereUniqueInput;
  };

  /**
   * AnnouncementComment findUniqueOrThrow
   */
  export type AnnouncementCommentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementComment to fetch.
     */
    where: AnnouncementCommentWhereUniqueInput;
  };

  /**
   * AnnouncementComment findFirst
   */
  export type AnnouncementCommentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementComment to fetch.
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementComments to fetch.
     */
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnnouncementComments.
     */
    cursor?: AnnouncementCommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementComments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementComments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnnouncementComments.
     */
    distinct?:
      | AnnouncementCommentScalarFieldEnum
      | AnnouncementCommentScalarFieldEnum[];
  };

  /**
   * AnnouncementComment findFirstOrThrow
   */
  export type AnnouncementCommentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementComment to fetch.
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementComments to fetch.
     */
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for AnnouncementComments.
     */
    cursor?: AnnouncementCommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementComments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementComments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of AnnouncementComments.
     */
    distinct?:
      | AnnouncementCommentScalarFieldEnum
      | AnnouncementCommentScalarFieldEnum[];
  };

  /**
   * AnnouncementComment findMany
   */
  export type AnnouncementCommentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter, which AnnouncementComments to fetch.
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of AnnouncementComments to fetch.
     */
    orderBy?:
      | AnnouncementCommentOrderByWithRelationInput
      | AnnouncementCommentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing AnnouncementComments.
     */
    cursor?: AnnouncementCommentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` AnnouncementComments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` AnnouncementComments.
     */
    skip?: number;
    distinct?:
      | AnnouncementCommentScalarFieldEnum
      | AnnouncementCommentScalarFieldEnum[];
  };

  /**
   * AnnouncementComment create
   */
  export type AnnouncementCommentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * The data needed to create a AnnouncementComment.
     */
    data: XOR<
      AnnouncementCommentCreateInput,
      AnnouncementCommentUncheckedCreateInput
    >;
  };

  /**
   * AnnouncementComment createMany
   */
  export type AnnouncementCommentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many AnnouncementComments.
     */
    data:
      | AnnouncementCommentCreateManyInput
      | AnnouncementCommentCreateManyInput[];
  };

  /**
   * AnnouncementComment update
   */
  export type AnnouncementCommentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * The data needed to update a AnnouncementComment.
     */
    data: XOR<
      AnnouncementCommentUpdateInput,
      AnnouncementCommentUncheckedUpdateInput
    >;
    /**
     * Choose, which AnnouncementComment to update.
     */
    where: AnnouncementCommentWhereUniqueInput;
  };

  /**
   * AnnouncementComment updateMany
   */
  export type AnnouncementCommentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update AnnouncementComments.
     */
    data: XOR<
      AnnouncementCommentUpdateManyMutationInput,
      AnnouncementCommentUncheckedUpdateManyInput
    >;
    /**
     * Filter which AnnouncementComments to update
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * Limit how many AnnouncementComments to update.
     */
    limit?: number;
  };

  /**
   * AnnouncementComment upsert
   */
  export type AnnouncementCommentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * The filter to search for the AnnouncementComment to update in case it exists.
     */
    where: AnnouncementCommentWhereUniqueInput;
    /**
     * In case the AnnouncementComment found by the `where` argument doesn't exist, create a new AnnouncementComment with this data.
     */
    create: XOR<
      AnnouncementCommentCreateInput,
      AnnouncementCommentUncheckedCreateInput
    >;
    /**
     * In case the AnnouncementComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      AnnouncementCommentUpdateInput,
      AnnouncementCommentUncheckedUpdateInput
    >;
  };

  /**
   * AnnouncementComment delete
   */
  export type AnnouncementCommentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
    /**
     * Filter which AnnouncementComment to delete.
     */
    where: AnnouncementCommentWhereUniqueInput;
  };

  /**
   * AnnouncementComment deleteMany
   */
  export type AnnouncementCommentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which AnnouncementComments to delete
     */
    where?: AnnouncementCommentWhereInput;
    /**
     * Limit how many AnnouncementComments to delete.
     */
    limit?: number;
  };

  /**
   * AnnouncementComment findRaw
   */
  export type AnnouncementCommentFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnnouncementComment aggregateRaw
   */
  export type AnnouncementCommentAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * AnnouncementComment without action
   */
  export type AnnouncementCommentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the AnnouncementComment
     */
    select?: AnnouncementCommentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the AnnouncementComment
     */
    omit?: AnnouncementCommentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementCommentInclude<ExtArgs> | null;
  };

  /**
   * Model ApartmentConfig
   */

  export type AggregateApartmentConfig = {
    _count: ApartmentConfigCountAggregateOutputType | null;
    _avg: ApartmentConfigAvgAggregateOutputType | null;
    _sum: ApartmentConfigSumAggregateOutputType | null;
    _min: ApartmentConfigMinAggregateOutputType | null;
    _max: ApartmentConfigMaxAggregateOutputType | null;
  };

  export type ApartmentConfigAvgAggregateOutputType = {
    maxProperties: number | null;
    numberOfBlocks: number | null;
    numberOfFloors: number | null;
    unitsPerFloor: number | null;
  };

  export type ApartmentConfigSumAggregateOutputType = {
    maxProperties: number | null;
    numberOfBlocks: number | null;
    numberOfFloors: number | null;
    unitsPerFloor: number | null;
  };

  export type ApartmentConfigMinAggregateOutputType = {
    id: string | null;
    maxProperties: number | null;
    numberOfBlocks: number | null;
    blockNamingConvention: $Enums.BlockNamingConvention | null;
    numberOfFloors: number | null;
    unitsPerFloor: number | null;
    updatedAt: Date | null;
  };

  export type ApartmentConfigMaxAggregateOutputType = {
    id: string | null;
    maxProperties: number | null;
    numberOfBlocks: number | null;
    blockNamingConvention: $Enums.BlockNamingConvention | null;
    numberOfFloors: number | null;
    unitsPerFloor: number | null;
    updatedAt: Date | null;
  };

  export type ApartmentConfigCountAggregateOutputType = {
    id: number;
    maxProperties: number;
    numberOfBlocks: number;
    blockNamingConvention: number;
    numberOfFloors: number;
    unitsPerFloor: number;
    updatedAt: number;
    _all: number;
  };

  export type ApartmentConfigAvgAggregateInputType = {
    maxProperties?: true;
    numberOfBlocks?: true;
    numberOfFloors?: true;
    unitsPerFloor?: true;
  };

  export type ApartmentConfigSumAggregateInputType = {
    maxProperties?: true;
    numberOfBlocks?: true;
    numberOfFloors?: true;
    unitsPerFloor?: true;
  };

  export type ApartmentConfigMinAggregateInputType = {
    id?: true;
    maxProperties?: true;
    numberOfBlocks?: true;
    blockNamingConvention?: true;
    numberOfFloors?: true;
    unitsPerFloor?: true;
    updatedAt?: true;
  };

  export type ApartmentConfigMaxAggregateInputType = {
    id?: true;
    maxProperties?: true;
    numberOfBlocks?: true;
    blockNamingConvention?: true;
    numberOfFloors?: true;
    unitsPerFloor?: true;
    updatedAt?: true;
  };

  export type ApartmentConfigCountAggregateInputType = {
    id?: true;
    maxProperties?: true;
    numberOfBlocks?: true;
    blockNamingConvention?: true;
    numberOfFloors?: true;
    unitsPerFloor?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ApartmentConfigAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApartmentConfig to aggregate.
     */
    where?: ApartmentConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApartmentConfigs to fetch.
     */
    orderBy?:
      | ApartmentConfigOrderByWithRelationInput
      | ApartmentConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ApartmentConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApartmentConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApartmentConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned ApartmentConfigs
     **/
    _count?: true | ApartmentConfigCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ApartmentConfigAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ApartmentConfigSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ApartmentConfigMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ApartmentConfigMaxAggregateInputType;
  };

  export type GetApartmentConfigAggregateType<
    T extends ApartmentConfigAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateApartmentConfig]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApartmentConfig[P]>
      : GetScalarType<T[P], AggregateApartmentConfig[P]>;
  };

  export type ApartmentConfigGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ApartmentConfigWhereInput;
    orderBy?:
      | ApartmentConfigOrderByWithAggregationInput
      | ApartmentConfigOrderByWithAggregationInput[];
    by: ApartmentConfigScalarFieldEnum[] | ApartmentConfigScalarFieldEnum;
    having?: ApartmentConfigScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ApartmentConfigCountAggregateInputType | true;
    _avg?: ApartmentConfigAvgAggregateInputType;
    _sum?: ApartmentConfigSumAggregateInputType;
    _min?: ApartmentConfigMinAggregateInputType;
    _max?: ApartmentConfigMaxAggregateInputType;
  };

  export type ApartmentConfigGroupByOutputType = {
    id: string;
    maxProperties: number;
    numberOfBlocks: number;
    blockNamingConvention: $Enums.BlockNamingConvention;
    numberOfFloors: number;
    unitsPerFloor: number;
    updatedAt: Date;
    _count: ApartmentConfigCountAggregateOutputType | null;
    _avg: ApartmentConfigAvgAggregateOutputType | null;
    _sum: ApartmentConfigSumAggregateOutputType | null;
    _min: ApartmentConfigMinAggregateOutputType | null;
    _max: ApartmentConfigMaxAggregateOutputType | null;
  };

  type GetApartmentConfigGroupByPayload<T extends ApartmentConfigGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ApartmentConfigGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof ApartmentConfigGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApartmentConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ApartmentConfigGroupByOutputType[P]>;
        }
      >
    >;

  export type ApartmentConfigSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      maxProperties?: boolean;
      numberOfBlocks?: boolean;
      blockNamingConvention?: boolean;
      numberOfFloors?: boolean;
      unitsPerFloor?: boolean;
      updatedAt?: boolean;
    },
    ExtArgs['result']['apartmentConfig']
  >;

  export type ApartmentConfigSelectScalar = {
    id?: boolean;
    maxProperties?: boolean;
    numberOfBlocks?: boolean;
    blockNamingConvention?: boolean;
    numberOfFloors?: boolean;
    unitsPerFloor?: boolean;
    updatedAt?: boolean;
  };

  export type ApartmentConfigOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'maxProperties'
    | 'numberOfBlocks'
    | 'blockNamingConvention'
    | 'numberOfFloors'
    | 'unitsPerFloor'
    | 'updatedAt',
    ExtArgs['result']['apartmentConfig']
  >;

  export type $ApartmentConfigPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'ApartmentConfig';
    objects: {};
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        maxProperties: number;
        numberOfBlocks: number;
        blockNamingConvention: $Enums.BlockNamingConvention;
        numberOfFloors: number;
        unitsPerFloor: number;
        updatedAt: Date;
      },
      ExtArgs['result']['apartmentConfig']
    >;
    composites: {};
  };

  type ApartmentConfigGetPayload<
    S extends boolean | null | undefined | ApartmentConfigDefaultArgs,
  > = $Result.GetResult<Prisma.$ApartmentConfigPayload, S>;

  type ApartmentConfigCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ApartmentConfigFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ApartmentConfigCountAggregateInputType | true;
  };

  export interface ApartmentConfigDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['ApartmentConfig'];
      meta: { name: 'ApartmentConfig' };
    };
    /**
     * Find zero or one ApartmentConfig that matches the filter.
     * @param {ApartmentConfigFindUniqueArgs} args - Arguments to find a ApartmentConfig
     * @example
     * // Get one ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ApartmentConfigFindUniqueArgs>(
      args: SelectSubset<T, ApartmentConfigFindUniqueArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one ApartmentConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ApartmentConfigFindUniqueOrThrowArgs} args - Arguments to find a ApartmentConfig
     * @example
     * // Get one ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ApartmentConfigFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ApartmentConfigFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApartmentConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigFindFirstArgs} args - Arguments to find a ApartmentConfig
     * @example
     * // Get one ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ApartmentConfigFindFirstArgs>(
      args?: SelectSubset<T, ApartmentConfigFindFirstArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first ApartmentConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigFindFirstOrThrowArgs} args - Arguments to find a ApartmentConfig
     * @example
     * // Get one ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ApartmentConfigFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ApartmentConfigFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApartmentConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ApartmentConfigs
     * const apartmentConfigs = await prisma.apartmentConfig.findMany()
     *
     * // Get first 10 ApartmentConfigs
     * const apartmentConfigs = await prisma.apartmentConfig.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const apartmentConfigWithIdOnly = await prisma.apartmentConfig.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ApartmentConfigFindManyArgs>(
      args?: SelectSubset<T, ApartmentConfigFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a ApartmentConfig.
     * @param {ApartmentConfigCreateArgs} args - Arguments to create a ApartmentConfig.
     * @example
     * // Create one ApartmentConfig
     * const ApartmentConfig = await prisma.apartmentConfig.create({
     *   data: {
     *     // ... data to create a ApartmentConfig
     *   }
     * })
     *
     */
    create<T extends ApartmentConfigCreateArgs>(
      args: SelectSubset<T, ApartmentConfigCreateArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many ApartmentConfigs.
     * @param {ApartmentConfigCreateManyArgs} args - Arguments to create many ApartmentConfigs.
     * @example
     * // Create many ApartmentConfigs
     * const apartmentConfig = await prisma.apartmentConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ApartmentConfigCreateManyArgs>(
      args?: SelectSubset<T, ApartmentConfigCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a ApartmentConfig.
     * @param {ApartmentConfigDeleteArgs} args - Arguments to delete one ApartmentConfig.
     * @example
     * // Delete one ApartmentConfig
     * const ApartmentConfig = await prisma.apartmentConfig.delete({
     *   where: {
     *     // ... filter to delete one ApartmentConfig
     *   }
     * })
     *
     */
    delete<T extends ApartmentConfigDeleteArgs>(
      args: SelectSubset<T, ApartmentConfigDeleteArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one ApartmentConfig.
     * @param {ApartmentConfigUpdateArgs} args - Arguments to update one ApartmentConfig.
     * @example
     * // Update one ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ApartmentConfigUpdateArgs>(
      args: SelectSubset<T, ApartmentConfigUpdateArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more ApartmentConfigs.
     * @param {ApartmentConfigDeleteManyArgs} args - Arguments to filter ApartmentConfigs to delete.
     * @example
     * // Delete a few ApartmentConfigs
     * const { count } = await prisma.apartmentConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ApartmentConfigDeleteManyArgs>(
      args?: SelectSubset<T, ApartmentConfigDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more ApartmentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ApartmentConfigs
     * const apartmentConfig = await prisma.apartmentConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ApartmentConfigUpdateManyArgs>(
      args: SelectSubset<T, ApartmentConfigUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one ApartmentConfig.
     * @param {ApartmentConfigUpsertArgs} args - Arguments to update or create a ApartmentConfig.
     * @example
     * // Update or create a ApartmentConfig
     * const apartmentConfig = await prisma.apartmentConfig.upsert({
     *   create: {
     *     // ... data to create a ApartmentConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ApartmentConfig we want to update
     *   }
     * })
     */
    upsert<T extends ApartmentConfigUpsertArgs>(
      args: SelectSubset<T, ApartmentConfigUpsertArgs<ExtArgs>>
    ): Prisma__ApartmentConfigClient<
      $Result.GetResult<
        Prisma.$ApartmentConfigPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more ApartmentConfigs that matches the filter.
     * @param {ApartmentConfigFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const apartmentConfig = await prisma.apartmentConfig.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: ApartmentConfigFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a ApartmentConfig.
     * @param {ApartmentConfigAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const apartmentConfig = await prisma.apartmentConfig.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ApartmentConfigAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of ApartmentConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigCountArgs} args - Arguments to filter ApartmentConfigs to count.
     * @example
     * // Count the number of ApartmentConfigs
     * const count = await prisma.apartmentConfig.count({
     *   where: {
     *     // ... the filter for the ApartmentConfigs we want to count
     *   }
     * })
     **/
    count<T extends ApartmentConfigCountArgs>(
      args?: Subset<T, ApartmentConfigCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApartmentConfigCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a ApartmentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ApartmentConfigAggregateArgs>(
      args: Subset<T, ApartmentConfigAggregateArgs>
    ): Prisma.PrismaPromise<GetApartmentConfigAggregateType<T>>;

    /**
     * Group by ApartmentConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApartmentConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ApartmentConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApartmentConfigGroupByArgs['orderBy'] }
        : { orderBy?: ApartmentConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ApartmentConfigGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetApartmentConfigGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the ApartmentConfig model
     */
    readonly fields: ApartmentConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ApartmentConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ApartmentConfigClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the ApartmentConfig model
   */
  interface ApartmentConfigFieldRefs {
    readonly id: FieldRef<'ApartmentConfig', 'String'>;
    readonly maxProperties: FieldRef<'ApartmentConfig', 'Int'>;
    readonly numberOfBlocks: FieldRef<'ApartmentConfig', 'Int'>;
    readonly blockNamingConvention: FieldRef<
      'ApartmentConfig',
      'BlockNamingConvention'
    >;
    readonly numberOfFloors: FieldRef<'ApartmentConfig', 'Int'>;
    readonly unitsPerFloor: FieldRef<'ApartmentConfig', 'Int'>;
    readonly updatedAt: FieldRef<'ApartmentConfig', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * ApartmentConfig findUnique
   */
  export type ApartmentConfigFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter, which ApartmentConfig to fetch.
     */
    where: ApartmentConfigWhereUniqueInput;
  };

  /**
   * ApartmentConfig findUniqueOrThrow
   */
  export type ApartmentConfigFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter, which ApartmentConfig to fetch.
     */
    where: ApartmentConfigWhereUniqueInput;
  };

  /**
   * ApartmentConfig findFirst
   */
  export type ApartmentConfigFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter, which ApartmentConfig to fetch.
     */
    where?: ApartmentConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApartmentConfigs to fetch.
     */
    orderBy?:
      | ApartmentConfigOrderByWithRelationInput
      | ApartmentConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApartmentConfigs.
     */
    cursor?: ApartmentConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApartmentConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApartmentConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApartmentConfigs.
     */
    distinct?:
      | ApartmentConfigScalarFieldEnum
      | ApartmentConfigScalarFieldEnum[];
  };

  /**
   * ApartmentConfig findFirstOrThrow
   */
  export type ApartmentConfigFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter, which ApartmentConfig to fetch.
     */
    where?: ApartmentConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApartmentConfigs to fetch.
     */
    orderBy?:
      | ApartmentConfigOrderByWithRelationInput
      | ApartmentConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for ApartmentConfigs.
     */
    cursor?: ApartmentConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApartmentConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApartmentConfigs.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of ApartmentConfigs.
     */
    distinct?:
      | ApartmentConfigScalarFieldEnum
      | ApartmentConfigScalarFieldEnum[];
  };

  /**
   * ApartmentConfig findMany
   */
  export type ApartmentConfigFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter, which ApartmentConfigs to fetch.
     */
    where?: ApartmentConfigWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of ApartmentConfigs to fetch.
     */
    orderBy?:
      | ApartmentConfigOrderByWithRelationInput
      | ApartmentConfigOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing ApartmentConfigs.
     */
    cursor?: ApartmentConfigWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` ApartmentConfigs from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` ApartmentConfigs.
     */
    skip?: number;
    distinct?:
      | ApartmentConfigScalarFieldEnum
      | ApartmentConfigScalarFieldEnum[];
  };

  /**
   * ApartmentConfig create
   */
  export type ApartmentConfigCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * The data needed to create a ApartmentConfig.
     */
    data: XOR<ApartmentConfigCreateInput, ApartmentConfigUncheckedCreateInput>;
  };

  /**
   * ApartmentConfig createMany
   */
  export type ApartmentConfigCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many ApartmentConfigs.
     */
    data: ApartmentConfigCreateManyInput | ApartmentConfigCreateManyInput[];
  };

  /**
   * ApartmentConfig update
   */
  export type ApartmentConfigUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * The data needed to update a ApartmentConfig.
     */
    data: XOR<ApartmentConfigUpdateInput, ApartmentConfigUncheckedUpdateInput>;
    /**
     * Choose, which ApartmentConfig to update.
     */
    where: ApartmentConfigWhereUniqueInput;
  };

  /**
   * ApartmentConfig updateMany
   */
  export type ApartmentConfigUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update ApartmentConfigs.
     */
    data: XOR<
      ApartmentConfigUpdateManyMutationInput,
      ApartmentConfigUncheckedUpdateManyInput
    >;
    /**
     * Filter which ApartmentConfigs to update
     */
    where?: ApartmentConfigWhereInput;
    /**
     * Limit how many ApartmentConfigs to update.
     */
    limit?: number;
  };

  /**
   * ApartmentConfig upsert
   */
  export type ApartmentConfigUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * The filter to search for the ApartmentConfig to update in case it exists.
     */
    where: ApartmentConfigWhereUniqueInput;
    /**
     * In case the ApartmentConfig found by the `where` argument doesn't exist, create a new ApartmentConfig with this data.
     */
    create: XOR<
      ApartmentConfigCreateInput,
      ApartmentConfigUncheckedCreateInput
    >;
    /**
     * In case the ApartmentConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      ApartmentConfigUpdateInput,
      ApartmentConfigUncheckedUpdateInput
    >;
  };

  /**
   * ApartmentConfig delete
   */
  export type ApartmentConfigDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
    /**
     * Filter which ApartmentConfig to delete.
     */
    where: ApartmentConfigWhereUniqueInput;
  };

  /**
   * ApartmentConfig deleteMany
   */
  export type ApartmentConfigDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which ApartmentConfigs to delete
     */
    where?: ApartmentConfigWhereInput;
    /**
     * Limit how many ApartmentConfigs to delete.
     */
    limit?: number;
  };

  /**
   * ApartmentConfig findRaw
   */
  export type ApartmentConfigFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ApartmentConfig aggregateRaw
   */
  export type ApartmentConfigAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * ApartmentConfig without action
   */
  export type ApartmentConfigDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the ApartmentConfig
     */
    select?: ApartmentConfigSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the ApartmentConfig
     */
    omit?: ApartmentConfigOmit<ExtArgs> | null;
  };

  /**
   * Model Poll
   */

  export type AggregatePoll = {
    _count: PollCountAggregateOutputType | null;
    _min: PollMinAggregateOutputType | null;
    _max: PollMaxAggregateOutputType | null;
  };

  export type PollMinAggregateOutputType = {
    id: string | null;
    question: string | null;
    description: string | null;
    isAnonymous: boolean | null;
    isPinned: boolean | null;
    pinnedAt: Date | null;
    endsAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdById: string | null;
    announcementId: string | null;
  };

  export type PollMaxAggregateOutputType = {
    id: string | null;
    question: string | null;
    description: string | null;
    isAnonymous: boolean | null;
    isPinned: boolean | null;
    pinnedAt: Date | null;
    endsAt: Date | null;
    createdAt: Date | null;
    updatedAt: Date | null;
    createdById: string | null;
    announcementId: string | null;
  };

  export type PollCountAggregateOutputType = {
    id: number;
    question: number;
    description: number;
    isAnonymous: number;
    isPinned: number;
    pinnedAt: number;
    endsAt: number;
    createdAt: number;
    updatedAt: number;
    createdById: number;
    announcementId: number;
    _all: number;
  };

  export type PollMinAggregateInputType = {
    id?: true;
    question?: true;
    description?: true;
    isAnonymous?: true;
    isPinned?: true;
    pinnedAt?: true;
    endsAt?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    announcementId?: true;
  };

  export type PollMaxAggregateInputType = {
    id?: true;
    question?: true;
    description?: true;
    isAnonymous?: true;
    isPinned?: true;
    pinnedAt?: true;
    endsAt?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    announcementId?: true;
  };

  export type PollCountAggregateInputType = {
    id?: true;
    question?: true;
    description?: true;
    isAnonymous?: true;
    isPinned?: true;
    pinnedAt?: true;
    endsAt?: true;
    createdAt?: true;
    updatedAt?: true;
    createdById?: true;
    announcementId?: true;
    _all?: true;
  };

  export type PollAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Poll to aggregate.
     */
    where?: PollWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PollWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Polls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Polls
     **/
    _count?: true | PollCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PollMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PollMaxAggregateInputType;
  };

  export type GetPollAggregateType<T extends PollAggregateArgs> = {
    [P in keyof T & keyof AggregatePoll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePoll[P]>
      : GetScalarType<T[P], AggregatePoll[P]>;
  };

  export type PollGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollWhereInput;
    orderBy?:
      | PollOrderByWithAggregationInput
      | PollOrderByWithAggregationInput[];
    by: PollScalarFieldEnum[] | PollScalarFieldEnum;
    having?: PollScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PollCountAggregateInputType | true;
    _min?: PollMinAggregateInputType;
    _max?: PollMaxAggregateInputType;
  };

  export type PollGroupByOutputType = {
    id: string;
    question: string;
    description: string | null;
    isAnonymous: boolean;
    isPinned: boolean;
    pinnedAt: Date | null;
    endsAt: Date | null;
    createdAt: Date;
    updatedAt: Date;
    createdById: string;
    announcementId: string | null;
    _count: PollCountAggregateOutputType | null;
    _min: PollMinAggregateOutputType | null;
    _max: PollMaxAggregateOutputType | null;
  };

  type GetPollGroupByPayload<T extends PollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PollGroupByOutputType, T['by']> & {
        [P in keyof T & keyof PollGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], PollGroupByOutputType[P]>
          : GetScalarType<T[P], PollGroupByOutputType[P]>;
      }
    >
  >;

  export type PollSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      question?: boolean;
      description?: boolean;
      isAnonymous?: boolean;
      isPinned?: boolean;
      pinnedAt?: boolean;
      endsAt?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      createdById?: boolean;
      announcementId?: boolean;
      createdBy?: boolean | UserDefaultArgs<ExtArgs>;
      options?: boolean | Poll$optionsArgs<ExtArgs>;
      votes?: boolean | Poll$votesArgs<ExtArgs>;
      announcement?: boolean | Poll$announcementArgs<ExtArgs>;
      _count?: boolean | PollCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['poll']
  >;

  export type PollSelectScalar = {
    id?: boolean;
    question?: boolean;
    description?: boolean;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: boolean;
    endsAt?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
    createdById?: boolean;
    announcementId?: boolean;
  };

  export type PollOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'question'
    | 'description'
    | 'isAnonymous'
    | 'isPinned'
    | 'pinnedAt'
    | 'endsAt'
    | 'createdAt'
    | 'updatedAt'
    | 'createdById'
    | 'announcementId',
    ExtArgs['result']['poll']
  >;
  export type PollInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    createdBy?: boolean | UserDefaultArgs<ExtArgs>;
    options?: boolean | Poll$optionsArgs<ExtArgs>;
    votes?: boolean | Poll$votesArgs<ExtArgs>;
    announcement?: boolean | Poll$announcementArgs<ExtArgs>;
    _count?: boolean | PollCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $PollPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Poll';
    objects: {
      createdBy: Prisma.$UserPayload<ExtArgs>;
      options: Prisma.$PollOptionPayload<ExtArgs>[];
      votes: Prisma.$PollVotePayload<ExtArgs>[];
      announcement: Prisma.$AnnouncementPayload<ExtArgs> | null;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        question: string;
        description: string | null;
        isAnonymous: boolean;
        isPinned: boolean;
        pinnedAt: Date | null;
        endsAt: Date | null;
        createdAt: Date;
        updatedAt: Date;
        createdById: string;
        announcementId: string | null;
      },
      ExtArgs['result']['poll']
    >;
    composites: {};
  };

  type PollGetPayload<S extends boolean | null | undefined | PollDefaultArgs> =
    $Result.GetResult<Prisma.$PollPayload, S>;

  type PollCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PollCountAggregateInputType | true;
  };

  export interface PollDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Poll'];
      meta: { name: 'Poll' };
    };
    /**
     * Find zero or one Poll that matches the filter.
     * @param {PollFindUniqueArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollFindUniqueArgs>(
      args: SelectSubset<T, PollFindUniqueArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Poll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollFindUniqueOrThrowArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PollFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Poll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindFirstArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollFindFirstArgs>(
      args?: SelectSubset<T, PollFindFirstArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Poll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindFirstOrThrowArgs} args - Arguments to find a Poll
     * @example
     * // Get one Poll
     * const poll = await prisma.poll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PollFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Polls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Polls
     * const polls = await prisma.poll.findMany()
     *
     * // Get first 10 Polls
     * const polls = await prisma.poll.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pollWithIdOnly = await prisma.poll.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PollFindManyArgs>(
      args?: SelectSubset<T, PollFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Poll.
     * @param {PollCreateArgs} args - Arguments to create a Poll.
     * @example
     * // Create one Poll
     * const Poll = await prisma.poll.create({
     *   data: {
     *     // ... data to create a Poll
     *   }
     * })
     *
     */
    create<T extends PollCreateArgs>(
      args: SelectSubset<T, PollCreateArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Polls.
     * @param {PollCreateManyArgs} args - Arguments to create many Polls.
     * @example
     * // Create many Polls
     * const poll = await prisma.poll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PollCreateManyArgs>(
      args?: SelectSubset<T, PollCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Poll.
     * @param {PollDeleteArgs} args - Arguments to delete one Poll.
     * @example
     * // Delete one Poll
     * const Poll = await prisma.poll.delete({
     *   where: {
     *     // ... filter to delete one Poll
     *   }
     * })
     *
     */
    delete<T extends PollDeleteArgs>(
      args: SelectSubset<T, PollDeleteArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Poll.
     * @param {PollUpdateArgs} args - Arguments to update one Poll.
     * @example
     * // Update one Poll
     * const poll = await prisma.poll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PollUpdateArgs>(
      args: SelectSubset<T, PollUpdateArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Polls.
     * @param {PollDeleteManyArgs} args - Arguments to filter Polls to delete.
     * @example
     * // Delete a few Polls
     * const { count } = await prisma.poll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PollDeleteManyArgs>(
      args?: SelectSubset<T, PollDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Polls
     * const poll = await prisma.poll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PollUpdateManyArgs>(
      args: SelectSubset<T, PollUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Poll.
     * @param {PollUpsertArgs} args - Arguments to update or create a Poll.
     * @example
     * // Update or create a Poll
     * const poll = await prisma.poll.upsert({
     *   create: {
     *     // ... data to create a Poll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Poll we want to update
     *   }
     * })
     */
    upsert<T extends PollUpsertArgs>(
      args: SelectSubset<T, PollUpsertArgs<ExtArgs>>
    ): Prisma__PollClient<
      $Result.GetResult<
        Prisma.$PollPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Polls that matches the filter.
     * @param {PollFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const poll = await prisma.poll.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PollFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Poll.
     * @param {PollAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const poll = await prisma.poll.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: PollAggregateRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Polls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollCountArgs} args - Arguments to filter Polls to count.
     * @example
     * // Count the number of Polls
     * const count = await prisma.poll.count({
     *   where: {
     *     // ... the filter for the Polls we want to count
     *   }
     * })
     **/
    count<T extends PollCountArgs>(
      args?: Subset<T, PollCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Poll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PollAggregateArgs>(
      args: Subset<T, PollAggregateArgs>
    ): Prisma.PrismaPromise<GetPollAggregateType<T>>;

    /**
     * Group by Poll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollGroupByArgs['orderBy'] }
        : { orderBy?: PollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PollGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPollGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Poll model
     */
    readonly fields: PollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Poll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    createdBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    options<T extends Poll$optionsArgs<ExtArgs> = {}>(
      args?: Subset<T, Poll$optionsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PollOptionPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    votes<T extends Poll$votesArgs<ExtArgs> = {}>(
      args?: Subset<T, Poll$votesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PollVotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    announcement<T extends Poll$announcementArgs<ExtArgs> = {}>(
      args?: Subset<T, Poll$announcementArgs<ExtArgs>>
    ): Prisma__AnnouncementClient<
      $Result.GetResult<
        Prisma.$AnnouncementPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Poll model
   */
  interface PollFieldRefs {
    readonly id: FieldRef<'Poll', 'String'>;
    readonly question: FieldRef<'Poll', 'String'>;
    readonly description: FieldRef<'Poll', 'String'>;
    readonly isAnonymous: FieldRef<'Poll', 'Boolean'>;
    readonly isPinned: FieldRef<'Poll', 'Boolean'>;
    readonly pinnedAt: FieldRef<'Poll', 'DateTime'>;
    readonly endsAt: FieldRef<'Poll', 'DateTime'>;
    readonly createdAt: FieldRef<'Poll', 'DateTime'>;
    readonly updatedAt: FieldRef<'Poll', 'DateTime'>;
    readonly createdById: FieldRef<'Poll', 'String'>;
    readonly announcementId: FieldRef<'Poll', 'String'>;
  }

  // Custom InputTypes
  /**
   * Poll findUnique
   */
  export type PollFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter, which Poll to fetch.
     */
    where: PollWhereUniqueInput;
  };

  /**
   * Poll findUniqueOrThrow
   */
  export type PollFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter, which Poll to fetch.
     */
    where: PollWhereUniqueInput;
  };

  /**
   * Poll findFirst
   */
  export type PollFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter, which Poll to fetch.
     */
    where?: PollWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Polls.
     */
    cursor?: PollWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Polls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Polls.
     */
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[];
  };

  /**
   * Poll findFirstOrThrow
   */
  export type PollFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter, which Poll to fetch.
     */
    where?: PollWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Polls.
     */
    cursor?: PollWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Polls.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Polls.
     */
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[];
  };

  /**
   * Poll findMany
   */
  export type PollFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter, which Polls to fetch.
     */
    where?: PollWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Polls to fetch.
     */
    orderBy?: PollOrderByWithRelationInput | PollOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Polls.
     */
    cursor?: PollWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Polls from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Polls.
     */
    skip?: number;
    distinct?: PollScalarFieldEnum | PollScalarFieldEnum[];
  };

  /**
   * Poll create
   */
  export type PollCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * The data needed to create a Poll.
     */
    data: XOR<PollCreateInput, PollUncheckedCreateInput>;
  };

  /**
   * Poll createMany
   */
  export type PollCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Polls.
     */
    data: PollCreateManyInput | PollCreateManyInput[];
  };

  /**
   * Poll update
   */
  export type PollUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * The data needed to update a Poll.
     */
    data: XOR<PollUpdateInput, PollUncheckedUpdateInput>;
    /**
     * Choose, which Poll to update.
     */
    where: PollWhereUniqueInput;
  };

  /**
   * Poll updateMany
   */
  export type PollUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Polls.
     */
    data: XOR<PollUpdateManyMutationInput, PollUncheckedUpdateManyInput>;
    /**
     * Filter which Polls to update
     */
    where?: PollWhereInput;
    /**
     * Limit how many Polls to update.
     */
    limit?: number;
  };

  /**
   * Poll upsert
   */
  export type PollUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * The filter to search for the Poll to update in case it exists.
     */
    where: PollWhereUniqueInput;
    /**
     * In case the Poll found by the `where` argument doesn't exist, create a new Poll with this data.
     */
    create: XOR<PollCreateInput, PollUncheckedCreateInput>;
    /**
     * In case the Poll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollUpdateInput, PollUncheckedUpdateInput>;
  };

  /**
   * Poll delete
   */
  export type PollDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
    /**
     * Filter which Poll to delete.
     */
    where: PollWhereUniqueInput;
  };

  /**
   * Poll deleteMany
   */
  export type PollDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Polls to delete
     */
    where?: PollWhereInput;
    /**
     * Limit how many Polls to delete.
     */
    limit?: number;
  };

  /**
   * Poll findRaw
   */
  export type PollFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Poll aggregateRaw
   */
  export type PollAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Poll.options
   */
  export type Poll$optionsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    where?: PollOptionWhereInput;
    orderBy?:
      | PollOptionOrderByWithRelationInput
      | PollOptionOrderByWithRelationInput[];
    cursor?: PollOptionWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[];
  };

  /**
   * Poll.votes
   */
  export type Poll$votesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    where?: PollVoteWhereInput;
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    cursor?: PollVoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * Poll.announcement
   */
  export type Poll$announcementArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Announcement
     */
    select?: AnnouncementSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Announcement
     */
    omit?: AnnouncementOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AnnouncementInclude<ExtArgs> | null;
    where?: AnnouncementWhereInput;
  };

  /**
   * Poll without action
   */
  export type PollDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Poll
     */
    select?: PollSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Poll
     */
    omit?: PollOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollInclude<ExtArgs> | null;
  };

  /**
   * Model PollOption
   */

  export type AggregatePollOption = {
    _count: PollOptionCountAggregateOutputType | null;
    _min: PollOptionMinAggregateOutputType | null;
    _max: PollOptionMaxAggregateOutputType | null;
  };

  export type PollOptionMinAggregateOutputType = {
    id: string | null;
    text: string | null;
    pollId: string | null;
  };

  export type PollOptionMaxAggregateOutputType = {
    id: string | null;
    text: string | null;
    pollId: string | null;
  };

  export type PollOptionCountAggregateOutputType = {
    id: number;
    text: number;
    pollId: number;
    _all: number;
  };

  export type PollOptionMinAggregateInputType = {
    id?: true;
    text?: true;
    pollId?: true;
  };

  export type PollOptionMaxAggregateInputType = {
    id?: true;
    text?: true;
    pollId?: true;
  };

  export type PollOptionCountAggregateInputType = {
    id?: true;
    text?: true;
    pollId?: true;
    _all?: true;
  };

  export type PollOptionAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PollOption to aggregate.
     */
    where?: PollOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollOptions to fetch.
     */
    orderBy?:
      | PollOptionOrderByWithRelationInput
      | PollOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PollOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PollOptions
     **/
    _count?: true | PollOptionCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PollOptionMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PollOptionMaxAggregateInputType;
  };

  export type GetPollOptionAggregateType<T extends PollOptionAggregateArgs> = {
    [P in keyof T & keyof AggregatePollOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollOption[P]>
      : GetScalarType<T[P], AggregatePollOption[P]>;
  };

  export type PollOptionGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollOptionWhereInput;
    orderBy?:
      | PollOptionOrderByWithAggregationInput
      | PollOptionOrderByWithAggregationInput[];
    by: PollOptionScalarFieldEnum[] | PollOptionScalarFieldEnum;
    having?: PollOptionScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PollOptionCountAggregateInputType | true;
    _min?: PollOptionMinAggregateInputType;
    _max?: PollOptionMaxAggregateInputType;
  };

  export type PollOptionGroupByOutputType = {
    id: string;
    text: string;
    pollId: string;
    _count: PollOptionCountAggregateOutputType | null;
    _min: PollOptionMinAggregateOutputType | null;
    _max: PollOptionMaxAggregateOutputType | null;
  };

  type GetPollOptionGroupByPayload<T extends PollOptionGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PollOptionGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PollOptionGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollOptionGroupByOutputType[P]>
            : GetScalarType<T[P], PollOptionGroupByOutputType[P]>;
        }
      >
    >;

  export type PollOptionSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      text?: boolean;
      pollId?: boolean;
      poll?: boolean | PollDefaultArgs<ExtArgs>;
      votes?: boolean | PollOption$votesArgs<ExtArgs>;
      _count?: boolean | PollOptionCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['pollOption']
  >;

  export type PollOptionSelectScalar = {
    id?: boolean;
    text?: boolean;
    pollId?: boolean;
  };

  export type PollOptionOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'text' | 'pollId',
    ExtArgs['result']['pollOption']
  >;
  export type PollOptionInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    poll?: boolean | PollDefaultArgs<ExtArgs>;
    votes?: boolean | PollOption$votesArgs<ExtArgs>;
    _count?: boolean | PollOptionCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $PollOptionPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PollOption';
    objects: {
      poll: Prisma.$PollPayload<ExtArgs>;
      votes: Prisma.$PollVotePayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        text: string;
        pollId: string;
      },
      ExtArgs['result']['pollOption']
    >;
    composites: {};
  };

  type PollOptionGetPayload<
    S extends boolean | null | undefined | PollOptionDefaultArgs,
  > = $Result.GetResult<Prisma.$PollOptionPayload, S>;

  type PollOptionCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    PollOptionFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: PollOptionCountAggregateInputType | true;
  };

  export interface PollOptionDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PollOption'];
      meta: { name: 'PollOption' };
    };
    /**
     * Find zero or one PollOption that matches the filter.
     * @param {PollOptionFindUniqueArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollOptionFindUniqueArgs>(
      args: SelectSubset<T, PollOptionFindUniqueArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PollOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollOptionFindUniqueOrThrowArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollOptionFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PollOptionFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PollOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindFirstArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollOptionFindFirstArgs>(
      args?: SelectSubset<T, PollOptionFindFirstArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PollOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindFirstOrThrowArgs} args - Arguments to find a PollOption
     * @example
     * // Get one PollOption
     * const pollOption = await prisma.pollOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollOptionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PollOptionFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PollOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollOptions
     * const pollOptions = await prisma.pollOption.findMany()
     *
     * // Get first 10 PollOptions
     * const pollOptions = await prisma.pollOption.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pollOptionWithIdOnly = await prisma.pollOption.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PollOptionFindManyArgs>(
      args?: SelectSubset<T, PollOptionFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PollOption.
     * @param {PollOptionCreateArgs} args - Arguments to create a PollOption.
     * @example
     * // Create one PollOption
     * const PollOption = await prisma.pollOption.create({
     *   data: {
     *     // ... data to create a PollOption
     *   }
     * })
     *
     */
    create<T extends PollOptionCreateArgs>(
      args: SelectSubset<T, PollOptionCreateArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PollOptions.
     * @param {PollOptionCreateManyArgs} args - Arguments to create many PollOptions.
     * @example
     * // Create many PollOptions
     * const pollOption = await prisma.pollOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PollOptionCreateManyArgs>(
      args?: SelectSubset<T, PollOptionCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PollOption.
     * @param {PollOptionDeleteArgs} args - Arguments to delete one PollOption.
     * @example
     * // Delete one PollOption
     * const PollOption = await prisma.pollOption.delete({
     *   where: {
     *     // ... filter to delete one PollOption
     *   }
     * })
     *
     */
    delete<T extends PollOptionDeleteArgs>(
      args: SelectSubset<T, PollOptionDeleteArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PollOption.
     * @param {PollOptionUpdateArgs} args - Arguments to update one PollOption.
     * @example
     * // Update one PollOption
     * const pollOption = await prisma.pollOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PollOptionUpdateArgs>(
      args: SelectSubset<T, PollOptionUpdateArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PollOptions.
     * @param {PollOptionDeleteManyArgs} args - Arguments to filter PollOptions to delete.
     * @example
     * // Delete a few PollOptions
     * const { count } = await prisma.pollOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PollOptionDeleteManyArgs>(
      args?: SelectSubset<T, PollOptionDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollOptions
     * const pollOption = await prisma.pollOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PollOptionUpdateManyArgs>(
      args: SelectSubset<T, PollOptionUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PollOption.
     * @param {PollOptionUpsertArgs} args - Arguments to update or create a PollOption.
     * @example
     * // Update or create a PollOption
     * const pollOption = await prisma.pollOption.upsert({
     *   create: {
     *     // ... data to create a PollOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollOption we want to update
     *   }
     * })
     */
    upsert<T extends PollOptionUpsertArgs>(
      args: SelectSubset<T, PollOptionUpsertArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      $Result.GetResult<
        Prisma.$PollOptionPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PollOptions that matches the filter.
     * @param {PollOptionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pollOption = await prisma.pollOption.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PollOptionFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a PollOption.
     * @param {PollOptionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pollOption = await prisma.pollOption.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: PollOptionAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of PollOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionCountArgs} args - Arguments to filter PollOptions to count.
     * @example
     * // Count the number of PollOptions
     * const count = await prisma.pollOption.count({
     *   where: {
     *     // ... the filter for the PollOptions we want to count
     *   }
     * })
     **/
    count<T extends PollOptionCountArgs>(
      args?: Subset<T, PollOptionCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollOptionCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PollOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PollOptionAggregateArgs>(
      args: Subset<T, PollOptionAggregateArgs>
    ): Prisma.PrismaPromise<GetPollOptionAggregateType<T>>;

    /**
     * Group by PollOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PollOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollOptionGroupByArgs['orderBy'] }
        : { orderBy?: PollOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PollOptionGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetPollOptionGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PollOption model
     */
    readonly fields: PollOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollOptionClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    poll<T extends PollDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PollDefaultArgs<ExtArgs>>
    ): Prisma__PollClient<
      | $Result.GetResult<
          Prisma.$PollPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    votes<T extends PollOption$votesArgs<ExtArgs> = {}>(
      args?: Subset<T, PollOption$votesArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$PollVotePayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PollOption model
   */
  interface PollOptionFieldRefs {
    readonly id: FieldRef<'PollOption', 'String'>;
    readonly text: FieldRef<'PollOption', 'String'>;
    readonly pollId: FieldRef<'PollOption', 'String'>;
  }

  // Custom InputTypes
  /**
   * PollOption findUnique
   */
  export type PollOptionFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter, which PollOption to fetch.
     */
    where: PollOptionWhereUniqueInput;
  };

  /**
   * PollOption findUniqueOrThrow
   */
  export type PollOptionFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter, which PollOption to fetch.
     */
    where: PollOptionWhereUniqueInput;
  };

  /**
   * PollOption findFirst
   */
  export type PollOptionFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter, which PollOption to fetch.
     */
    where?: PollOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollOptions to fetch.
     */
    orderBy?:
      | PollOptionOrderByWithRelationInput
      | PollOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PollOptions.
     */
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[];
  };

  /**
   * PollOption findFirstOrThrow
   */
  export type PollOptionFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter, which PollOption to fetch.
     */
    where?: PollOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollOptions to fetch.
     */
    orderBy?:
      | PollOptionOrderByWithRelationInput
      | PollOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollOptions.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PollOptions.
     */
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[];
  };

  /**
   * PollOption findMany
   */
  export type PollOptionFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter, which PollOptions to fetch.
     */
    where?: PollOptionWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollOptions to fetch.
     */
    orderBy?:
      | PollOptionOrderByWithRelationInput
      | PollOptionOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PollOptions.
     */
    cursor?: PollOptionWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollOptions from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollOptions.
     */
    skip?: number;
    distinct?: PollOptionScalarFieldEnum | PollOptionScalarFieldEnum[];
  };

  /**
   * PollOption create
   */
  export type PollOptionCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * The data needed to create a PollOption.
     */
    data: XOR<PollOptionCreateInput, PollOptionUncheckedCreateInput>;
  };

  /**
   * PollOption createMany
   */
  export type PollOptionCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PollOptions.
     */
    data: PollOptionCreateManyInput | PollOptionCreateManyInput[];
  };

  /**
   * PollOption update
   */
  export type PollOptionUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * The data needed to update a PollOption.
     */
    data: XOR<PollOptionUpdateInput, PollOptionUncheckedUpdateInput>;
    /**
     * Choose, which PollOption to update.
     */
    where: PollOptionWhereUniqueInput;
  };

  /**
   * PollOption updateMany
   */
  export type PollOptionUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PollOptions.
     */
    data: XOR<
      PollOptionUpdateManyMutationInput,
      PollOptionUncheckedUpdateManyInput
    >;
    /**
     * Filter which PollOptions to update
     */
    where?: PollOptionWhereInput;
    /**
     * Limit how many PollOptions to update.
     */
    limit?: number;
  };

  /**
   * PollOption upsert
   */
  export type PollOptionUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * The filter to search for the PollOption to update in case it exists.
     */
    where: PollOptionWhereUniqueInput;
    /**
     * In case the PollOption found by the `where` argument doesn't exist, create a new PollOption with this data.
     */
    create: XOR<PollOptionCreateInput, PollOptionUncheckedCreateInput>;
    /**
     * In case the PollOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollOptionUpdateInput, PollOptionUncheckedUpdateInput>;
  };

  /**
   * PollOption delete
   */
  export type PollOptionDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
    /**
     * Filter which PollOption to delete.
     */
    where: PollOptionWhereUniqueInput;
  };

  /**
   * PollOption deleteMany
   */
  export type PollOptionDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PollOptions to delete
     */
    where?: PollOptionWhereInput;
    /**
     * Limit how many PollOptions to delete.
     */
    limit?: number;
  };

  /**
   * PollOption findRaw
   */
  export type PollOptionFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PollOption aggregateRaw
   */
  export type PollOptionAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PollOption.votes
   */
  export type PollOption$votesArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    where?: PollVoteWhereInput;
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    cursor?: PollVoteWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * PollOption without action
   */
  export type PollOptionDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollOption
     */
    select?: PollOptionSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollOption
     */
    omit?: PollOptionOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollOptionInclude<ExtArgs> | null;
  };

  /**
   * Model PollVote
   */

  export type AggregatePollVote = {
    _count: PollVoteCountAggregateOutputType | null;
    _min: PollVoteMinAggregateOutputType | null;
    _max: PollVoteMaxAggregateOutputType | null;
  };

  export type PollVoteMinAggregateOutputType = {
    id: string | null;
    pollId: string | null;
    optionId: string | null;
    userId: string | null;
    createdAt: Date | null;
  };

  export type PollVoteMaxAggregateOutputType = {
    id: string | null;
    pollId: string | null;
    optionId: string | null;
    userId: string | null;
    createdAt: Date | null;
  };

  export type PollVoteCountAggregateOutputType = {
    id: number;
    pollId: number;
    optionId: number;
    userId: number;
    createdAt: number;
    _all: number;
  };

  export type PollVoteMinAggregateInputType = {
    id?: true;
    pollId?: true;
    optionId?: true;
    userId?: true;
    createdAt?: true;
  };

  export type PollVoteMaxAggregateInputType = {
    id?: true;
    pollId?: true;
    optionId?: true;
    userId?: true;
    createdAt?: true;
  };

  export type PollVoteCountAggregateInputType = {
    id?: true;
    pollId?: true;
    optionId?: true;
    userId?: true;
    createdAt?: true;
    _all?: true;
  };

  export type PollVoteAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PollVote to aggregate.
     */
    where?: PollVoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollVotes to fetch.
     */
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PollVoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned PollVotes
     **/
    _count?: true | PollVoteCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PollVoteMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PollVoteMaxAggregateInputType;
  };

  export type GetPollVoteAggregateType<T extends PollVoteAggregateArgs> = {
    [P in keyof T & keyof AggregatePollVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePollVote[P]>
      : GetScalarType<T[P], AggregatePollVote[P]>;
  };

  export type PollVoteGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PollVoteWhereInput;
    orderBy?:
      | PollVoteOrderByWithAggregationInput
      | PollVoteOrderByWithAggregationInput[];
    by: PollVoteScalarFieldEnum[] | PollVoteScalarFieldEnum;
    having?: PollVoteScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PollVoteCountAggregateInputType | true;
    _min?: PollVoteMinAggregateInputType;
    _max?: PollVoteMaxAggregateInputType;
  };

  export type PollVoteGroupByOutputType = {
    id: string;
    pollId: string;
    optionId: string;
    userId: string;
    createdAt: Date;
    _count: PollVoteCountAggregateOutputType | null;
    _min: PollVoteMinAggregateOutputType | null;
    _max: PollVoteMaxAggregateOutputType | null;
  };

  type GetPollVoteGroupByPayload<T extends PollVoteGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PollVoteGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PollVoteGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PollVoteGroupByOutputType[P]>
            : GetScalarType<T[P], PollVoteGroupByOutputType[P]>;
        }
      >
    >;

  export type PollVoteSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      pollId?: boolean;
      optionId?: boolean;
      userId?: boolean;
      createdAt?: boolean;
      poll?: boolean | PollDefaultArgs<ExtArgs>;
      option?: boolean | PollOptionDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['pollVote']
  >;

  export type PollVoteSelectScalar = {
    id?: boolean;
    pollId?: boolean;
    optionId?: boolean;
    userId?: boolean;
    createdAt?: boolean;
  };

  export type PollVoteOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'pollId' | 'optionId' | 'userId' | 'createdAt',
    ExtArgs['result']['pollVote']
  >;
  export type PollVoteInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    poll?: boolean | PollDefaultArgs<ExtArgs>;
    option?: boolean | PollOptionDefaultArgs<ExtArgs>;
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PollVotePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'PollVote';
    objects: {
      poll: Prisma.$PollPayload<ExtArgs>;
      option: Prisma.$PollOptionPayload<ExtArgs>;
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        pollId: string;
        optionId: string;
        userId: string;
        createdAt: Date;
      },
      ExtArgs['result']['pollVote']
    >;
    composites: {};
  };

  type PollVoteGetPayload<
    S extends boolean | null | undefined | PollVoteDefaultArgs,
  > = $Result.GetResult<Prisma.$PollVotePayload, S>;

  type PollVoteCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PollVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PollVoteCountAggregateInputType | true;
  };

  export interface PollVoteDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['PollVote'];
      meta: { name: 'PollVote' };
    };
    /**
     * Find zero or one PollVote that matches the filter.
     * @param {PollVoteFindUniqueArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PollVoteFindUniqueArgs>(
      args: SelectSubset<T, PollVoteFindUniqueArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one PollVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PollVoteFindUniqueOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PollVoteFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PollVoteFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PollVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PollVoteFindFirstArgs>(
      args?: SelectSubset<T, PollVoteFindFirstArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first PollVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindFirstOrThrowArgs} args - Arguments to find a PollVote
     * @example
     * // Get one PollVote
     * const pollVote = await prisma.pollVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PollVoteFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PollVoteFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PollVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PollVotes
     * const pollVotes = await prisma.pollVote.findMany()
     *
     * // Get first 10 PollVotes
     * const pollVotes = await prisma.pollVote.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const pollVoteWithIdOnly = await prisma.pollVote.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PollVoteFindManyArgs>(
      args?: SelectSubset<T, PollVoteFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a PollVote.
     * @param {PollVoteCreateArgs} args - Arguments to create a PollVote.
     * @example
     * // Create one PollVote
     * const PollVote = await prisma.pollVote.create({
     *   data: {
     *     // ... data to create a PollVote
     *   }
     * })
     *
     */
    create<T extends PollVoteCreateArgs>(
      args: SelectSubset<T, PollVoteCreateArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many PollVotes.
     * @param {PollVoteCreateManyArgs} args - Arguments to create many PollVotes.
     * @example
     * // Create many PollVotes
     * const pollVote = await prisma.pollVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PollVoteCreateManyArgs>(
      args?: SelectSubset<T, PollVoteCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a PollVote.
     * @param {PollVoteDeleteArgs} args - Arguments to delete one PollVote.
     * @example
     * // Delete one PollVote
     * const PollVote = await prisma.pollVote.delete({
     *   where: {
     *     // ... filter to delete one PollVote
     *   }
     * })
     *
     */
    delete<T extends PollVoteDeleteArgs>(
      args: SelectSubset<T, PollVoteDeleteArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one PollVote.
     * @param {PollVoteUpdateArgs} args - Arguments to update one PollVote.
     * @example
     * // Update one PollVote
     * const pollVote = await prisma.pollVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PollVoteUpdateArgs>(
      args: SelectSubset<T, PollVoteUpdateArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more PollVotes.
     * @param {PollVoteDeleteManyArgs} args - Arguments to filter PollVotes to delete.
     * @example
     * // Delete a few PollVotes
     * const { count } = await prisma.pollVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PollVoteDeleteManyArgs>(
      args?: SelectSubset<T, PollVoteDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PollVotes
     * const pollVote = await prisma.pollVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PollVoteUpdateManyArgs>(
      args: SelectSubset<T, PollVoteUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one PollVote.
     * @param {PollVoteUpsertArgs} args - Arguments to update or create a PollVote.
     * @example
     * // Update or create a PollVote
     * const pollVote = await prisma.pollVote.upsert({
     *   create: {
     *     // ... data to create a PollVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PollVote we want to update
     *   }
     * })
     */
    upsert<T extends PollVoteUpsertArgs>(
      args: SelectSubset<T, PollVoteUpsertArgs<ExtArgs>>
    ): Prisma__PollVoteClient<
      $Result.GetResult<
        Prisma.$PollVotePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more PollVotes that matches the filter.
     * @param {PollVoteFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const pollVote = await prisma.pollVote.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PollVoteFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a PollVote.
     * @param {PollVoteAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const pollVote = await prisma.pollVote.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: PollVoteAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of PollVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteCountArgs} args - Arguments to filter PollVotes to count.
     * @example
     * // Count the number of PollVotes
     * const count = await prisma.pollVote.count({
     *   where: {
     *     // ... the filter for the PollVotes we want to count
     *   }
     * })
     **/
    count<T extends PollVoteCountArgs>(
      args?: Subset<T, PollVoteCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PollVoteCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PollVoteAggregateArgs>(
      args: Subset<T, PollVoteAggregateArgs>
    ): Prisma.PrismaPromise<GetPollVoteAggregateType<T>>;

    /**
     * Group by PollVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PollVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PollVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PollVoteGroupByArgs['orderBy'] }
        : { orderBy?: PollVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PollVoteGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPollVoteGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the PollVote model
     */
    readonly fields: PollVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PollVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PollVoteClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    poll<T extends PollDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PollDefaultArgs<ExtArgs>>
    ): Prisma__PollClient<
      | $Result.GetResult<
          Prisma.$PollPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    option<T extends PollOptionDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, PollOptionDefaultArgs<ExtArgs>>
    ): Prisma__PollOptionClient<
      | $Result.GetResult<
          Prisma.$PollOptionPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the PollVote model
   */
  interface PollVoteFieldRefs {
    readonly id: FieldRef<'PollVote', 'String'>;
    readonly pollId: FieldRef<'PollVote', 'String'>;
    readonly optionId: FieldRef<'PollVote', 'String'>;
    readonly userId: FieldRef<'PollVote', 'String'>;
    readonly createdAt: FieldRef<'PollVote', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * PollVote findUnique
   */
  export type PollVoteFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput;
  };

  /**
   * PollVote findUniqueOrThrow
   */
  export type PollVoteFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter, which PollVote to fetch.
     */
    where: PollVoteWhereUniqueInput;
  };

  /**
   * PollVote findFirst
   */
  export type PollVoteFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollVotes to fetch.
     */
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * PollVote findFirstOrThrow
   */
  export type PollVoteFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter, which PollVote to fetch.
     */
    where?: PollVoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollVotes to fetch.
     */
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollVotes.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of PollVotes.
     */
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * PollVote findMany
   */
  export type PollVoteFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter, which PollVotes to fetch.
     */
    where?: PollVoteWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of PollVotes to fetch.
     */
    orderBy?:
      | PollVoteOrderByWithRelationInput
      | PollVoteOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing PollVotes.
     */
    cursor?: PollVoteWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` PollVotes from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` PollVotes.
     */
    skip?: number;
    distinct?: PollVoteScalarFieldEnum | PollVoteScalarFieldEnum[];
  };

  /**
   * PollVote create
   */
  export type PollVoteCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * The data needed to create a PollVote.
     */
    data: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>;
  };

  /**
   * PollVote createMany
   */
  export type PollVoteCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many PollVotes.
     */
    data: PollVoteCreateManyInput | PollVoteCreateManyInput[];
  };

  /**
   * PollVote update
   */
  export type PollVoteUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * The data needed to update a PollVote.
     */
    data: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>;
    /**
     * Choose, which PollVote to update.
     */
    where: PollVoteWhereUniqueInput;
  };

  /**
   * PollVote updateMany
   */
  export type PollVoteUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update PollVotes.
     */
    data: XOR<
      PollVoteUpdateManyMutationInput,
      PollVoteUncheckedUpdateManyInput
    >;
    /**
     * Filter which PollVotes to update
     */
    where?: PollVoteWhereInput;
    /**
     * Limit how many PollVotes to update.
     */
    limit?: number;
  };

  /**
   * PollVote upsert
   */
  export type PollVoteUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * The filter to search for the PollVote to update in case it exists.
     */
    where: PollVoteWhereUniqueInput;
    /**
     * In case the PollVote found by the `where` argument doesn't exist, create a new PollVote with this data.
     */
    create: XOR<PollVoteCreateInput, PollVoteUncheckedCreateInput>;
    /**
     * In case the PollVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PollVoteUpdateInput, PollVoteUncheckedUpdateInput>;
  };

  /**
   * PollVote delete
   */
  export type PollVoteDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
    /**
     * Filter which PollVote to delete.
     */
    where: PollVoteWhereUniqueInput;
  };

  /**
   * PollVote deleteMany
   */
  export type PollVoteDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which PollVotes to delete
     */
    where?: PollVoteWhereInput;
    /**
     * Limit how many PollVotes to delete.
     */
    limit?: number;
  };

  /**
   * PollVote findRaw
   */
  export type PollVoteFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PollVote aggregateRaw
   */
  export type PollVoteAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * PollVote without action
   */
  export type PollVoteDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the PollVote
     */
    select?: PollVoteSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the PollVote
     */
    omit?: PollVoteOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PollVoteInclude<ExtArgs> | null;
  };

  /**
   * Model Facility
   */

  export type AggregateFacility = {
    _count: FacilityCountAggregateOutputType | null;
    _avg: FacilityAvgAggregateOutputType | null;
    _sum: FacilitySumAggregateOutputType | null;
    _min: FacilityMinAggregateOutputType | null;
    _max: FacilityMaxAggregateOutputType | null;
  };

  export type FacilityAvgAggregateOutputType = {
    capacity: number | null;
    hourlyRate: number | null;
  };

  export type FacilitySumAggregateOutputType = {
    capacity: number | null;
    hourlyRate: number | null;
  };

  export type FacilityMinAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    capacity: number | null;
    hourlyRate: number | null;
    isActive: boolean | null;
    rules: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FacilityMaxAggregateOutputType = {
    id: string | null;
    name: string | null;
    description: string | null;
    capacity: number | null;
    hourlyRate: number | null;
    isActive: boolean | null;
    rules: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FacilityCountAggregateOutputType = {
    id: number;
    name: number;
    description: number;
    capacity: number;
    hourlyRate: number;
    isActive: number;
    amenities: number;
    rules: number;
    images: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FacilityAvgAggregateInputType = {
    capacity?: true;
    hourlyRate?: true;
  };

  export type FacilitySumAggregateInputType = {
    capacity?: true;
    hourlyRate?: true;
  };

  export type FacilityMinAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    capacity?: true;
    hourlyRate?: true;
    isActive?: true;
    rules?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FacilityMaxAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    capacity?: true;
    hourlyRate?: true;
    isActive?: true;
    rules?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FacilityCountAggregateInputType = {
    id?: true;
    name?: true;
    description?: true;
    capacity?: true;
    hourlyRate?: true;
    isActive?: true;
    amenities?: true;
    rules?: true;
    images?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FacilityAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Facility to aggregate.
     */
    where?: FacilityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Facilities to fetch.
     */
    orderBy?:
      | FacilityOrderByWithRelationInput
      | FacilityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FacilityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Facilities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Facilities
     **/
    _count?: true | FacilityCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FacilityAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FacilitySumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FacilityMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FacilityMaxAggregateInputType;
  };

  export type GetFacilityAggregateType<T extends FacilityAggregateArgs> = {
    [P in keyof T & keyof AggregateFacility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacility[P]>
      : GetScalarType<T[P], AggregateFacility[P]>;
  };

  export type FacilityGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacilityWhereInput;
    orderBy?:
      | FacilityOrderByWithAggregationInput
      | FacilityOrderByWithAggregationInput[];
    by: FacilityScalarFieldEnum[] | FacilityScalarFieldEnum;
    having?: FacilityScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FacilityCountAggregateInputType | true;
    _avg?: FacilityAvgAggregateInputType;
    _sum?: FacilitySumAggregateInputType;
    _min?: FacilityMinAggregateInputType;
    _max?: FacilityMaxAggregateInputType;
  };

  export type FacilityGroupByOutputType = {
    id: string;
    name: string;
    description: string | null;
    capacity: number | null;
    hourlyRate: number | null;
    isActive: boolean;
    amenities: string[];
    rules: string | null;
    images: string[];
    createdAt: Date;
    updatedAt: Date;
    _count: FacilityCountAggregateOutputType | null;
    _avg: FacilityAvgAggregateOutputType | null;
    _sum: FacilitySumAggregateOutputType | null;
    _min: FacilityMinAggregateOutputType | null;
    _max: FacilityMaxAggregateOutputType | null;
  };

  type GetFacilityGroupByPayload<T extends FacilityGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FacilityGroupByOutputType, T['by']> & {
          [P in keyof T & keyof FacilityGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityGroupByOutputType[P]>;
        }
      >
    >;

  export type FacilitySelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      capacity?: boolean;
      hourlyRate?: boolean;
      isActive?: boolean;
      amenities?: boolean;
      rules?: boolean;
      images?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      bookings?: boolean | Facility$bookingsArgs<ExtArgs>;
      _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['facility']
  >;

  export type FacilitySelectScalar = {
    id?: boolean;
    name?: boolean;
    description?: boolean;
    capacity?: boolean;
    hourlyRate?: boolean;
    isActive?: boolean;
    amenities?: boolean;
    rules?: boolean;
    images?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FacilityOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'name'
    | 'description'
    | 'capacity'
    | 'hourlyRate'
    | 'isActive'
    | 'amenities'
    | 'rules'
    | 'images'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['facility']
  >;
  export type FacilityInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    bookings?: boolean | Facility$bookingsArgs<ExtArgs>;
    _count?: boolean | FacilityCountOutputTypeDefaultArgs<ExtArgs>;
  };

  export type $FacilityPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Facility';
    objects: {
      bookings: Prisma.$FacilityBookingPayload<ExtArgs>[];
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        name: string;
        description: string | null;
        capacity: number | null;
        hourlyRate: number | null;
        isActive: boolean;
        amenities: string[];
        rules: string | null;
        images: string[];
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['facility']
    >;
    composites: {};
  };

  type FacilityGetPayload<
    S extends boolean | null | undefined | FacilityDefaultArgs,
  > = $Result.GetResult<Prisma.$FacilityPayload, S>;

  type FacilityCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<FacilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: FacilityCountAggregateInputType | true;
  };

  export interface FacilityDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Facility'];
      meta: { name: 'Facility' };
    };
    /**
     * Find zero or one Facility that matches the filter.
     * @param {FacilityFindUniqueArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityFindUniqueArgs>(
      args: SelectSubset<T, FacilityFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Facility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityFindUniqueOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FacilityFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Facility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityFindFirstArgs>(
      args?: SelectSubset<T, FacilityFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Facility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindFirstOrThrowArgs} args - Arguments to find a Facility
     * @example
     * // Get one Facility
     * const facility = await prisma.facility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacilityFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Facilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Facilities
     * const facilities = await prisma.facility.findMany()
     *
     * // Get first 10 Facilities
     * const facilities = await prisma.facility.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const facilityWithIdOnly = await prisma.facility.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FacilityFindManyArgs>(
      args?: SelectSubset<T, FacilityFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Facility.
     * @param {FacilityCreateArgs} args - Arguments to create a Facility.
     * @example
     * // Create one Facility
     * const Facility = await prisma.facility.create({
     *   data: {
     *     // ... data to create a Facility
     *   }
     * })
     *
     */
    create<T extends FacilityCreateArgs>(
      args: SelectSubset<T, FacilityCreateArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Facilities.
     * @param {FacilityCreateManyArgs} args - Arguments to create many Facilities.
     * @example
     * // Create many Facilities
     * const facility = await prisma.facility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FacilityCreateManyArgs>(
      args?: SelectSubset<T, FacilityCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Facility.
     * @param {FacilityDeleteArgs} args - Arguments to delete one Facility.
     * @example
     * // Delete one Facility
     * const Facility = await prisma.facility.delete({
     *   where: {
     *     // ... filter to delete one Facility
     *   }
     * })
     *
     */
    delete<T extends FacilityDeleteArgs>(
      args: SelectSubset<T, FacilityDeleteArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Facility.
     * @param {FacilityUpdateArgs} args - Arguments to update one Facility.
     * @example
     * // Update one Facility
     * const facility = await prisma.facility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FacilityUpdateArgs>(
      args: SelectSubset<T, FacilityUpdateArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Facilities.
     * @param {FacilityDeleteManyArgs} args - Arguments to filter Facilities to delete.
     * @example
     * // Delete a few Facilities
     * const { count } = await prisma.facility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FacilityDeleteManyArgs>(
      args?: SelectSubset<T, FacilityDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Facilities
     * const facility = await prisma.facility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FacilityUpdateManyArgs>(
      args: SelectSubset<T, FacilityUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Facility.
     * @param {FacilityUpsertArgs} args - Arguments to update or create a Facility.
     * @example
     * // Update or create a Facility
     * const facility = await prisma.facility.upsert({
     *   create: {
     *     // ... data to create a Facility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Facility we want to update
     *   }
     * })
     */
    upsert<T extends FacilityUpsertArgs>(
      args: SelectSubset<T, FacilityUpsertArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      $Result.GetResult<
        Prisma.$FacilityPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Facilities that matches the filter.
     * @param {FacilityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const facility = await prisma.facility.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: FacilityFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Facility.
     * @param {FacilityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const facility = await prisma.facility.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FacilityAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Facilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityCountArgs} args - Arguments to filter Facilities to count.
     * @example
     * // Count the number of Facilities
     * const count = await prisma.facility.count({
     *   where: {
     *     // ... the filter for the Facilities we want to count
     *   }
     * })
     **/
    count<T extends FacilityCountArgs>(
      args?: Subset<T, FacilityCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FacilityAggregateArgs>(
      args: Subset<T, FacilityAggregateArgs>
    ): Prisma.PrismaPromise<GetFacilityAggregateType<T>>;

    /**
     * Group by Facility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FacilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityGroupByArgs['orderBy'] }
        : { orderBy?: FacilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FacilityGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetFacilityGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Facility model
     */
    readonly fields: FacilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Facility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    bookings<T extends Facility$bookingsArgs<ExtArgs> = {}>(
      args?: Subset<T, Facility$bookingsArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      | $Result.GetResult<
          Prisma.$FacilityBookingPayload<ExtArgs>,
          T,
          'findMany',
          GlobalOmitOptions
        >
      | Null
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Facility model
   */
  interface FacilityFieldRefs {
    readonly id: FieldRef<'Facility', 'String'>;
    readonly name: FieldRef<'Facility', 'String'>;
    readonly description: FieldRef<'Facility', 'String'>;
    readonly capacity: FieldRef<'Facility', 'Int'>;
    readonly hourlyRate: FieldRef<'Facility', 'Float'>;
    readonly isActive: FieldRef<'Facility', 'Boolean'>;
    readonly amenities: FieldRef<'Facility', 'String[]'>;
    readonly rules: FieldRef<'Facility', 'String'>;
    readonly images: FieldRef<'Facility', 'String[]'>;
    readonly createdAt: FieldRef<'Facility', 'DateTime'>;
    readonly updatedAt: FieldRef<'Facility', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Facility findUnique
   */
  export type FacilityFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput;
  };

  /**
   * Facility findUniqueOrThrow
   */
  export type FacilityFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter, which Facility to fetch.
     */
    where: FacilityWhereUniqueInput;
  };

  /**
   * Facility findFirst
   */
  export type FacilityFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Facilities to fetch.
     */
    orderBy?:
      | FacilityOrderByWithRelationInput
      | FacilityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Facilities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[];
  };

  /**
   * Facility findFirstOrThrow
   */
  export type FacilityFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter, which Facility to fetch.
     */
    where?: FacilityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Facilities to fetch.
     */
    orderBy?:
      | FacilityOrderByWithRelationInput
      | FacilityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Facilities.
     */
    cursor?: FacilityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Facilities.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Facilities.
     */
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[];
  };

  /**
   * Facility findMany
   */
  export type FacilityFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter, which Facilities to fetch.
     */
    where?: FacilityWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Facilities to fetch.
     */
    orderBy?:
      | FacilityOrderByWithRelationInput
      | FacilityOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Facilities.
     */
    cursor?: FacilityWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Facilities from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Facilities.
     */
    skip?: number;
    distinct?: FacilityScalarFieldEnum | FacilityScalarFieldEnum[];
  };

  /**
   * Facility create
   */
  export type FacilityCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * The data needed to create a Facility.
     */
    data: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>;
  };

  /**
   * Facility createMany
   */
  export type FacilityCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Facilities.
     */
    data: FacilityCreateManyInput | FacilityCreateManyInput[];
  };

  /**
   * Facility update
   */
  export type FacilityUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * The data needed to update a Facility.
     */
    data: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>;
    /**
     * Choose, which Facility to update.
     */
    where: FacilityWhereUniqueInput;
  };

  /**
   * Facility updateMany
   */
  export type FacilityUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Facilities.
     */
    data: XOR<
      FacilityUpdateManyMutationInput,
      FacilityUncheckedUpdateManyInput
    >;
    /**
     * Filter which Facilities to update
     */
    where?: FacilityWhereInput;
    /**
     * Limit how many Facilities to update.
     */
    limit?: number;
  };

  /**
   * Facility upsert
   */
  export type FacilityUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * The filter to search for the Facility to update in case it exists.
     */
    where: FacilityWhereUniqueInput;
    /**
     * In case the Facility found by the `where` argument doesn't exist, create a new Facility with this data.
     */
    create: XOR<FacilityCreateInput, FacilityUncheckedCreateInput>;
    /**
     * In case the Facility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FacilityUpdateInput, FacilityUncheckedUpdateInput>;
  };

  /**
   * Facility delete
   */
  export type FacilityDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
    /**
     * Filter which Facility to delete.
     */
    where: FacilityWhereUniqueInput;
  };

  /**
   * Facility deleteMany
   */
  export type FacilityDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Facilities to delete
     */
    where?: FacilityWhereInput;
    /**
     * Limit how many Facilities to delete.
     */
    limit?: number;
  };

  /**
   * Facility findRaw
   */
  export type FacilityFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Facility aggregateRaw
   */
  export type FacilityAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Facility.bookings
   */
  export type Facility$bookingsArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    where?: FacilityBookingWhereInput;
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    cursor?: FacilityBookingWhereUniqueInput;
    take?: number;
    skip?: number;
    distinct?:
      | FacilityBookingScalarFieldEnum
      | FacilityBookingScalarFieldEnum[];
  };

  /**
   * Facility without action
   */
  export type FacilityDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Facility
     */
    select?: FacilitySelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Facility
     */
    omit?: FacilityOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityInclude<ExtArgs> | null;
  };

  /**
   * Model FacilityBooking
   */

  export type AggregateFacilityBooking = {
    _count: FacilityBookingCountAggregateOutputType | null;
    _avg: FacilityBookingAvgAggregateOutputType | null;
    _sum: FacilityBookingSumAggregateOutputType | null;
    _min: FacilityBookingMinAggregateOutputType | null;
    _max: FacilityBookingMaxAggregateOutputType | null;
  };

  export type FacilityBookingAvgAggregateOutputType = {
    totalCost: number | null;
  };

  export type FacilityBookingSumAggregateOutputType = {
    totalCost: number | null;
  };

  export type FacilityBookingMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    facilityId: string | null;
    startTime: Date | null;
    endTime: Date | null;
    purpose: string | null;
    status: $Enums.FacilityBookingStatus | null;
    totalCost: number | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FacilityBookingMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    facilityId: string | null;
    startTime: Date | null;
    endTime: Date | null;
    purpose: string | null;
    status: $Enums.FacilityBookingStatus | null;
    totalCost: number | null;
    notes: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type FacilityBookingCountAggregateOutputType = {
    id: number;
    userId: number;
    facilityId: number;
    startTime: number;
    endTime: number;
    purpose: number;
    status: number;
    totalCost: number;
    notes: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type FacilityBookingAvgAggregateInputType = {
    totalCost?: true;
  };

  export type FacilityBookingSumAggregateInputType = {
    totalCost?: true;
  };

  export type FacilityBookingMinAggregateInputType = {
    id?: true;
    userId?: true;
    facilityId?: true;
    startTime?: true;
    endTime?: true;
    purpose?: true;
    status?: true;
    totalCost?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FacilityBookingMaxAggregateInputType = {
    id?: true;
    userId?: true;
    facilityId?: true;
    startTime?: true;
    endTime?: true;
    purpose?: true;
    status?: true;
    totalCost?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type FacilityBookingCountAggregateInputType = {
    id?: true;
    userId?: true;
    facilityId?: true;
    startTime?: true;
    endTime?: true;
    purpose?: true;
    status?: true;
    totalCost?: true;
    notes?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type FacilityBookingAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FacilityBooking to aggregate.
     */
    where?: FacilityBookingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FacilityBookings to fetch.
     */
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: FacilityBookingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FacilityBookings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FacilityBookings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned FacilityBookings
     **/
    _count?: true | FacilityBookingCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: FacilityBookingAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: FacilityBookingSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: FacilityBookingMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: FacilityBookingMaxAggregateInputType;
  };

  export type GetFacilityBookingAggregateType<
    T extends FacilityBookingAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateFacilityBooking]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFacilityBooking[P]>
      : GetScalarType<T[P], AggregateFacilityBooking[P]>;
  };

  export type FacilityBookingGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: FacilityBookingWhereInput;
    orderBy?:
      | FacilityBookingOrderByWithAggregationInput
      | FacilityBookingOrderByWithAggregationInput[];
    by: FacilityBookingScalarFieldEnum[] | FacilityBookingScalarFieldEnum;
    having?: FacilityBookingScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: FacilityBookingCountAggregateInputType | true;
    _avg?: FacilityBookingAvgAggregateInputType;
    _sum?: FacilityBookingSumAggregateInputType;
    _min?: FacilityBookingMinAggregateInputType;
    _max?: FacilityBookingMaxAggregateInputType;
  };

  export type FacilityBookingGroupByOutputType = {
    id: string;
    userId: string;
    facilityId: string;
    startTime: Date;
    endTime: Date;
    purpose: string | null;
    status: $Enums.FacilityBookingStatus;
    totalCost: number | null;
    notes: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: FacilityBookingCountAggregateOutputType | null;
    _avg: FacilityBookingAvgAggregateOutputType | null;
    _sum: FacilityBookingSumAggregateOutputType | null;
    _min: FacilityBookingMinAggregateOutputType | null;
    _max: FacilityBookingMaxAggregateOutputType | null;
  };

  type GetFacilityBookingGroupByPayload<T extends FacilityBookingGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<FacilityBookingGroupByOutputType, T['by']> & {
          [P in keyof T &
            keyof FacilityBookingGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FacilityBookingGroupByOutputType[P]>
            : GetScalarType<T[P], FacilityBookingGroupByOutputType[P]>;
        }
      >
    >;

  export type FacilityBookingSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      facilityId?: boolean;
      startTime?: boolean;
      endTime?: boolean;
      purpose?: boolean;
      status?: boolean;
      totalCost?: boolean;
      notes?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
      facility?: boolean | FacilityDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['facilityBooking']
  >;

  export type FacilityBookingSelectScalar = {
    id?: boolean;
    userId?: boolean;
    facilityId?: boolean;
    startTime?: boolean;
    endTime?: boolean;
    purpose?: boolean;
    status?: boolean;
    totalCost?: boolean;
    notes?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type FacilityBookingOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'facilityId'
    | 'startTime'
    | 'endTime'
    | 'purpose'
    | 'status'
    | 'totalCost'
    | 'notes'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['facilityBooking']
  >;
  export type FacilityBookingInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
    facility?: boolean | FacilityDefaultArgs<ExtArgs>;
  };

  export type $FacilityBookingPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'FacilityBooking';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
      facility: Prisma.$FacilityPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        facilityId: string;
        startTime: Date;
        endTime: Date;
        purpose: string | null;
        status: $Enums.FacilityBookingStatus;
        totalCost: number | null;
        notes: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['facilityBooking']
    >;
    composites: {};
  };

  type FacilityBookingGetPayload<
    S extends boolean | null | undefined | FacilityBookingDefaultArgs,
  > = $Result.GetResult<Prisma.$FacilityBookingPayload, S>;

  type FacilityBookingCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    FacilityBookingFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: FacilityBookingCountAggregateInputType | true;
  };

  export interface FacilityBookingDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['FacilityBooking'];
      meta: { name: 'FacilityBooking' };
    };
    /**
     * Find zero or one FacilityBooking that matches the filter.
     * @param {FacilityBookingFindUniqueArgs} args - Arguments to find a FacilityBooking
     * @example
     * // Get one FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FacilityBookingFindUniqueArgs>(
      args: SelectSubset<T, FacilityBookingFindUniqueArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one FacilityBooking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FacilityBookingFindUniqueOrThrowArgs} args - Arguments to find a FacilityBooking
     * @example
     * // Get one FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FacilityBookingFindUniqueOrThrowArgs>(
      args: SelectSubset<T, FacilityBookingFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FacilityBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingFindFirstArgs} args - Arguments to find a FacilityBooking
     * @example
     * // Get one FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FacilityBookingFindFirstArgs>(
      args?: SelectSubset<T, FacilityBookingFindFirstArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first FacilityBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingFindFirstOrThrowArgs} args - Arguments to find a FacilityBooking
     * @example
     * // Get one FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FacilityBookingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, FacilityBookingFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FacilityBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FacilityBookings
     * const facilityBookings = await prisma.facilityBooking.findMany()
     *
     * // Get first 10 FacilityBookings
     * const facilityBookings = await prisma.facilityBooking.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const facilityBookingWithIdOnly = await prisma.facilityBooking.findMany({ select: { id: true } })
     *
     */
    findMany<T extends FacilityBookingFindManyArgs>(
      args?: SelectSubset<T, FacilityBookingFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a FacilityBooking.
     * @param {FacilityBookingCreateArgs} args - Arguments to create a FacilityBooking.
     * @example
     * // Create one FacilityBooking
     * const FacilityBooking = await prisma.facilityBooking.create({
     *   data: {
     *     // ... data to create a FacilityBooking
     *   }
     * })
     *
     */
    create<T extends FacilityBookingCreateArgs>(
      args: SelectSubset<T, FacilityBookingCreateArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many FacilityBookings.
     * @param {FacilityBookingCreateManyArgs} args - Arguments to create many FacilityBookings.
     * @example
     * // Create many FacilityBookings
     * const facilityBooking = await prisma.facilityBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends FacilityBookingCreateManyArgs>(
      args?: SelectSubset<T, FacilityBookingCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a FacilityBooking.
     * @param {FacilityBookingDeleteArgs} args - Arguments to delete one FacilityBooking.
     * @example
     * // Delete one FacilityBooking
     * const FacilityBooking = await prisma.facilityBooking.delete({
     *   where: {
     *     // ... filter to delete one FacilityBooking
     *   }
     * })
     *
     */
    delete<T extends FacilityBookingDeleteArgs>(
      args: SelectSubset<T, FacilityBookingDeleteArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one FacilityBooking.
     * @param {FacilityBookingUpdateArgs} args - Arguments to update one FacilityBooking.
     * @example
     * // Update one FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends FacilityBookingUpdateArgs>(
      args: SelectSubset<T, FacilityBookingUpdateArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more FacilityBookings.
     * @param {FacilityBookingDeleteManyArgs} args - Arguments to filter FacilityBookings to delete.
     * @example
     * // Delete a few FacilityBookings
     * const { count } = await prisma.facilityBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends FacilityBookingDeleteManyArgs>(
      args?: SelectSubset<T, FacilityBookingDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more FacilityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FacilityBookings
     * const facilityBooking = await prisma.facilityBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends FacilityBookingUpdateManyArgs>(
      args: SelectSubset<T, FacilityBookingUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one FacilityBooking.
     * @param {FacilityBookingUpsertArgs} args - Arguments to update or create a FacilityBooking.
     * @example
     * // Update or create a FacilityBooking
     * const facilityBooking = await prisma.facilityBooking.upsert({
     *   create: {
     *     // ... data to create a FacilityBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FacilityBooking we want to update
     *   }
     * })
     */
    upsert<T extends FacilityBookingUpsertArgs>(
      args: SelectSubset<T, FacilityBookingUpsertArgs<ExtArgs>>
    ): Prisma__FacilityBookingClient<
      $Result.GetResult<
        Prisma.$FacilityBookingPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more FacilityBookings that matches the filter.
     * @param {FacilityBookingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const facilityBooking = await prisma.facilityBooking.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: FacilityBookingFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a FacilityBooking.
     * @param {FacilityBookingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const facilityBooking = await prisma.facilityBooking.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: FacilityBookingAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of FacilityBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingCountArgs} args - Arguments to filter FacilityBookings to count.
     * @example
     * // Count the number of FacilityBookings
     * const count = await prisma.facilityBooking.count({
     *   where: {
     *     // ... the filter for the FacilityBookings we want to count
     *   }
     * })
     **/
    count<T extends FacilityBookingCountArgs>(
      args?: Subset<T, FacilityBookingCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FacilityBookingCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a FacilityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends FacilityBookingAggregateArgs>(
      args: Subset<T, FacilityBookingAggregateArgs>
    ): Prisma.PrismaPromise<GetFacilityBookingAggregateType<T>>;

    /**
     * Group by FacilityBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FacilityBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends FacilityBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FacilityBookingGroupByArgs['orderBy'] }
        : { orderBy?: FacilityBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, FacilityBookingGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetFacilityBookingGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the FacilityBooking model
     */
    readonly fields: FacilityBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FacilityBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FacilityBookingClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    facility<T extends FacilityDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, FacilityDefaultArgs<ExtArgs>>
    ): Prisma__FacilityClient<
      | $Result.GetResult<
          Prisma.$FacilityPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the FacilityBooking model
   */
  interface FacilityBookingFieldRefs {
    readonly id: FieldRef<'FacilityBooking', 'String'>;
    readonly userId: FieldRef<'FacilityBooking', 'String'>;
    readonly facilityId: FieldRef<'FacilityBooking', 'String'>;
    readonly startTime: FieldRef<'FacilityBooking', 'DateTime'>;
    readonly endTime: FieldRef<'FacilityBooking', 'DateTime'>;
    readonly purpose: FieldRef<'FacilityBooking', 'String'>;
    readonly status: FieldRef<'FacilityBooking', 'FacilityBookingStatus'>;
    readonly totalCost: FieldRef<'FacilityBooking', 'Float'>;
    readonly notes: FieldRef<'FacilityBooking', 'String'>;
    readonly createdAt: FieldRef<'FacilityBooking', 'DateTime'>;
    readonly updatedAt: FieldRef<'FacilityBooking', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * FacilityBooking findUnique
   */
  export type FacilityBookingFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter, which FacilityBooking to fetch.
     */
    where: FacilityBookingWhereUniqueInput;
  };

  /**
   * FacilityBooking findUniqueOrThrow
   */
  export type FacilityBookingFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter, which FacilityBooking to fetch.
     */
    where: FacilityBookingWhereUniqueInput;
  };

  /**
   * FacilityBooking findFirst
   */
  export type FacilityBookingFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter, which FacilityBooking to fetch.
     */
    where?: FacilityBookingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FacilityBookings to fetch.
     */
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FacilityBookings.
     */
    cursor?: FacilityBookingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FacilityBookings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FacilityBookings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FacilityBookings.
     */
    distinct?:
      | FacilityBookingScalarFieldEnum
      | FacilityBookingScalarFieldEnum[];
  };

  /**
   * FacilityBooking findFirstOrThrow
   */
  export type FacilityBookingFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter, which FacilityBooking to fetch.
     */
    where?: FacilityBookingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FacilityBookings to fetch.
     */
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for FacilityBookings.
     */
    cursor?: FacilityBookingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FacilityBookings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FacilityBookings.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of FacilityBookings.
     */
    distinct?:
      | FacilityBookingScalarFieldEnum
      | FacilityBookingScalarFieldEnum[];
  };

  /**
   * FacilityBooking findMany
   */
  export type FacilityBookingFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter, which FacilityBookings to fetch.
     */
    where?: FacilityBookingWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of FacilityBookings to fetch.
     */
    orderBy?:
      | FacilityBookingOrderByWithRelationInput
      | FacilityBookingOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing FacilityBookings.
     */
    cursor?: FacilityBookingWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` FacilityBookings from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` FacilityBookings.
     */
    skip?: number;
    distinct?:
      | FacilityBookingScalarFieldEnum
      | FacilityBookingScalarFieldEnum[];
  };

  /**
   * FacilityBooking create
   */
  export type FacilityBookingCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * The data needed to create a FacilityBooking.
     */
    data: XOR<FacilityBookingCreateInput, FacilityBookingUncheckedCreateInput>;
  };

  /**
   * FacilityBooking createMany
   */
  export type FacilityBookingCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many FacilityBookings.
     */
    data: FacilityBookingCreateManyInput | FacilityBookingCreateManyInput[];
  };

  /**
   * FacilityBooking update
   */
  export type FacilityBookingUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * The data needed to update a FacilityBooking.
     */
    data: XOR<FacilityBookingUpdateInput, FacilityBookingUncheckedUpdateInput>;
    /**
     * Choose, which FacilityBooking to update.
     */
    where: FacilityBookingWhereUniqueInput;
  };

  /**
   * FacilityBooking updateMany
   */
  export type FacilityBookingUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update FacilityBookings.
     */
    data: XOR<
      FacilityBookingUpdateManyMutationInput,
      FacilityBookingUncheckedUpdateManyInput
    >;
    /**
     * Filter which FacilityBookings to update
     */
    where?: FacilityBookingWhereInput;
    /**
     * Limit how many FacilityBookings to update.
     */
    limit?: number;
  };

  /**
   * FacilityBooking upsert
   */
  export type FacilityBookingUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * The filter to search for the FacilityBooking to update in case it exists.
     */
    where: FacilityBookingWhereUniqueInput;
    /**
     * In case the FacilityBooking found by the `where` argument doesn't exist, create a new FacilityBooking with this data.
     */
    create: XOR<
      FacilityBookingCreateInput,
      FacilityBookingUncheckedCreateInput
    >;
    /**
     * In case the FacilityBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      FacilityBookingUpdateInput,
      FacilityBookingUncheckedUpdateInput
    >;
  };

  /**
   * FacilityBooking delete
   */
  export type FacilityBookingDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
    /**
     * Filter which FacilityBooking to delete.
     */
    where: FacilityBookingWhereUniqueInput;
  };

  /**
   * FacilityBooking deleteMany
   */
  export type FacilityBookingDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which FacilityBookings to delete
     */
    where?: FacilityBookingWhereInput;
    /**
     * Limit how many FacilityBookings to delete.
     */
    limit?: number;
  };

  /**
   * FacilityBooking findRaw
   */
  export type FacilityBookingFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FacilityBooking aggregateRaw
   */
  export type FacilityBookingAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * FacilityBooking without action
   */
  export type FacilityBookingDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the FacilityBooking
     */
    select?: FacilityBookingSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the FacilityBooking
     */
    omit?: FacilityBookingOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FacilityBookingInclude<ExtArgs> | null;
  };

  /**
   * Model Complaint
   */

  export type AggregateComplaint = {
    _count: ComplaintCountAggregateOutputType | null;
    _avg: ComplaintAvgAggregateOutputType | null;
    _sum: ComplaintSumAggregateOutputType | null;
    _min: ComplaintMinAggregateOutputType | null;
    _max: ComplaintMaxAggregateOutputType | null;
  };

  export type ComplaintAvgAggregateOutputType = {
    rating: number | null;
  };

  export type ComplaintSumAggregateOutputType = {
    rating: number | null;
  };

  export type ComplaintMinAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    type: $Enums.ComplaintType | null;
    status: $Enums.ComplaintStatus | null;
    userId: string | null;
    resolvedAt: Date | null;
    resolvedBy: string | null;
    rating: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ComplaintMaxAggregateOutputType = {
    id: string | null;
    title: string | null;
    description: string | null;
    type: $Enums.ComplaintType | null;
    status: $Enums.ComplaintStatus | null;
    userId: string | null;
    resolvedAt: Date | null;
    resolvedBy: string | null;
    rating: number | null;
    feedback: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type ComplaintCountAggregateOutputType = {
    id: number;
    title: number;
    description: number;
    type: number;
    status: number;
    userId: number;
    resolvedAt: number;
    resolvedBy: number;
    rating: number;
    feedback: number;
    images: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type ComplaintAvgAggregateInputType = {
    rating?: true;
  };

  export type ComplaintSumAggregateInputType = {
    rating?: true;
  };

  export type ComplaintMinAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    userId?: true;
    resolvedAt?: true;
    resolvedBy?: true;
    rating?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ComplaintMaxAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    userId?: true;
    resolvedAt?: true;
    resolvedBy?: true;
    rating?: true;
    feedback?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type ComplaintCountAggregateInputType = {
    id?: true;
    title?: true;
    description?: true;
    type?: true;
    status?: true;
    userId?: true;
    resolvedAt?: true;
    resolvedBy?: true;
    rating?: true;
    feedback?: true;
    images?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type ComplaintAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Complaint to aggregate.
     */
    where?: ComplaintWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Complaints to fetch.
     */
    orderBy?:
      | ComplaintOrderByWithRelationInput
      | ComplaintOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: ComplaintWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Complaints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Complaints
     **/
    _count?: true | ComplaintCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: ComplaintAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: ComplaintSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: ComplaintMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: ComplaintMaxAggregateInputType;
  };

  export type GetComplaintAggregateType<T extends ComplaintAggregateArgs> = {
    [P in keyof T & keyof AggregateComplaint]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplaint[P]>
      : GetScalarType<T[P], AggregateComplaint[P]>;
  };

  export type ComplaintGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: ComplaintWhereInput;
    orderBy?:
      | ComplaintOrderByWithAggregationInput
      | ComplaintOrderByWithAggregationInput[];
    by: ComplaintScalarFieldEnum[] | ComplaintScalarFieldEnum;
    having?: ComplaintScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: ComplaintCountAggregateInputType | true;
    _avg?: ComplaintAvgAggregateInputType;
    _sum?: ComplaintSumAggregateInputType;
    _min?: ComplaintMinAggregateInputType;
    _max?: ComplaintMaxAggregateInputType;
  };

  export type ComplaintGroupByOutputType = {
    id: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status: $Enums.ComplaintStatus;
    userId: string;
    resolvedAt: Date | null;
    resolvedBy: string | null;
    rating: number | null;
    feedback: string | null;
    images: string[];
    createdAt: Date;
    updatedAt: Date;
    _count: ComplaintCountAggregateOutputType | null;
    _avg: ComplaintAvgAggregateOutputType | null;
    _sum: ComplaintSumAggregateOutputType | null;
    _min: ComplaintMinAggregateOutputType | null;
    _max: ComplaintMaxAggregateOutputType | null;
  };

  type GetComplaintGroupByPayload<T extends ComplaintGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<ComplaintGroupByOutputType, T['by']> & {
          [P in keyof T & keyof ComplaintGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplaintGroupByOutputType[P]>
            : GetScalarType<T[P], ComplaintGroupByOutputType[P]>;
        }
      >
    >;

  export type ComplaintSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      type?: boolean;
      status?: boolean;
      userId?: boolean;
      resolvedAt?: boolean;
      resolvedBy?: boolean;
      rating?: boolean;
      feedback?: boolean;
      images?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['complaint']
  >;

  export type ComplaintSelectScalar = {
    id?: boolean;
    title?: boolean;
    description?: boolean;
    type?: boolean;
    status?: boolean;
    userId?: boolean;
    resolvedAt?: boolean;
    resolvedBy?: boolean;
    rating?: boolean;
    feedback?: boolean;
    images?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type ComplaintOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'title'
    | 'description'
    | 'type'
    | 'status'
    | 'userId'
    | 'resolvedAt'
    | 'resolvedBy'
    | 'rating'
    | 'feedback'
    | 'images'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['complaint']
  >;
  export type ComplaintInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $ComplaintPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Complaint';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        title: string;
        description: string;
        type: $Enums.ComplaintType;
        status: $Enums.ComplaintStatus;
        userId: string;
        resolvedAt: Date | null;
        resolvedBy: string | null;
        rating: number | null;
        feedback: string | null;
        images: string[];
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['complaint']
    >;
    composites: {};
  };

  type ComplaintGetPayload<
    S extends boolean | null | undefined | ComplaintDefaultArgs,
  > = $Result.GetResult<Prisma.$ComplaintPayload, S>;

  type ComplaintCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    ComplaintFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: ComplaintCountAggregateInputType | true;
  };

  export interface ComplaintDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Complaint'];
      meta: { name: 'Complaint' };
    };
    /**
     * Find zero or one Complaint that matches the filter.
     * @param {ComplaintFindUniqueArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplaintFindUniqueArgs>(
      args: SelectSubset<T, ComplaintFindUniqueArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Complaint that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplaintFindUniqueOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplaintFindUniqueOrThrowArgs>(
      args: SelectSubset<T, ComplaintFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Complaint that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplaintFindFirstArgs>(
      args?: SelectSubset<T, ComplaintFindFirstArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Complaint that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindFirstOrThrowArgs} args - Arguments to find a Complaint
     * @example
     * // Get one Complaint
     * const complaint = await prisma.complaint.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplaintFindFirstOrThrowArgs>(
      args?: SelectSubset<T, ComplaintFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Complaints that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Complaints
     * const complaints = await prisma.complaint.findMany()
     *
     * // Get first 10 Complaints
     * const complaints = await prisma.complaint.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const complaintWithIdOnly = await prisma.complaint.findMany({ select: { id: true } })
     *
     */
    findMany<T extends ComplaintFindManyArgs>(
      args?: SelectSubset<T, ComplaintFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Complaint.
     * @param {ComplaintCreateArgs} args - Arguments to create a Complaint.
     * @example
     * // Create one Complaint
     * const Complaint = await prisma.complaint.create({
     *   data: {
     *     // ... data to create a Complaint
     *   }
     * })
     *
     */
    create<T extends ComplaintCreateArgs>(
      args: SelectSubset<T, ComplaintCreateArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Complaints.
     * @param {ComplaintCreateManyArgs} args - Arguments to create many Complaints.
     * @example
     * // Create many Complaints
     * const complaint = await prisma.complaint.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends ComplaintCreateManyArgs>(
      args?: SelectSubset<T, ComplaintCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Complaint.
     * @param {ComplaintDeleteArgs} args - Arguments to delete one Complaint.
     * @example
     * // Delete one Complaint
     * const Complaint = await prisma.complaint.delete({
     *   where: {
     *     // ... filter to delete one Complaint
     *   }
     * })
     *
     */
    delete<T extends ComplaintDeleteArgs>(
      args: SelectSubset<T, ComplaintDeleteArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Complaint.
     * @param {ComplaintUpdateArgs} args - Arguments to update one Complaint.
     * @example
     * // Update one Complaint
     * const complaint = await prisma.complaint.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends ComplaintUpdateArgs>(
      args: SelectSubset<T, ComplaintUpdateArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Complaints.
     * @param {ComplaintDeleteManyArgs} args - Arguments to filter Complaints to delete.
     * @example
     * // Delete a few Complaints
     * const { count } = await prisma.complaint.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends ComplaintDeleteManyArgs>(
      args?: SelectSubset<T, ComplaintDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Complaints
     * const complaint = await prisma.complaint.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends ComplaintUpdateManyArgs>(
      args: SelectSubset<T, ComplaintUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Complaint.
     * @param {ComplaintUpsertArgs} args - Arguments to update or create a Complaint.
     * @example
     * // Update or create a Complaint
     * const complaint = await prisma.complaint.upsert({
     *   create: {
     *     // ... data to create a Complaint
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Complaint we want to update
     *   }
     * })
     */
    upsert<T extends ComplaintUpsertArgs>(
      args: SelectSubset<T, ComplaintUpsertArgs<ExtArgs>>
    ): Prisma__ComplaintClient<
      $Result.GetResult<
        Prisma.$ComplaintPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Complaints that matches the filter.
     * @param {ComplaintFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const complaint = await prisma.complaint.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ComplaintFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Complaint.
     * @param {ComplaintAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const complaint = await prisma.complaint.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: ComplaintAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Complaints.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintCountArgs} args - Arguments to filter Complaints to count.
     * @example
     * // Count the number of Complaints
     * const count = await prisma.complaint.count({
     *   where: {
     *     // ... the filter for the Complaints we want to count
     *   }
     * })
     **/
    count<T extends ComplaintCountArgs>(
      args?: Subset<T, ComplaintCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplaintCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends ComplaintAggregateArgs>(
      args: Subset<T, ComplaintAggregateArgs>
    ): Prisma.PrismaPromise<GetComplaintAggregateType<T>>;

    /**
     * Group by Complaint.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplaintGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends ComplaintGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplaintGroupByArgs['orderBy'] }
        : { orderBy?: ComplaintGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, ComplaintGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetComplaintGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Complaint model
     */
    readonly fields: ComplaintFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Complaint.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplaintClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Complaint model
   */
  interface ComplaintFieldRefs {
    readonly id: FieldRef<'Complaint', 'String'>;
    readonly title: FieldRef<'Complaint', 'String'>;
    readonly description: FieldRef<'Complaint', 'String'>;
    readonly type: FieldRef<'Complaint', 'ComplaintType'>;
    readonly status: FieldRef<'Complaint', 'ComplaintStatus'>;
    readonly userId: FieldRef<'Complaint', 'String'>;
    readonly resolvedAt: FieldRef<'Complaint', 'DateTime'>;
    readonly resolvedBy: FieldRef<'Complaint', 'String'>;
    readonly rating: FieldRef<'Complaint', 'Int'>;
    readonly feedback: FieldRef<'Complaint', 'String'>;
    readonly images: FieldRef<'Complaint', 'String[]'>;
    readonly createdAt: FieldRef<'Complaint', 'DateTime'>;
    readonly updatedAt: FieldRef<'Complaint', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Complaint findUnique
   */
  export type ComplaintFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput;
  };

  /**
   * Complaint findUniqueOrThrow
   */
  export type ComplaintFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter, which Complaint to fetch.
     */
    where: ComplaintWhereUniqueInput;
  };

  /**
   * Complaint findFirst
   */
  export type ComplaintFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Complaints to fetch.
     */
    orderBy?:
      | ComplaintOrderByWithRelationInput
      | ComplaintOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Complaints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[];
  };

  /**
   * Complaint findFirstOrThrow
   */
  export type ComplaintFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter, which Complaint to fetch.
     */
    where?: ComplaintWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Complaints to fetch.
     */
    orderBy?:
      | ComplaintOrderByWithRelationInput
      | ComplaintOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Complaints.
     */
    cursor?: ComplaintWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Complaints.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Complaints.
     */
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[];
  };

  /**
   * Complaint findMany
   */
  export type ComplaintFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter, which Complaints to fetch.
     */
    where?: ComplaintWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Complaints to fetch.
     */
    orderBy?:
      | ComplaintOrderByWithRelationInput
      | ComplaintOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Complaints.
     */
    cursor?: ComplaintWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Complaints from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Complaints.
     */
    skip?: number;
    distinct?: ComplaintScalarFieldEnum | ComplaintScalarFieldEnum[];
  };

  /**
   * Complaint create
   */
  export type ComplaintCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * The data needed to create a Complaint.
     */
    data: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>;
  };

  /**
   * Complaint createMany
   */
  export type ComplaintCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Complaints.
     */
    data: ComplaintCreateManyInput | ComplaintCreateManyInput[];
  };

  /**
   * Complaint update
   */
  export type ComplaintUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * The data needed to update a Complaint.
     */
    data: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>;
    /**
     * Choose, which Complaint to update.
     */
    where: ComplaintWhereUniqueInput;
  };

  /**
   * Complaint updateMany
   */
  export type ComplaintUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Complaints.
     */
    data: XOR<
      ComplaintUpdateManyMutationInput,
      ComplaintUncheckedUpdateManyInput
    >;
    /**
     * Filter which Complaints to update
     */
    where?: ComplaintWhereInput;
    /**
     * Limit how many Complaints to update.
     */
    limit?: number;
  };

  /**
   * Complaint upsert
   */
  export type ComplaintUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * The filter to search for the Complaint to update in case it exists.
     */
    where: ComplaintWhereUniqueInput;
    /**
     * In case the Complaint found by the `where` argument doesn't exist, create a new Complaint with this data.
     */
    create: XOR<ComplaintCreateInput, ComplaintUncheckedCreateInput>;
    /**
     * In case the Complaint was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplaintUpdateInput, ComplaintUncheckedUpdateInput>;
  };

  /**
   * Complaint delete
   */
  export type ComplaintDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
    /**
     * Filter which Complaint to delete.
     */
    where: ComplaintWhereUniqueInput;
  };

  /**
   * Complaint deleteMany
   */
  export type ComplaintDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Complaints to delete
     */
    where?: ComplaintWhereInput;
    /**
     * Limit how many Complaints to delete.
     */
    limit?: number;
  };

  /**
   * Complaint findRaw
   */
  export type ComplaintFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Complaint aggregateRaw
   */
  export type ComplaintAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Complaint without action
   */
  export type ComplaintDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Complaint
     */
    select?: ComplaintSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Complaint
     */
    omit?: ComplaintOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplaintInclude<ExtArgs> | null;
  };

  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  export type PaymentAvgAggregateOutputType = {
    amount: number | null;
  };

  export type PaymentSumAggregateOutputType = {
    amount: number | null;
  };

  export type PaymentMinAggregateOutputType = {
    id: string | null;
    userId: string | null;
    amount: number | null;
    type: $Enums.PaymentType | null;
    description: string | null;
    status: $Enums.PaymentStatus | null;
    dueDate: Date | null;
    paidDate: Date | null;
    paymentMethod: $Enums.PaymentMethod | null;
    transactionId: string | null;
    razorpayOrderId: string | null;
    razorpayPaymentId: string | null;
    receiptUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentMaxAggregateOutputType = {
    id: string | null;
    userId: string | null;
    amount: number | null;
    type: $Enums.PaymentType | null;
    description: string | null;
    status: $Enums.PaymentStatus | null;
    dueDate: Date | null;
    paidDate: Date | null;
    paymentMethod: $Enums.PaymentMethod | null;
    transactionId: string | null;
    razorpayOrderId: string | null;
    razorpayPaymentId: string | null;
    receiptUrl: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type PaymentCountAggregateOutputType = {
    id: number;
    userId: number;
    amount: number;
    type: number;
    description: number;
    status: number;
    dueDate: number;
    paidDate: number;
    paymentMethod: number;
    transactionId: number;
    razorpayOrderId: number;
    razorpayPaymentId: number;
    receiptUrl: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type PaymentAvgAggregateInputType = {
    amount?: true;
  };

  export type PaymentSumAggregateInputType = {
    amount?: true;
  };

  export type PaymentMinAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    description?: true;
    status?: true;
    dueDate?: true;
    paidDate?: true;
    paymentMethod?: true;
    transactionId?: true;
    razorpayOrderId?: true;
    razorpayPaymentId?: true;
    receiptUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentMaxAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    description?: true;
    status?: true;
    dueDate?: true;
    paidDate?: true;
    paymentMethod?: true;
    transactionId?: true;
    razorpayOrderId?: true;
    razorpayPaymentId?: true;
    receiptUrl?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type PaymentCountAggregateInputType = {
    id?: true;
    userId?: true;
    amount?: true;
    type?: true;
    description?: true;
    status?: true;
    dueDate?: true;
    paidDate?: true;
    paymentMethod?: true;
    transactionId?: true;
    razorpayOrderId?: true;
    razorpayPaymentId?: true;
    receiptUrl?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type PaymentAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Payments
     **/
    _count?: true | PaymentCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: PaymentAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: PaymentSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: PaymentMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: PaymentMaxAggregateInputType;
  };

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
    [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>;
  };

  export type PaymentGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: PaymentWhereInput;
    orderBy?:
      | PaymentOrderByWithAggregationInput
      | PaymentOrderByWithAggregationInput[];
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum;
    having?: PaymentScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: PaymentCountAggregateInputType | true;
    _avg?: PaymentAvgAggregateInputType;
    _sum?: PaymentSumAggregateInputType;
    _min?: PaymentMinAggregateInputType;
    _max?: PaymentMaxAggregateInputType;
  };

  export type PaymentGroupByOutputType = {
    id: string;
    userId: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status: $Enums.PaymentStatus;
    dueDate: Date | null;
    paidDate: Date | null;
    paymentMethod: $Enums.PaymentMethod | null;
    transactionId: string | null;
    razorpayOrderId: string | null;
    razorpayPaymentId: string | null;
    receiptUrl: string | null;
    createdAt: Date;
    updatedAt: Date;
    _count: PaymentCountAggregateOutputType | null;
    _avg: PaymentAvgAggregateOutputType | null;
    _sum: PaymentSumAggregateOutputType | null;
    _min: PaymentMinAggregateOutputType | null;
    _max: PaymentMaxAggregateOutputType | null;
  };

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<PaymentGroupByOutputType, T['by']> & {
          [P in keyof T & keyof PaymentGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>;
        }
      >
    >;

  export type PaymentSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      userId?: boolean;
      amount?: boolean;
      type?: boolean;
      description?: boolean;
      status?: boolean;
      dueDate?: boolean;
      paidDate?: boolean;
      paymentMethod?: boolean;
      transactionId?: boolean;
      razorpayOrderId?: boolean;
      razorpayPaymentId?: boolean;
      receiptUrl?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      user?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['payment']
  >;

  export type PaymentSelectScalar = {
    id?: boolean;
    userId?: boolean;
    amount?: boolean;
    type?: boolean;
    description?: boolean;
    status?: boolean;
    dueDate?: boolean;
    paidDate?: boolean;
    paymentMethod?: boolean;
    transactionId?: boolean;
    razorpayOrderId?: boolean;
    razorpayPaymentId?: boolean;
    receiptUrl?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type PaymentOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'userId'
    | 'amount'
    | 'type'
    | 'description'
    | 'status'
    | 'dueDate'
    | 'paidDate'
    | 'paymentMethod'
    | 'transactionId'
    | 'razorpayOrderId'
    | 'razorpayPaymentId'
    | 'receiptUrl'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['payment']
  >;
  export type PaymentInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    user?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $PaymentPayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Payment';
    objects: {
      user: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        userId: string;
        amount: number;
        type: $Enums.PaymentType;
        description: string;
        status: $Enums.PaymentStatus;
        dueDate: Date | null;
        paidDate: Date | null;
        paymentMethod: $Enums.PaymentMethod | null;
        transactionId: string | null;
        razorpayOrderId: string | null;
        razorpayPaymentId: string | null;
        receiptUrl: string | null;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['payment']
    >;
    composites: {};
  };

  type PaymentGetPayload<
    S extends boolean | null | undefined | PaymentDefaultArgs,
  > = $Result.GetResult<Prisma.$PaymentPayload, S>;

  type PaymentCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: PaymentCountAggregateInputType | true;
  };

  export interface PaymentDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Payment'];
      meta: { name: 'Payment' };
    };
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(
      args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(
      args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(
      args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(
      args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     *
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     *
     */
    findMany<T extends PaymentFindManyArgs>(
      args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     *
     */
    create<T extends PaymentCreateArgs>(
      args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends PaymentCreateManyArgs>(
      args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     *
     */
    delete<T extends PaymentDeleteArgs>(
      args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends PaymentUpdateArgs>(
      args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends PaymentDeleteManyArgs>(
      args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends PaymentUpdateManyArgs>(
      args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(
      args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>
    ): Prisma__PaymentClient<
      $Result.GetResult<
        Prisma.$PaymentPayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Payments that matches the filter.
     * @param {PaymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const payment = await prisma.payment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: PaymentFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Payment.
     * @param {PaymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const payment = await prisma.payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: PaymentAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
     **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends PaymentAggregateArgs>(
      args: Subset<T, PaymentAggregateArgs>
    ): Prisma.PrismaPromise<GetPaymentAggregateType<T>>;

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetPaymentGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Payment model
     */
    readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    user<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<'Payment', 'String'>;
    readonly userId: FieldRef<'Payment', 'String'>;
    readonly amount: FieldRef<'Payment', 'Float'>;
    readonly type: FieldRef<'Payment', 'PaymentType'>;
    readonly description: FieldRef<'Payment', 'String'>;
    readonly status: FieldRef<'Payment', 'PaymentStatus'>;
    readonly dueDate: FieldRef<'Payment', 'DateTime'>;
    readonly paidDate: FieldRef<'Payment', 'DateTime'>;
    readonly paymentMethod: FieldRef<'Payment', 'PaymentMethod'>;
    readonly transactionId: FieldRef<'Payment', 'String'>;
    readonly razorpayOrderId: FieldRef<'Payment', 'String'>;
    readonly razorpayPaymentId: FieldRef<'Payment', 'String'>;
    readonly receiptUrl: FieldRef<'Payment', 'String'>;
    readonly createdAt: FieldRef<'Payment', 'DateTime'>;
    readonly updatedAt: FieldRef<'Payment', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Payments to fetch.
     */
    orderBy?:
      | PaymentOrderByWithRelationInput
      | PaymentOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Payments.
     */
    skip?: number;
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[];
  };

  /**
   * Payment create
   */
  export type PaymentCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
  };

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[];
  };

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>;
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to update.
     */
    limit?: number;
  };

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput;
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>;
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>;
  };

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput;
  };

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput;
    /**
     * Limit how many Payments to delete.
     */
    limit?: number;
  };

  /**
   * Payment findRaw
   */
  export type PaymentFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Payment aggregateRaw
   */
  export type PaymentAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null;
  };

  /**
   * Model CommunityFinance
   */

  export type AggregateCommunityFinance = {
    _count: CommunityFinanceCountAggregateOutputType | null;
    _avg: CommunityFinanceAvgAggregateOutputType | null;
    _sum: CommunityFinanceSumAggregateOutputType | null;
    _min: CommunityFinanceMinAggregateOutputType | null;
    _max: CommunityFinanceMaxAggregateOutputType | null;
  };

  export type CommunityFinanceAvgAggregateOutputType = {
    amount: number | null;
  };

  export type CommunityFinanceSumAggregateOutputType = {
    amount: number | null;
  };

  export type CommunityFinanceMinAggregateOutputType = {
    id: string | null;
    amount: number | null;
    type: string | null;
    category: string | null;
    description: string | null;
    date: Date | null;
    recordedById: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommunityFinanceMaxAggregateOutputType = {
    id: string | null;
    amount: number | null;
    type: string | null;
    category: string | null;
    description: string | null;
    date: Date | null;
    recordedById: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type CommunityFinanceCountAggregateOutputType = {
    id: number;
    amount: number;
    type: number;
    category: number;
    description: number;
    date: number;
    recordedById: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type CommunityFinanceAvgAggregateInputType = {
    amount?: true;
  };

  export type CommunityFinanceSumAggregateInputType = {
    amount?: true;
  };

  export type CommunityFinanceMinAggregateInputType = {
    id?: true;
    amount?: true;
    type?: true;
    category?: true;
    description?: true;
    date?: true;
    recordedById?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommunityFinanceMaxAggregateInputType = {
    id?: true;
    amount?: true;
    type?: true;
    category?: true;
    description?: true;
    date?: true;
    recordedById?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type CommunityFinanceCountAggregateInputType = {
    id?: true;
    amount?: true;
    type?: true;
    category?: true;
    description?: true;
    date?: true;
    recordedById?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type CommunityFinanceAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CommunityFinance to aggregate.
     */
    where?: CommunityFinanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommunityFinances to fetch.
     */
    orderBy?:
      | CommunityFinanceOrderByWithRelationInput
      | CommunityFinanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: CommunityFinanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommunityFinances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommunityFinances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned CommunityFinances
     **/
    _count?: true | CommunityFinanceCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to average
     **/
    _avg?: CommunityFinanceAvgAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to sum
     **/
    _sum?: CommunityFinanceSumAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: CommunityFinanceMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: CommunityFinanceMaxAggregateInputType;
  };

  export type GetCommunityFinanceAggregateType<
    T extends CommunityFinanceAggregateArgs,
  > = {
    [P in keyof T & keyof AggregateCommunityFinance]: P extends
      | '_count'
      | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommunityFinance[P]>
      : GetScalarType<T[P], AggregateCommunityFinance[P]>;
  };

  export type CommunityFinanceGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: CommunityFinanceWhereInput;
    orderBy?:
      | CommunityFinanceOrderByWithAggregationInput
      | CommunityFinanceOrderByWithAggregationInput[];
    by: CommunityFinanceScalarFieldEnum[] | CommunityFinanceScalarFieldEnum;
    having?: CommunityFinanceScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: CommunityFinanceCountAggregateInputType | true;
    _avg?: CommunityFinanceAvgAggregateInputType;
    _sum?: CommunityFinanceSumAggregateInputType;
    _min?: CommunityFinanceMinAggregateInputType;
    _max?: CommunityFinanceMaxAggregateInputType;
  };

  export type CommunityFinanceGroupByOutputType = {
    id: string;
    amount: number;
    type: string;
    category: string;
    description: string | null;
    date: Date;
    recordedById: string;
    createdAt: Date;
    updatedAt: Date;
    _count: CommunityFinanceCountAggregateOutputType | null;
    _avg: CommunityFinanceAvgAggregateOutputType | null;
    _sum: CommunityFinanceSumAggregateOutputType | null;
    _min: CommunityFinanceMinAggregateOutputType | null;
    _max: CommunityFinanceMaxAggregateOutputType | null;
  };

  type GetCommunityFinanceGroupByPayload<
    T extends CommunityFinanceGroupByArgs,
  > = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommunityFinanceGroupByOutputType, T['by']> & {
        [P in keyof T &
          keyof CommunityFinanceGroupByOutputType]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : GetScalarType<T[P], CommunityFinanceGroupByOutputType[P]>
          : GetScalarType<T[P], CommunityFinanceGroupByOutputType[P]>;
      }
    >
  >;

  export type CommunityFinanceSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      amount?: boolean;
      type?: boolean;
      category?: boolean;
      description?: boolean;
      date?: boolean;
      recordedById?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      recordedBy?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['communityFinance']
  >;

  export type CommunityFinanceSelectScalar = {
    id?: boolean;
    amount?: boolean;
    type?: boolean;
    category?: boolean;
    description?: boolean;
    date?: boolean;
    recordedById?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type CommunityFinanceOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    | 'id'
    | 'amount'
    | 'type'
    | 'category'
    | 'description'
    | 'date'
    | 'recordedById'
    | 'createdAt'
    | 'updatedAt',
    ExtArgs['result']['communityFinance']
  >;
  export type CommunityFinanceInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    recordedBy?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $CommunityFinancePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'CommunityFinance';
    objects: {
      recordedBy: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        amount: number;
        type: string;
        category: string;
        description: string | null;
        date: Date;
        recordedById: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['communityFinance']
    >;
    composites: {};
  };

  type CommunityFinanceGetPayload<
    S extends boolean | null | undefined | CommunityFinanceDefaultArgs,
  > = $Result.GetResult<Prisma.$CommunityFinancePayload, S>;

  type CommunityFinanceCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<
    CommunityFinanceFindManyArgs,
    'select' | 'include' | 'distinct' | 'omit'
  > & {
    select?: CommunityFinanceCountAggregateInputType | true;
  };

  export interface CommunityFinanceDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['CommunityFinance'];
      meta: { name: 'CommunityFinance' };
    };
    /**
     * Find zero or one CommunityFinance that matches the filter.
     * @param {CommunityFinanceFindUniqueArgs} args - Arguments to find a CommunityFinance
     * @example
     * // Get one CommunityFinance
     * const communityFinance = await prisma.communityFinance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommunityFinanceFindUniqueArgs>(
      args: SelectSubset<T, CommunityFinanceFindUniqueArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one CommunityFinance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CommunityFinanceFindUniqueOrThrowArgs} args - Arguments to find a CommunityFinance
     * @example
     * // Get one CommunityFinance
     * const communityFinance = await prisma.communityFinance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommunityFinanceFindUniqueOrThrowArgs>(
      args: SelectSubset<T, CommunityFinanceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CommunityFinance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceFindFirstArgs} args - Arguments to find a CommunityFinance
     * @example
     * // Get one CommunityFinance
     * const communityFinance = await prisma.communityFinance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommunityFinanceFindFirstArgs>(
      args?: SelectSubset<T, CommunityFinanceFindFirstArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first CommunityFinance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceFindFirstOrThrowArgs} args - Arguments to find a CommunityFinance
     * @example
     * // Get one CommunityFinance
     * const communityFinance = await prisma.communityFinance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommunityFinanceFindFirstOrThrowArgs>(
      args?: SelectSubset<T, CommunityFinanceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CommunityFinances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommunityFinances
     * const communityFinances = await prisma.communityFinance.findMany()
     *
     * // Get first 10 CommunityFinances
     * const communityFinances = await prisma.communityFinance.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const communityFinanceWithIdOnly = await prisma.communityFinance.findMany({ select: { id: true } })
     *
     */
    findMany<T extends CommunityFinanceFindManyArgs>(
      args?: SelectSubset<T, CommunityFinanceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a CommunityFinance.
     * @param {CommunityFinanceCreateArgs} args - Arguments to create a CommunityFinance.
     * @example
     * // Create one CommunityFinance
     * const CommunityFinance = await prisma.communityFinance.create({
     *   data: {
     *     // ... data to create a CommunityFinance
     *   }
     * })
     *
     */
    create<T extends CommunityFinanceCreateArgs>(
      args: SelectSubset<T, CommunityFinanceCreateArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many CommunityFinances.
     * @param {CommunityFinanceCreateManyArgs} args - Arguments to create many CommunityFinances.
     * @example
     * // Create many CommunityFinances
     * const communityFinance = await prisma.communityFinance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends CommunityFinanceCreateManyArgs>(
      args?: SelectSubset<T, CommunityFinanceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a CommunityFinance.
     * @param {CommunityFinanceDeleteArgs} args - Arguments to delete one CommunityFinance.
     * @example
     * // Delete one CommunityFinance
     * const CommunityFinance = await prisma.communityFinance.delete({
     *   where: {
     *     // ... filter to delete one CommunityFinance
     *   }
     * })
     *
     */
    delete<T extends CommunityFinanceDeleteArgs>(
      args: SelectSubset<T, CommunityFinanceDeleteArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one CommunityFinance.
     * @param {CommunityFinanceUpdateArgs} args - Arguments to update one CommunityFinance.
     * @example
     * // Update one CommunityFinance
     * const communityFinance = await prisma.communityFinance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends CommunityFinanceUpdateArgs>(
      args: SelectSubset<T, CommunityFinanceUpdateArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more CommunityFinances.
     * @param {CommunityFinanceDeleteManyArgs} args - Arguments to filter CommunityFinances to delete.
     * @example
     * // Delete a few CommunityFinances
     * const { count } = await prisma.communityFinance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends CommunityFinanceDeleteManyArgs>(
      args?: SelectSubset<T, CommunityFinanceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more CommunityFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommunityFinances
     * const communityFinance = await prisma.communityFinance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends CommunityFinanceUpdateManyArgs>(
      args: SelectSubset<T, CommunityFinanceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one CommunityFinance.
     * @param {CommunityFinanceUpsertArgs} args - Arguments to update or create a CommunityFinance.
     * @example
     * // Update or create a CommunityFinance
     * const communityFinance = await prisma.communityFinance.upsert({
     *   create: {
     *     // ... data to create a CommunityFinance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommunityFinance we want to update
     *   }
     * })
     */
    upsert<T extends CommunityFinanceUpsertArgs>(
      args: SelectSubset<T, CommunityFinanceUpsertArgs<ExtArgs>>
    ): Prisma__CommunityFinanceClient<
      $Result.GetResult<
        Prisma.$CommunityFinancePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more CommunityFinances that matches the filter.
     * @param {CommunityFinanceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const communityFinance = await prisma.communityFinance.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(
      args?: CommunityFinanceFindRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a CommunityFinance.
     * @param {CommunityFinanceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const communityFinance = await prisma.communityFinance.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: CommunityFinanceAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of CommunityFinances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceCountArgs} args - Arguments to filter CommunityFinances to count.
     * @example
     * // Count the number of CommunityFinances
     * const count = await prisma.communityFinance.count({
     *   where: {
     *     // ... the filter for the CommunityFinances we want to count
     *   }
     * })
     **/
    count<T extends CommunityFinanceCountArgs>(
      args?: Subset<T, CommunityFinanceCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommunityFinanceCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a CommunityFinance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends CommunityFinanceAggregateArgs>(
      args: Subset<T, CommunityFinanceAggregateArgs>
    ): Prisma.PrismaPromise<GetCommunityFinanceAggregateType<T>>;

    /**
     * Group by CommunityFinance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommunityFinanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends CommunityFinanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommunityFinanceGroupByArgs['orderBy'] }
        : { orderBy?: CommunityFinanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, CommunityFinanceGroupByArgs, OrderByArg> &
        InputErrors
    ): {} extends InputErrors
      ? GetCommunityFinanceGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the CommunityFinance model
     */
    readonly fields: CommunityFinanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommunityFinance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommunityFinanceClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    recordedBy<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the CommunityFinance model
   */
  interface CommunityFinanceFieldRefs {
    readonly id: FieldRef<'CommunityFinance', 'String'>;
    readonly amount: FieldRef<'CommunityFinance', 'Float'>;
    readonly type: FieldRef<'CommunityFinance', 'String'>;
    readonly category: FieldRef<'CommunityFinance', 'String'>;
    readonly description: FieldRef<'CommunityFinance', 'String'>;
    readonly date: FieldRef<'CommunityFinance', 'DateTime'>;
    readonly recordedById: FieldRef<'CommunityFinance', 'String'>;
    readonly createdAt: FieldRef<'CommunityFinance', 'DateTime'>;
    readonly updatedAt: FieldRef<'CommunityFinance', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * CommunityFinance findUnique
   */
  export type CommunityFinanceFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter, which CommunityFinance to fetch.
     */
    where: CommunityFinanceWhereUniqueInput;
  };

  /**
   * CommunityFinance findUniqueOrThrow
   */
  export type CommunityFinanceFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter, which CommunityFinance to fetch.
     */
    where: CommunityFinanceWhereUniqueInput;
  };

  /**
   * CommunityFinance findFirst
   */
  export type CommunityFinanceFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter, which CommunityFinance to fetch.
     */
    where?: CommunityFinanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommunityFinances to fetch.
     */
    orderBy?:
      | CommunityFinanceOrderByWithRelationInput
      | CommunityFinanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommunityFinances.
     */
    cursor?: CommunityFinanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommunityFinances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommunityFinances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommunityFinances.
     */
    distinct?:
      | CommunityFinanceScalarFieldEnum
      | CommunityFinanceScalarFieldEnum[];
  };

  /**
   * CommunityFinance findFirstOrThrow
   */
  export type CommunityFinanceFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter, which CommunityFinance to fetch.
     */
    where?: CommunityFinanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommunityFinances to fetch.
     */
    orderBy?:
      | CommunityFinanceOrderByWithRelationInput
      | CommunityFinanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for CommunityFinances.
     */
    cursor?: CommunityFinanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommunityFinances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommunityFinances.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of CommunityFinances.
     */
    distinct?:
      | CommunityFinanceScalarFieldEnum
      | CommunityFinanceScalarFieldEnum[];
  };

  /**
   * CommunityFinance findMany
   */
  export type CommunityFinanceFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter, which CommunityFinances to fetch.
     */
    where?: CommunityFinanceWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of CommunityFinances to fetch.
     */
    orderBy?:
      | CommunityFinanceOrderByWithRelationInput
      | CommunityFinanceOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing CommunityFinances.
     */
    cursor?: CommunityFinanceWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` CommunityFinances from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` CommunityFinances.
     */
    skip?: number;
    distinct?:
      | CommunityFinanceScalarFieldEnum
      | CommunityFinanceScalarFieldEnum[];
  };

  /**
   * CommunityFinance create
   */
  export type CommunityFinanceCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * The data needed to create a CommunityFinance.
     */
    data: XOR<
      CommunityFinanceCreateInput,
      CommunityFinanceUncheckedCreateInput
    >;
  };

  /**
   * CommunityFinance createMany
   */
  export type CommunityFinanceCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many CommunityFinances.
     */
    data: CommunityFinanceCreateManyInput | CommunityFinanceCreateManyInput[];
  };

  /**
   * CommunityFinance update
   */
  export type CommunityFinanceUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * The data needed to update a CommunityFinance.
     */
    data: XOR<
      CommunityFinanceUpdateInput,
      CommunityFinanceUncheckedUpdateInput
    >;
    /**
     * Choose, which CommunityFinance to update.
     */
    where: CommunityFinanceWhereUniqueInput;
  };

  /**
   * CommunityFinance updateMany
   */
  export type CommunityFinanceUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update CommunityFinances.
     */
    data: XOR<
      CommunityFinanceUpdateManyMutationInput,
      CommunityFinanceUncheckedUpdateManyInput
    >;
    /**
     * Filter which CommunityFinances to update
     */
    where?: CommunityFinanceWhereInput;
    /**
     * Limit how many CommunityFinances to update.
     */
    limit?: number;
  };

  /**
   * CommunityFinance upsert
   */
  export type CommunityFinanceUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * The filter to search for the CommunityFinance to update in case it exists.
     */
    where: CommunityFinanceWhereUniqueInput;
    /**
     * In case the CommunityFinance found by the `where` argument doesn't exist, create a new CommunityFinance with this data.
     */
    create: XOR<
      CommunityFinanceCreateInput,
      CommunityFinanceUncheckedCreateInput
    >;
    /**
     * In case the CommunityFinance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<
      CommunityFinanceUpdateInput,
      CommunityFinanceUncheckedUpdateInput
    >;
  };

  /**
   * CommunityFinance delete
   */
  export type CommunityFinanceDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
    /**
     * Filter which CommunityFinance to delete.
     */
    where: CommunityFinanceWhereUniqueInput;
  };

  /**
   * CommunityFinance deleteMany
   */
  export type CommunityFinanceDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which CommunityFinances to delete
     */
    where?: CommunityFinanceWhereInput;
    /**
     * Limit how many CommunityFinances to delete.
     */
    limit?: number;
  };

  /**
   * CommunityFinance findRaw
   */
  export type CommunityFinanceFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * CommunityFinance aggregateRaw
   */
  export type CommunityFinanceAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * CommunityFinance without action
   */
  export type CommunityFinanceDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the CommunityFinance
     */
    select?: CommunityFinanceSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the CommunityFinance
     */
    omit?: CommunityFinanceOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommunityFinanceInclude<ExtArgs> | null;
  };

  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  export type MessageMinAggregateOutputType = {
    id: string | null;
    content: string | null;
    senderId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MessageMaxAggregateOutputType = {
    id: string | null;
    content: string | null;
    senderId: string | null;
    createdAt: Date | null;
    updatedAt: Date | null;
  };

  export type MessageCountAggregateOutputType = {
    id: number;
    content: number;
    senderId: number;
    createdAt: number;
    updatedAt: number;
    _all: number;
  };

  export type MessageMinAggregateInputType = {
    id?: true;
    content?: true;
    senderId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MessageMaxAggregateInputType = {
    id?: true;
    content?: true;
    senderId?: true;
    createdAt?: true;
    updatedAt?: true;
  };

  export type MessageCountAggregateInputType = {
    id?: true;
    content?: true;
    senderId?: true;
    createdAt?: true;
    updatedAt?: true;
    _all?: true;
  };

  export type MessageAggregateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Count returned Messages
     **/
    _count?: true | MessageCountAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the minimum value
     **/
    _min?: MessageMinAggregateInputType;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     *
     * Select which fields to find the maximum value
     **/
    _max?: MessageMaxAggregateInputType;
  };

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
    [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>;
  };

  export type MessageGroupByArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    where?: MessageWhereInput;
    orderBy?:
      | MessageOrderByWithAggregationInput
      | MessageOrderByWithAggregationInput[];
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum;
    having?: MessageScalarWhereWithAggregatesInput;
    take?: number;
    skip?: number;
    _count?: MessageCountAggregateInputType | true;
    _min?: MessageMinAggregateInputType;
    _max?: MessageMaxAggregateInputType;
  };

  export type MessageGroupByOutputType = {
    id: string;
    content: string;
    senderId: string;
    createdAt: Date;
    updatedAt: Date;
    _count: MessageCountAggregateOutputType | null;
    _min: MessageMinAggregateOutputType | null;
    _max: MessageMaxAggregateOutputType | null;
  };

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> =
    Prisma.PrismaPromise<
      Array<
        PickEnumerable<MessageGroupByOutputType, T['by']> & {
          [P in keyof T & keyof MessageGroupByOutputType]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>;
        }
      >
    >;

  export type MessageSelect<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetSelect<
    {
      id?: boolean;
      content?: boolean;
      senderId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
      sender?: boolean | UserDefaultArgs<ExtArgs>;
    },
    ExtArgs['result']['message']
  >;

  export type MessageSelectScalar = {
    id?: boolean;
    content?: boolean;
    senderId?: boolean;
    createdAt?: boolean;
    updatedAt?: boolean;
  };

  export type MessageOmit<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = $Extensions.GetOmit<
    'id' | 'content' | 'senderId' | 'createdAt' | 'updatedAt',
    ExtArgs['result']['message']
  >;
  export type MessageInclude<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    sender?: boolean | UserDefaultArgs<ExtArgs>;
  };

  export type $MessagePayload<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    name: 'Message';
    objects: {
      sender: Prisma.$UserPayload<ExtArgs>;
    };
    scalars: $Extensions.GetPayloadResult<
      {
        id: string;
        content: string;
        senderId: string;
        createdAt: Date;
        updatedAt: Date;
      },
      ExtArgs['result']['message']
    >;
    composites: {};
  };

  type MessageGetPayload<
    S extends boolean | null | undefined | MessageDefaultArgs,
  > = $Result.GetResult<Prisma.$MessagePayload, S>;

  type MessageCountArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MessageCountAggregateInputType | true;
  };

  export interface MessageDelegate<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > {
    [K: symbol]: {
      types: Prisma.TypeMap<ExtArgs>['model']['Message'];
      meta: { name: 'Message' };
    };
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(
      args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findUnique',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(
      args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findUniqueOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(
      args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findFirst',
        GlobalOmitOptions
      > | null,
      null,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(
      args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findFirstOrThrow',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     *
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     *
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     *
     */
    findMany<T extends MessageFindManyArgs>(
      args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'findMany',
        GlobalOmitOptions
      >
    >;

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     *
     */
    create<T extends MessageCreateArgs>(
      args: SelectSubset<T, MessageCreateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'create',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *
     */
    createMany<T extends MessageCreateManyArgs>(
      args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     *
     */
    delete<T extends MessageDeleteArgs>(
      args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'delete',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    update<T extends MessageUpdateArgs>(
      args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'update',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     *
     */
    deleteMany<T extends MessageDeleteManyArgs>(
      args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     *
     */
    updateMany<T extends MessageUpdateManyArgs>(
      args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>;

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(
      args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>
    ): Prisma__MessageClient<
      $Result.GetResult<
        Prisma.$MessagePayload<ExtArgs>,
        T,
        'upsert',
        GlobalOmitOptions
      >,
      never,
      ExtArgs,
      GlobalOmitOptions
    >;

    /**
     * Find zero or more Messages that matches the filter.
     * @param {MessageFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const message = await prisma.message.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: MessageFindRawArgs): Prisma.PrismaPromise<JsonObject>;

    /**
     * Perform aggregation operations on a Message.
     * @param {MessageAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const message = await prisma.message.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(
      args?: MessageAggregateRawArgs
    ): Prisma.PrismaPromise<JsonObject>;

    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
     **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >;

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
     **/
    aggregate<T extends MessageAggregateArgs>(
      args: Subset<T, MessageAggregateArgs>
    ): Prisma.PrismaPromise<GetMessageAggregateType<T>>;

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     *
     **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<
        Keys<MaybeTupleToUnion<T['orderBy']>>
      >,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
        ? `Error: "by" must not be empty.`
        : HavingValid extends False
          ? {
              [P in HavingFields]: P extends ByFields
                ? never
                : P extends string
                  ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                  : [
                      Error,
                      'Field ',
                      P,
                      ` in "having" needs to be provided in "by"`,
                    ];
            }[HavingFields]
          : 'take' extends Keys<T>
            ? 'orderBy' extends Keys<T>
              ? ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields]
              : 'Error: If you provide "take", you also need to provide "orderBy"'
            : 'skip' extends Keys<T>
              ? 'orderBy' extends Keys<T>
                ? ByValid extends True
                  ? {}
                  : {
                      [P in OrderFields]: P extends ByFields
                        ? never
                        : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                    }[OrderFields]
                : 'Error: If you provide "skip", you also need to provide "orderBy"'
              : ByValid extends True
                ? {}
                : {
                    [P in OrderFields]: P extends ByFields
                      ? never
                      : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                  }[OrderFields],
    >(
      args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors
    ): {} extends InputErrors
      ? GetMessageGroupByPayload<T>
      : Prisma.PrismaPromise<InputErrors>;
    /**
     * Fields of the Message model
     */
    readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<
    T,
    Null = never,
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
    GlobalOmitOptions = {},
  > extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(
      args?: Subset<T, UserDefaultArgs<ExtArgs>>
    ): Prisma__UserClient<
      | $Result.GetResult<
          Prisma.$UserPayload<ExtArgs>,
          T,
          'findUniqueOrThrow',
          GlobalOmitOptions
        >
      | Null,
      Null,
      ExtArgs,
      GlobalOmitOptions
    >;
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(
      onfulfilled?:
        | ((value: T) => TResult1 | PromiseLike<TResult1>)
        | undefined
        | null,
      onrejected?:
        | ((reason: any) => TResult2 | PromiseLike<TResult2>)
        | undefined
        | null
    ): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(
      onrejected?:
        | ((reason: any) => TResult | PromiseLike<TResult>)
        | undefined
        | null
    ): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }

  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<'Message', 'String'>;
    readonly content: FieldRef<'Message', 'String'>;
    readonly senderId: FieldRef<'Message', 'String'>;
    readonly createdAt: FieldRef<'Message', 'DateTime'>;
    readonly updatedAt: FieldRef<'Message', 'DateTime'>;
  }

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     *
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     *
     * Determine the order of Messages to fetch.
     */
    orderBy?:
      | MessageOrderByWithRelationInput
      | MessageOrderByWithRelationInput[];
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     *
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number;
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     *
     * Skip the first `n` Messages.
     */
    skip?: number;
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[];
  };

  /**
   * Message create
   */
  export type MessageCreateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
  };

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[];
  };

  /**
   * Message update
   */
  export type MessageUpdateArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>;
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to update.
     */
    limit?: number;
  };

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput;
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>;
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>;
  };

  /**
   * Message delete
   */
  export type MessageDeleteArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput;
  };

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput;
    /**
     * Limit how many Messages to delete.
     */
    limit?: number;
  };

  /**
   * Message findRaw
   */
  export type MessageFindRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue;
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Message aggregateRaw
   */
  export type MessageAggregateRawArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[];
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue;
  };

  /**
   * Message without action
   */
  export type MessageDefaultArgs<
    ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
  > = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null;
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null;
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null;
  };

  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id';
    email: 'email';
    phone: 'phone';
    name: 'name';
    password: 'password';
    role: 'role';
    status: 'status';
    rejectionReason: 'rejectionReason';
    provider: 'provider';
    image: 'image';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    approvedById: 'approvedById';
    notificationsEnabled: 'notificationsEnabled';
  };

  export type UserScalarFieldEnum =
    (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

  export const RefreshTokenScalarFieldEnum: {
    id: 'id';
    token: 'token';
    userId: 'userId';
    expiresAt: 'expiresAt';
    revoked: 'revoked';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type RefreshTokenScalarFieldEnum =
    (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum];

  export const PushSubscriptionScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    endpoint: 'endpoint';
    p256dh: 'p256dh';
    auth: 'auth';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PushSubscriptionScalarFieldEnum =
    (typeof PushSubscriptionScalarFieldEnum)[keyof typeof PushSubscriptionScalarFieldEnum];

  export const NotificationScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    title: 'title';
    message: 'message';
    type: 'type';
    read: 'read';
    link: 'link';
    createdAt: 'createdAt';
  };

  export type NotificationScalarFieldEnum =
    (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum];

  export const PropertyScalarFieldEnum: {
    id: 'id';
    block: 'block';
    floor: 'floor';
    flatNumber: 'flatNumber';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PropertyScalarFieldEnum =
    (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum];

  export const AnnouncementScalarFieldEnum: {
    id: 'id';
    title: 'title';
    content: 'content';
    imageUrl: 'imageUrl';
    authorId: 'authorId';
    commentsEnabled: 'commentsEnabled';
    isPinned: 'isPinned';
    pinnedAt: 'pinnedAt';
    expiresAt: 'expiresAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AnnouncementScalarFieldEnum =
    (typeof AnnouncementScalarFieldEnum)[keyof typeof AnnouncementScalarFieldEnum];

  export const AnnouncementLikeScalarFieldEnum: {
    id: 'id';
    announcementId: 'announcementId';
    userId: 'userId';
    createdAt: 'createdAt';
  };

  export type AnnouncementLikeScalarFieldEnum =
    (typeof AnnouncementLikeScalarFieldEnum)[keyof typeof AnnouncementLikeScalarFieldEnum];

  export const AnnouncementCommentScalarFieldEnum: {
    id: 'id';
    content: 'content';
    announcementId: 'announcementId';
    userId: 'userId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type AnnouncementCommentScalarFieldEnum =
    (typeof AnnouncementCommentScalarFieldEnum)[keyof typeof AnnouncementCommentScalarFieldEnum];

  export const ApartmentConfigScalarFieldEnum: {
    id: 'id';
    maxProperties: 'maxProperties';
    numberOfBlocks: 'numberOfBlocks';
    blockNamingConvention: 'blockNamingConvention';
    numberOfFloors: 'numberOfFloors';
    unitsPerFloor: 'unitsPerFloor';
    updatedAt: 'updatedAt';
  };

  export type ApartmentConfigScalarFieldEnum =
    (typeof ApartmentConfigScalarFieldEnum)[keyof typeof ApartmentConfigScalarFieldEnum];

  export const PollScalarFieldEnum: {
    id: 'id';
    question: 'question';
    description: 'description';
    isAnonymous: 'isAnonymous';
    isPinned: 'isPinned';
    pinnedAt: 'pinnedAt';
    endsAt: 'endsAt';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
    createdById: 'createdById';
    announcementId: 'announcementId';
  };

  export type PollScalarFieldEnum =
    (typeof PollScalarFieldEnum)[keyof typeof PollScalarFieldEnum];

  export const PollOptionScalarFieldEnum: {
    id: 'id';
    text: 'text';
    pollId: 'pollId';
  };

  export type PollOptionScalarFieldEnum =
    (typeof PollOptionScalarFieldEnum)[keyof typeof PollOptionScalarFieldEnum];

  export const PollVoteScalarFieldEnum: {
    id: 'id';
    pollId: 'pollId';
    optionId: 'optionId';
    userId: 'userId';
    createdAt: 'createdAt';
  };

  export type PollVoteScalarFieldEnum =
    (typeof PollVoteScalarFieldEnum)[keyof typeof PollVoteScalarFieldEnum];

  export const FacilityScalarFieldEnum: {
    id: 'id';
    name: 'name';
    description: 'description';
    capacity: 'capacity';
    hourlyRate: 'hourlyRate';
    isActive: 'isActive';
    amenities: 'amenities';
    rules: 'rules';
    images: 'images';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FacilityScalarFieldEnum =
    (typeof FacilityScalarFieldEnum)[keyof typeof FacilityScalarFieldEnum];

  export const FacilityBookingScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    facilityId: 'facilityId';
    startTime: 'startTime';
    endTime: 'endTime';
    purpose: 'purpose';
    status: 'status';
    totalCost: 'totalCost';
    notes: 'notes';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type FacilityBookingScalarFieldEnum =
    (typeof FacilityBookingScalarFieldEnum)[keyof typeof FacilityBookingScalarFieldEnum];

  export const ComplaintScalarFieldEnum: {
    id: 'id';
    title: 'title';
    description: 'description';
    type: 'type';
    status: 'status';
    userId: 'userId';
    resolvedAt: 'resolvedAt';
    resolvedBy: 'resolvedBy';
    rating: 'rating';
    feedback: 'feedback';
    images: 'images';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type ComplaintScalarFieldEnum =
    (typeof ComplaintScalarFieldEnum)[keyof typeof ComplaintScalarFieldEnum];

  export const PaymentScalarFieldEnum: {
    id: 'id';
    userId: 'userId';
    amount: 'amount';
    type: 'type';
    description: 'description';
    status: 'status';
    dueDate: 'dueDate';
    paidDate: 'paidDate';
    paymentMethod: 'paymentMethod';
    transactionId: 'transactionId';
    razorpayOrderId: 'razorpayOrderId';
    razorpayPaymentId: 'razorpayPaymentId';
    receiptUrl: 'receiptUrl';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type PaymentScalarFieldEnum =
    (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum];

  export const CommunityFinanceScalarFieldEnum: {
    id: 'id';
    amount: 'amount';
    type: 'type';
    category: 'category';
    description: 'description';
    date: 'date';
    recordedById: 'recordedById';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type CommunityFinanceScalarFieldEnum =
    (typeof CommunityFinanceScalarFieldEnum)[keyof typeof CommunityFinanceScalarFieldEnum];

  export const MessageScalarFieldEnum: {
    id: 'id';
    content: 'content';
    senderId: 'senderId';
    createdAt: 'createdAt';
    updatedAt: 'updatedAt';
  };

  export type MessageScalarFieldEnum =
    (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum];

  export const SortOrder: {
    asc: 'asc';
    desc: 'desc';
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

  export const QueryMode: {
    default: 'default';
    insensitive: 'insensitive';
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode];

  /**
   * Field references
   */

  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String'
  >;

  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'String[]'
  >;

  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole'
  >;

  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserRole[]'
  >;

  /**
   * Reference to a field of type 'UserStatus'
   */
  export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserStatus'
  >;

  /**
   * Reference to a field of type 'UserStatus[]'
   */
  export type ListEnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'UserStatus[]'
  >;

  /**
   * Reference to a field of type 'AuthProvider'
   */
  export type EnumAuthProviderFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'AuthProvider'
  >;

  /**
   * Reference to a field of type 'AuthProvider[]'
   */
  export type ListEnumAuthProviderFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'AuthProvider[]'>;

  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime'
  >;

  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'DateTime[]'
  >;

  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Boolean'
  >;

  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int'
  >;

  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Int[]'
  >;

  /**
   * Reference to a field of type 'BlockNamingConvention'
   */
  export type EnumBlockNamingConventionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'BlockNamingConvention'>;

  /**
   * Reference to a field of type 'BlockNamingConvention[]'
   */
  export type ListEnumBlockNamingConventionFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'BlockNamingConvention[]'>;

  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float'
  >;

  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'Float[]'
  >;

  /**
   * Reference to a field of type 'FacilityBookingStatus'
   */
  export type EnumFacilityBookingStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'FacilityBookingStatus'>;

  /**
   * Reference to a field of type 'FacilityBookingStatus[]'
   */
  export type ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'FacilityBookingStatus[]'>;

  /**
   * Reference to a field of type 'ComplaintType'
   */
  export type EnumComplaintTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'ComplaintType'
  >;

  /**
   * Reference to a field of type 'ComplaintType[]'
   */
  export type ListEnumComplaintTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ComplaintType[]'>;

  /**
   * Reference to a field of type 'ComplaintStatus'
   */
  export type EnumComplaintStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ComplaintStatus'>;

  /**
   * Reference to a field of type 'ComplaintStatus[]'
   */
  export type ListEnumComplaintStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'ComplaintStatus[]'>;

  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'PaymentType'
  >;

  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'PaymentType[]'>;

  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'PaymentStatus'
  >;

  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>;

  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<
    $PrismaModel,
    'PaymentMethod'
  >;

  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> =
    FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>;

  /**
   * Deep Input Types
   */

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[];
    OR?: UserWhereInput[];
    NOT?: UserWhereInput | UserWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    phone?: StringNullableFilter<'User'> | string | null;
    name?: StringFilter<'User'> | string;
    password?: StringNullableFilter<'User'> | string | null;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    status?: EnumUserStatusFilter<'User'> | $Enums.UserStatus;
    rejectionReason?: StringNullableFilter<'User'> | string | null;
    provider?: EnumAuthProviderFilter<'User'> | $Enums.AuthProvider;
    image?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    approvedById?: StringNullableFilter<'User'> | string | null;
    notificationsEnabled?: BoolFilter<'User'> | boolean;
    refreshTokens?: RefreshTokenListRelationFilter;
    pushSubscriptions?: PushSubscriptionListRelationFilter;
    notifications?: NotificationListRelationFilter;
    property?: XOR<
      PropertyNullableScalarRelationFilter,
      PropertyWhereInput
    > | null;
    approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    approvals?: UserListRelationFilter;
    announcements?: AnnouncementListRelationFilter;
    announcementLikes?: AnnouncementLikeListRelationFilter;
    announcementComments?: AnnouncementCommentListRelationFilter;
    createdPolls?: PollListRelationFilter;
    pollVotes?: PollVoteListRelationFilter;
    facilityBookings?: FacilityBookingListRelationFilter;
    complaints?: ComplaintListRelationFilter;
    payments?: PaymentListRelationFilter;
    recordedFinances?: CommunityFinanceListRelationFilter;
    messages?: MessageListRelationFilter;
  };

  export type UserOrderByWithRelationInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    name?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    status?: SortOrder;
    rejectionReason?: SortOrder;
    provider?: SortOrder;
    image?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedById?: SortOrder;
    notificationsEnabled?: SortOrder;
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput;
    pushSubscriptions?: PushSubscriptionOrderByRelationAggregateInput;
    notifications?: NotificationOrderByRelationAggregateInput;
    property?: PropertyOrderByWithRelationInput;
    approvedBy?: UserOrderByWithRelationInput;
    approvals?: UserOrderByRelationAggregateInput;
    announcements?: AnnouncementOrderByRelationAggregateInput;
    announcementLikes?: AnnouncementLikeOrderByRelationAggregateInput;
    announcementComments?: AnnouncementCommentOrderByRelationAggregateInput;
    createdPolls?: PollOrderByRelationAggregateInput;
    pollVotes?: PollVoteOrderByRelationAggregateInput;
    facilityBookings?: FacilityBookingOrderByRelationAggregateInput;
    complaints?: ComplaintOrderByRelationAggregateInput;
    payments?: PaymentOrderByRelationAggregateInput;
    recordedFinances?: CommunityFinanceOrderByRelationAggregateInput;
    messages?: MessageOrderByRelationAggregateInput;
  };

  export type UserWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      email?: string;
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      phone?: StringNullableFilter<'User'> | string | null;
      name?: StringFilter<'User'> | string;
      password?: StringNullableFilter<'User'> | string | null;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      status?: EnumUserStatusFilter<'User'> | $Enums.UserStatus;
      rejectionReason?: StringNullableFilter<'User'> | string | null;
      provider?: EnumAuthProviderFilter<'User'> | $Enums.AuthProvider;
      image?: StringNullableFilter<'User'> | string | null;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      approvedById?: StringNullableFilter<'User'> | string | null;
      notificationsEnabled?: BoolFilter<'User'> | boolean;
      refreshTokens?: RefreshTokenListRelationFilter;
      pushSubscriptions?: PushSubscriptionListRelationFilter;
      notifications?: NotificationListRelationFilter;
      property?: XOR<
        PropertyNullableScalarRelationFilter,
        PropertyWhereInput
      > | null;
      approvedBy?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      approvals?: UserListRelationFilter;
      announcements?: AnnouncementListRelationFilter;
      announcementLikes?: AnnouncementLikeListRelationFilter;
      announcementComments?: AnnouncementCommentListRelationFilter;
      createdPolls?: PollListRelationFilter;
      pollVotes?: PollVoteListRelationFilter;
      facilityBookings?: FacilityBookingListRelationFilter;
      complaints?: ComplaintListRelationFilter;
      payments?: PaymentListRelationFilter;
      recordedFinances?: CommunityFinanceListRelationFilter;
      messages?: MessageListRelationFilter;
    },
    'id' | 'email'
  >;

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    name?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    status?: SortOrder;
    rejectionReason?: SortOrder;
    provider?: SortOrder;
    image?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedById?: SortOrder;
    notificationsEnabled?: SortOrder;
    _count?: UserCountOrderByAggregateInput;
    _max?: UserMaxOrderByAggregateInput;
    _min?: UserMinOrderByAggregateInput;
  };

  export type UserScalarWhereWithAggregatesInput = {
    AND?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    OR?: UserScalarWhereWithAggregatesInput[];
    NOT?:
      | UserScalarWhereWithAggregatesInput
      | UserScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'User'> | string;
    email?: StringWithAggregatesFilter<'User'> | string;
    phone?: StringNullableWithAggregatesFilter<'User'> | string | null;
    name?: StringWithAggregatesFilter<'User'> | string;
    password?: StringNullableWithAggregatesFilter<'User'> | string | null;
    role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
    status?: EnumUserStatusWithAggregatesFilter<'User'> | $Enums.UserStatus;
    rejectionReason?:
      | StringNullableWithAggregatesFilter<'User'>
      | string
      | null;
    provider?:
      | EnumAuthProviderWithAggregatesFilter<'User'>
      | $Enums.AuthProvider;
    image?: StringNullableWithAggregatesFilter<'User'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
    approvedById?: StringNullableWithAggregatesFilter<'User'> | string | null;
    notificationsEnabled?: BoolWithAggregatesFilter<'User'> | boolean;
  };

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
    OR?: RefreshTokenWhereInput[];
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
    id?: StringFilter<'RefreshToken'> | string;
    token?: StringFilter<'RefreshToken'> | string;
    userId?: StringFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    revoked?: BoolFilter<'RefreshToken'> | boolean;
    createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    updatedAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    revoked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      token?: string;
      AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
      OR?: RefreshTokenWhereInput[];
      NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[];
      userId?: StringFilter<'RefreshToken'> | string;
      expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
      revoked?: BoolFilter<'RefreshToken'> | boolean;
      createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
      updatedAt?: DateTimeFilter<'RefreshToken'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'token'
  >;

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    revoked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: RefreshTokenCountOrderByAggregateInput;
    _max?: RefreshTokenMaxOrderByAggregateInput;
    _min?: RefreshTokenMinOrderByAggregateInput;
  };

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?:
      | RefreshTokenScalarWhereWithAggregatesInput
      | RefreshTokenScalarWhereWithAggregatesInput[];
    OR?: RefreshTokenScalarWhereWithAggregatesInput[];
    NOT?:
      | RefreshTokenScalarWhereWithAggregatesInput
      | RefreshTokenScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'RefreshToken'> | string;
    token?: StringWithAggregatesFilter<'RefreshToken'> | string;
    userId?: StringWithAggregatesFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeWithAggregatesFilter<'RefreshToken'> | Date | string;
    revoked?: BoolWithAggregatesFilter<'RefreshToken'> | boolean;
    createdAt?: DateTimeWithAggregatesFilter<'RefreshToken'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'RefreshToken'> | Date | string;
  };

  export type PushSubscriptionWhereInput = {
    AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
    OR?: PushSubscriptionWhereInput[];
    NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
    id?: StringFilter<'PushSubscription'> | string;
    userId?: StringFilter<'PushSubscription'> | string;
    endpoint?: StringFilter<'PushSubscription'> | string;
    p256dh?: StringFilter<'PushSubscription'> | string;
    auth?: StringFilter<'PushSubscription'> | string;
    createdAt?: DateTimeFilter<'PushSubscription'> | Date | string;
    updatedAt?: DateTimeFilter<'PushSubscription'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type PushSubscriptionOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    endpoint?: SortOrder;
    p256dh?: SortOrder;
    auth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PushSubscriptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      endpoint?: string;
      AND?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
      OR?: PushSubscriptionWhereInput[];
      NOT?: PushSubscriptionWhereInput | PushSubscriptionWhereInput[];
      userId?: StringFilter<'PushSubscription'> | string;
      p256dh?: StringFilter<'PushSubscription'> | string;
      auth?: StringFilter<'PushSubscription'> | string;
      createdAt?: DateTimeFilter<'PushSubscription'> | Date | string;
      updatedAt?: DateTimeFilter<'PushSubscription'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'endpoint'
  >;

  export type PushSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    endpoint?: SortOrder;
    p256dh?: SortOrder;
    auth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PushSubscriptionCountOrderByAggregateInput;
    _max?: PushSubscriptionMaxOrderByAggregateInput;
    _min?: PushSubscriptionMinOrderByAggregateInput;
  };

  export type PushSubscriptionScalarWhereWithAggregatesInput = {
    AND?:
      | PushSubscriptionScalarWhereWithAggregatesInput
      | PushSubscriptionScalarWhereWithAggregatesInput[];
    OR?: PushSubscriptionScalarWhereWithAggregatesInput[];
    NOT?:
      | PushSubscriptionScalarWhereWithAggregatesInput
      | PushSubscriptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PushSubscription'> | string;
    userId?: StringWithAggregatesFilter<'PushSubscription'> | string;
    endpoint?: StringWithAggregatesFilter<'PushSubscription'> | string;
    p256dh?: StringWithAggregatesFilter<'PushSubscription'> | string;
    auth?: StringWithAggregatesFilter<'PushSubscription'> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'PushSubscription'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'PushSubscription'>
      | Date
      | string;
  };

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[];
    OR?: NotificationWhereInput[];
    NOT?: NotificationWhereInput | NotificationWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    read?: BoolFilter<'Notification'> | boolean;
    link?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    read?: SortOrder;
    link?: SortOrder;
    createdAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type NotificationWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: NotificationWhereInput | NotificationWhereInput[];
      OR?: NotificationWhereInput[];
      NOT?: NotificationWhereInput | NotificationWhereInput[];
      userId?: StringFilter<'Notification'> | string;
      title?: StringFilter<'Notification'> | string;
      message?: StringFilter<'Notification'> | string;
      type?: StringFilter<'Notification'> | string;
      read?: BoolFilter<'Notification'> | boolean;
      link?: StringNullableFilter<'Notification'> | string | null;
      createdAt?: DateTimeFilter<'Notification'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    read?: SortOrder;
    link?: SortOrder;
    createdAt?: SortOrder;
    _count?: NotificationCountOrderByAggregateInput;
    _max?: NotificationMaxOrderByAggregateInput;
    _min?: NotificationMinOrderByAggregateInput;
  };

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    OR?: NotificationScalarWhereWithAggregatesInput[];
    NOT?:
      | NotificationScalarWhereWithAggregatesInput
      | NotificationScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Notification'> | string;
    userId?: StringWithAggregatesFilter<'Notification'> | string;
    title?: StringWithAggregatesFilter<'Notification'> | string;
    message?: StringWithAggregatesFilter<'Notification'> | string;
    type?: StringWithAggregatesFilter<'Notification'> | string;
    read?: BoolWithAggregatesFilter<'Notification'> | boolean;
    link?: StringNullableWithAggregatesFilter<'Notification'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Notification'> | Date | string;
  };

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[];
    OR?: PropertyWhereInput[];
    NOT?: PropertyWhereInput | PropertyWhereInput[];
    id?: StringFilter<'Property'> | string;
    block?: StringFilter<'Property'> | string;
    floor?: StringFilter<'Property'> | string;
    flatNumber?: StringFilter<'Property'> | string;
    userId?: StringNullableFilter<'Property'> | string | null;
    createdAt?: DateTimeFilter<'Property'> | Date | string;
    updatedAt?: DateTimeFilter<'Property'> | Date | string;
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
  };

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder;
    block?: SortOrder;
    floor?: SortOrder;
    flatNumber?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PropertyWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId?: string;
      AND?: PropertyWhereInput | PropertyWhereInput[];
      OR?: PropertyWhereInput[];
      NOT?: PropertyWhereInput | PropertyWhereInput[];
      block?: StringFilter<'Property'> | string;
      floor?: StringFilter<'Property'> | string;
      flatNumber?: StringFilter<'Property'> | string;
      createdAt?: DateTimeFilter<'Property'> | Date | string;
      updatedAt?: DateTimeFilter<'Property'> | Date | string;
      user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
    },
    'id' | 'userId'
  >;

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder;
    block?: SortOrder;
    floor?: SortOrder;
    flatNumber?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PropertyCountOrderByAggregateInput;
    _max?: PropertyMaxOrderByAggregateInput;
    _min?: PropertyMinOrderByAggregateInput;
  };

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?:
      | PropertyScalarWhereWithAggregatesInput
      | PropertyScalarWhereWithAggregatesInput[];
    OR?: PropertyScalarWhereWithAggregatesInput[];
    NOT?:
      | PropertyScalarWhereWithAggregatesInput
      | PropertyScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Property'> | string;
    block?: StringWithAggregatesFilter<'Property'> | string;
    floor?: StringWithAggregatesFilter<'Property'> | string;
    flatNumber?: StringWithAggregatesFilter<'Property'> | string;
    userId?: StringNullableWithAggregatesFilter<'Property'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Property'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Property'> | Date | string;
  };

  export type AnnouncementWhereInput = {
    AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
    OR?: AnnouncementWhereInput[];
    NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
    id?: StringFilter<'Announcement'> | string;
    title?: StringFilter<'Announcement'> | string;
    content?: StringFilter<'Announcement'> | string;
    imageUrl?: StringNullableFilter<'Announcement'> | string | null;
    authorId?: StringFilter<'Announcement'> | string;
    commentsEnabled?: BoolFilter<'Announcement'> | boolean;
    isPinned?: BoolFilter<'Announcement'> | boolean;
    pinnedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    createdAt?: DateTimeFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
    author?: XOR<UserScalarRelationFilter, UserWhereInput>;
    likes?: AnnouncementLikeListRelationFilter;
    comments?: AnnouncementCommentListRelationFilter;
    poll?: XOR<PollNullableScalarRelationFilter, PollWhereInput> | null;
  };

  export type AnnouncementOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    imageUrl?: SortOrder;
    authorId?: SortOrder;
    commentsEnabled?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    author?: UserOrderByWithRelationInput;
    likes?: AnnouncementLikeOrderByRelationAggregateInput;
    comments?: AnnouncementCommentOrderByRelationAggregateInput;
    poll?: PollOrderByWithRelationInput;
  };

  export type AnnouncementWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AnnouncementWhereInput | AnnouncementWhereInput[];
      OR?: AnnouncementWhereInput[];
      NOT?: AnnouncementWhereInput | AnnouncementWhereInput[];
      title?: StringFilter<'Announcement'> | string;
      content?: StringFilter<'Announcement'> | string;
      imageUrl?: StringNullableFilter<'Announcement'> | string | null;
      authorId?: StringFilter<'Announcement'> | string;
      commentsEnabled?: BoolFilter<'Announcement'> | boolean;
      isPinned?: BoolFilter<'Announcement'> | boolean;
      pinnedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
      expiresAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
      createdAt?: DateTimeFilter<'Announcement'> | Date | string;
      updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
      author?: XOR<UserScalarRelationFilter, UserWhereInput>;
      likes?: AnnouncementLikeListRelationFilter;
      comments?: AnnouncementCommentListRelationFilter;
      poll?: XOR<PollNullableScalarRelationFilter, PollWhereInput> | null;
    },
    'id'
  >;

  export type AnnouncementOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    imageUrl?: SortOrder;
    authorId?: SortOrder;
    commentsEnabled?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AnnouncementCountOrderByAggregateInput;
    _max?: AnnouncementMaxOrderByAggregateInput;
    _min?: AnnouncementMinOrderByAggregateInput;
  };

  export type AnnouncementScalarWhereWithAggregatesInput = {
    AND?:
      | AnnouncementScalarWhereWithAggregatesInput
      | AnnouncementScalarWhereWithAggregatesInput[];
    OR?: AnnouncementScalarWhereWithAggregatesInput[];
    NOT?:
      | AnnouncementScalarWhereWithAggregatesInput
      | AnnouncementScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Announcement'> | string;
    title?: StringWithAggregatesFilter<'Announcement'> | string;
    content?: StringWithAggregatesFilter<'Announcement'> | string;
    imageUrl?:
      | StringNullableWithAggregatesFilter<'Announcement'>
      | string
      | null;
    authorId?: StringWithAggregatesFilter<'Announcement'> | string;
    commentsEnabled?: BoolWithAggregatesFilter<'Announcement'> | boolean;
    isPinned?: BoolWithAggregatesFilter<'Announcement'> | boolean;
    pinnedAt?:
      | DateTimeNullableWithAggregatesFilter<'Announcement'>
      | Date
      | string
      | null;
    expiresAt?:
      | DateTimeNullableWithAggregatesFilter<'Announcement'>
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Announcement'> | Date | string;
  };

  export type AnnouncementLikeWhereInput = {
    AND?: AnnouncementLikeWhereInput | AnnouncementLikeWhereInput[];
    OR?: AnnouncementLikeWhereInput[];
    NOT?: AnnouncementLikeWhereInput | AnnouncementLikeWhereInput[];
    id?: StringFilter<'AnnouncementLike'> | string;
    announcementId?: StringFilter<'AnnouncementLike'> | string;
    userId?: StringFilter<'AnnouncementLike'> | string;
    createdAt?: DateTimeFilter<'AnnouncementLike'> | Date | string;
    announcement?: XOR<
      AnnouncementScalarRelationFilter,
      AnnouncementWhereInput
    >;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AnnouncementLikeOrderByWithRelationInput = {
    id?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    announcement?: AnnouncementOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type AnnouncementLikeWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      announcementId_userId?: AnnouncementLikeAnnouncementIdUserIdCompoundUniqueInput;
      AND?: AnnouncementLikeWhereInput | AnnouncementLikeWhereInput[];
      OR?: AnnouncementLikeWhereInput[];
      NOT?: AnnouncementLikeWhereInput | AnnouncementLikeWhereInput[];
      announcementId?: StringFilter<'AnnouncementLike'> | string;
      userId?: StringFilter<'AnnouncementLike'> | string;
      createdAt?: DateTimeFilter<'AnnouncementLike'> | Date | string;
      announcement?: XOR<
        AnnouncementScalarRelationFilter,
        AnnouncementWhereInput
      >;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'announcementId_userId'
  >;

  export type AnnouncementLikeOrderByWithAggregationInput = {
    id?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    _count?: AnnouncementLikeCountOrderByAggregateInput;
    _max?: AnnouncementLikeMaxOrderByAggregateInput;
    _min?: AnnouncementLikeMinOrderByAggregateInput;
  };

  export type AnnouncementLikeScalarWhereWithAggregatesInput = {
    AND?:
      | AnnouncementLikeScalarWhereWithAggregatesInput
      | AnnouncementLikeScalarWhereWithAggregatesInput[];
    OR?: AnnouncementLikeScalarWhereWithAggregatesInput[];
    NOT?:
      | AnnouncementLikeScalarWhereWithAggregatesInput
      | AnnouncementLikeScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AnnouncementLike'> | string;
    announcementId?: StringWithAggregatesFilter<'AnnouncementLike'> | string;
    userId?: StringWithAggregatesFilter<'AnnouncementLike'> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'AnnouncementLike'>
      | Date
      | string;
  };

  export type AnnouncementCommentWhereInput = {
    AND?: AnnouncementCommentWhereInput | AnnouncementCommentWhereInput[];
    OR?: AnnouncementCommentWhereInput[];
    NOT?: AnnouncementCommentWhereInput | AnnouncementCommentWhereInput[];
    id?: StringFilter<'AnnouncementComment'> | string;
    content?: StringFilter<'AnnouncementComment'> | string;
    announcementId?: StringFilter<'AnnouncementComment'> | string;
    userId?: StringFilter<'AnnouncementComment'> | string;
    createdAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
    updatedAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
    announcement?: XOR<
      AnnouncementScalarRelationFilter,
      AnnouncementWhereInput
    >;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type AnnouncementCommentOrderByWithRelationInput = {
    id?: SortOrder;
    content?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    announcement?: AnnouncementOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type AnnouncementCommentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: AnnouncementCommentWhereInput | AnnouncementCommentWhereInput[];
      OR?: AnnouncementCommentWhereInput[];
      NOT?: AnnouncementCommentWhereInput | AnnouncementCommentWhereInput[];
      content?: StringFilter<'AnnouncementComment'> | string;
      announcementId?: StringFilter<'AnnouncementComment'> | string;
      userId?: StringFilter<'AnnouncementComment'> | string;
      createdAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
      updatedAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
      announcement?: XOR<
        AnnouncementScalarRelationFilter,
        AnnouncementWhereInput
      >;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type AnnouncementCommentOrderByWithAggregationInput = {
    id?: SortOrder;
    content?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: AnnouncementCommentCountOrderByAggregateInput;
    _max?: AnnouncementCommentMaxOrderByAggregateInput;
    _min?: AnnouncementCommentMinOrderByAggregateInput;
  };

  export type AnnouncementCommentScalarWhereWithAggregatesInput = {
    AND?:
      | AnnouncementCommentScalarWhereWithAggregatesInput
      | AnnouncementCommentScalarWhereWithAggregatesInput[];
    OR?: AnnouncementCommentScalarWhereWithAggregatesInput[];
    NOT?:
      | AnnouncementCommentScalarWhereWithAggregatesInput
      | AnnouncementCommentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'AnnouncementComment'> | string;
    content?: StringWithAggregatesFilter<'AnnouncementComment'> | string;
    announcementId?: StringWithAggregatesFilter<'AnnouncementComment'> | string;
    userId?: StringWithAggregatesFilter<'AnnouncementComment'> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'AnnouncementComment'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'AnnouncementComment'>
      | Date
      | string;
  };

  export type ApartmentConfigWhereInput = {
    AND?: ApartmentConfigWhereInput | ApartmentConfigWhereInput[];
    OR?: ApartmentConfigWhereInput[];
    NOT?: ApartmentConfigWhereInput | ApartmentConfigWhereInput[];
    id?: StringFilter<'ApartmentConfig'> | string;
    maxProperties?: IntFilter<'ApartmentConfig'> | number;
    numberOfBlocks?: IntFilter<'ApartmentConfig'> | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionFilter<'ApartmentConfig'>
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntFilter<'ApartmentConfig'> | number;
    unitsPerFloor?: IntFilter<'ApartmentConfig'> | number;
    updatedAt?: DateTimeFilter<'ApartmentConfig'> | Date | string;
  };

  export type ApartmentConfigOrderByWithRelationInput = {
    id?: SortOrder;
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    blockNamingConvention?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApartmentConfigWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ApartmentConfigWhereInput | ApartmentConfigWhereInput[];
      OR?: ApartmentConfigWhereInput[];
      NOT?: ApartmentConfigWhereInput | ApartmentConfigWhereInput[];
      maxProperties?: IntFilter<'ApartmentConfig'> | number;
      numberOfBlocks?: IntFilter<'ApartmentConfig'> | number;
      blockNamingConvention?:
        | EnumBlockNamingConventionFilter<'ApartmentConfig'>
        | $Enums.BlockNamingConvention;
      numberOfFloors?: IntFilter<'ApartmentConfig'> | number;
      unitsPerFloor?: IntFilter<'ApartmentConfig'> | number;
      updatedAt?: DateTimeFilter<'ApartmentConfig'> | Date | string;
    },
    'id'
  >;

  export type ApartmentConfigOrderByWithAggregationInput = {
    id?: SortOrder;
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    blockNamingConvention?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ApartmentConfigCountOrderByAggregateInput;
    _avg?: ApartmentConfigAvgOrderByAggregateInput;
    _max?: ApartmentConfigMaxOrderByAggregateInput;
    _min?: ApartmentConfigMinOrderByAggregateInput;
    _sum?: ApartmentConfigSumOrderByAggregateInput;
  };

  export type ApartmentConfigScalarWhereWithAggregatesInput = {
    AND?:
      | ApartmentConfigScalarWhereWithAggregatesInput
      | ApartmentConfigScalarWhereWithAggregatesInput[];
    OR?: ApartmentConfigScalarWhereWithAggregatesInput[];
    NOT?:
      | ApartmentConfigScalarWhereWithAggregatesInput
      | ApartmentConfigScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'ApartmentConfig'> | string;
    maxProperties?: IntWithAggregatesFilter<'ApartmentConfig'> | number;
    numberOfBlocks?: IntWithAggregatesFilter<'ApartmentConfig'> | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionWithAggregatesFilter<'ApartmentConfig'>
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntWithAggregatesFilter<'ApartmentConfig'> | number;
    unitsPerFloor?: IntWithAggregatesFilter<'ApartmentConfig'> | number;
    updatedAt?: DateTimeWithAggregatesFilter<'ApartmentConfig'> | Date | string;
  };

  export type PollWhereInput = {
    AND?: PollWhereInput | PollWhereInput[];
    OR?: PollWhereInput[];
    NOT?: PollWhereInput | PollWhereInput[];
    id?: StringFilter<'Poll'> | string;
    question?: StringFilter<'Poll'> | string;
    description?: StringNullableFilter<'Poll'> | string | null;
    isAnonymous?: BoolFilter<'Poll'> | boolean;
    isPinned?: BoolFilter<'Poll'> | boolean;
    pinnedAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
    endsAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
    createdAt?: DateTimeFilter<'Poll'> | Date | string;
    updatedAt?: DateTimeFilter<'Poll'> | Date | string;
    createdById?: StringFilter<'Poll'> | string;
    announcementId?: StringNullableFilter<'Poll'> | string | null;
    createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    options?: PollOptionListRelationFilter;
    votes?: PollVoteListRelationFilter;
    announcement?: XOR<
      AnnouncementNullableScalarRelationFilter,
      AnnouncementWhereInput
    > | null;
  };

  export type PollOrderByWithRelationInput = {
    id?: SortOrder;
    question?: SortOrder;
    description?: SortOrder;
    isAnonymous?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    endsAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    announcementId?: SortOrder;
    createdBy?: UserOrderByWithRelationInput;
    options?: PollOptionOrderByRelationAggregateInput;
    votes?: PollVoteOrderByRelationAggregateInput;
    announcement?: AnnouncementOrderByWithRelationInput;
  };

  export type PollWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      announcementId?: string;
      AND?: PollWhereInput | PollWhereInput[];
      OR?: PollWhereInput[];
      NOT?: PollWhereInput | PollWhereInput[];
      question?: StringFilter<'Poll'> | string;
      description?: StringNullableFilter<'Poll'> | string | null;
      isAnonymous?: BoolFilter<'Poll'> | boolean;
      isPinned?: BoolFilter<'Poll'> | boolean;
      pinnedAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
      endsAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
      createdAt?: DateTimeFilter<'Poll'> | Date | string;
      updatedAt?: DateTimeFilter<'Poll'> | Date | string;
      createdById?: StringFilter<'Poll'> | string;
      createdBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
      options?: PollOptionListRelationFilter;
      votes?: PollVoteListRelationFilter;
      announcement?: XOR<
        AnnouncementNullableScalarRelationFilter,
        AnnouncementWhereInput
      > | null;
    },
    'id' | 'announcementId'
  >;

  export type PollOrderByWithAggregationInput = {
    id?: SortOrder;
    question?: SortOrder;
    description?: SortOrder;
    isAnonymous?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    endsAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    announcementId?: SortOrder;
    _count?: PollCountOrderByAggregateInput;
    _max?: PollMaxOrderByAggregateInput;
    _min?: PollMinOrderByAggregateInput;
  };

  export type PollScalarWhereWithAggregatesInput = {
    AND?:
      | PollScalarWhereWithAggregatesInput
      | PollScalarWhereWithAggregatesInput[];
    OR?: PollScalarWhereWithAggregatesInput[];
    NOT?:
      | PollScalarWhereWithAggregatesInput
      | PollScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Poll'> | string;
    question?: StringWithAggregatesFilter<'Poll'> | string;
    description?: StringNullableWithAggregatesFilter<'Poll'> | string | null;
    isAnonymous?: BoolWithAggregatesFilter<'Poll'> | boolean;
    isPinned?: BoolWithAggregatesFilter<'Poll'> | boolean;
    pinnedAt?:
      | DateTimeNullableWithAggregatesFilter<'Poll'>
      | Date
      | string
      | null;
    endsAt?:
      | DateTimeNullableWithAggregatesFilter<'Poll'>
      | Date
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'Poll'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Poll'> | Date | string;
    createdById?: StringWithAggregatesFilter<'Poll'> | string;
    announcementId?: StringNullableWithAggregatesFilter<'Poll'> | string | null;
  };

  export type PollOptionWhereInput = {
    AND?: PollOptionWhereInput | PollOptionWhereInput[];
    OR?: PollOptionWhereInput[];
    NOT?: PollOptionWhereInput | PollOptionWhereInput[];
    id?: StringFilter<'PollOption'> | string;
    text?: StringFilter<'PollOption'> | string;
    pollId?: StringFilter<'PollOption'> | string;
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>;
    votes?: PollVoteListRelationFilter;
  };

  export type PollOptionOrderByWithRelationInput = {
    id?: SortOrder;
    text?: SortOrder;
    pollId?: SortOrder;
    poll?: PollOrderByWithRelationInput;
    votes?: PollVoteOrderByRelationAggregateInput;
  };

  export type PollOptionWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PollOptionWhereInput | PollOptionWhereInput[];
      OR?: PollOptionWhereInput[];
      NOT?: PollOptionWhereInput | PollOptionWhereInput[];
      text?: StringFilter<'PollOption'> | string;
      pollId?: StringFilter<'PollOption'> | string;
      poll?: XOR<PollScalarRelationFilter, PollWhereInput>;
      votes?: PollVoteListRelationFilter;
    },
    'id'
  >;

  export type PollOptionOrderByWithAggregationInput = {
    id?: SortOrder;
    text?: SortOrder;
    pollId?: SortOrder;
    _count?: PollOptionCountOrderByAggregateInput;
    _max?: PollOptionMaxOrderByAggregateInput;
    _min?: PollOptionMinOrderByAggregateInput;
  };

  export type PollOptionScalarWhereWithAggregatesInput = {
    AND?:
      | PollOptionScalarWhereWithAggregatesInput
      | PollOptionScalarWhereWithAggregatesInput[];
    OR?: PollOptionScalarWhereWithAggregatesInput[];
    NOT?:
      | PollOptionScalarWhereWithAggregatesInput
      | PollOptionScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PollOption'> | string;
    text?: StringWithAggregatesFilter<'PollOption'> | string;
    pollId?: StringWithAggregatesFilter<'PollOption'> | string;
  };

  export type PollVoteWhereInput = {
    AND?: PollVoteWhereInput | PollVoteWhereInput[];
    OR?: PollVoteWhereInput[];
    NOT?: PollVoteWhereInput | PollVoteWhereInput[];
    id?: StringFilter<'PollVote'> | string;
    pollId?: StringFilter<'PollVote'> | string;
    optionId?: StringFilter<'PollVote'> | string;
    userId?: StringFilter<'PollVote'> | string;
    createdAt?: DateTimeFilter<'PollVote'> | Date | string;
    poll?: XOR<PollScalarRelationFilter, PollWhereInput>;
    option?: XOR<PollOptionScalarRelationFilter, PollOptionWhereInput>;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type PollVoteOrderByWithRelationInput = {
    id?: SortOrder;
    pollId?: SortOrder;
    optionId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    poll?: PollOrderByWithRelationInput;
    option?: PollOptionOrderByWithRelationInput;
    user?: UserOrderByWithRelationInput;
  };

  export type PollVoteWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      userId_pollId?: PollVoteUserIdPollIdCompoundUniqueInput;
      AND?: PollVoteWhereInput | PollVoteWhereInput[];
      OR?: PollVoteWhereInput[];
      NOT?: PollVoteWhereInput | PollVoteWhereInput[];
      pollId?: StringFilter<'PollVote'> | string;
      optionId?: StringFilter<'PollVote'> | string;
      userId?: StringFilter<'PollVote'> | string;
      createdAt?: DateTimeFilter<'PollVote'> | Date | string;
      poll?: XOR<PollScalarRelationFilter, PollWhereInput>;
      option?: XOR<PollOptionScalarRelationFilter, PollOptionWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id' | 'userId_pollId'
  >;

  export type PollVoteOrderByWithAggregationInput = {
    id?: SortOrder;
    pollId?: SortOrder;
    optionId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    _count?: PollVoteCountOrderByAggregateInput;
    _max?: PollVoteMaxOrderByAggregateInput;
    _min?: PollVoteMinOrderByAggregateInput;
  };

  export type PollVoteScalarWhereWithAggregatesInput = {
    AND?:
      | PollVoteScalarWhereWithAggregatesInput
      | PollVoteScalarWhereWithAggregatesInput[];
    OR?: PollVoteScalarWhereWithAggregatesInput[];
    NOT?:
      | PollVoteScalarWhereWithAggregatesInput
      | PollVoteScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'PollVote'> | string;
    pollId?: StringWithAggregatesFilter<'PollVote'> | string;
    optionId?: StringWithAggregatesFilter<'PollVote'> | string;
    userId?: StringWithAggregatesFilter<'PollVote'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'PollVote'> | Date | string;
  };

  export type FacilityWhereInput = {
    AND?: FacilityWhereInput | FacilityWhereInput[];
    OR?: FacilityWhereInput[];
    NOT?: FacilityWhereInput | FacilityWhereInput[];
    id?: StringFilter<'Facility'> | string;
    name?: StringFilter<'Facility'> | string;
    description?: StringNullableFilter<'Facility'> | string | null;
    capacity?: IntNullableFilter<'Facility'> | number | null;
    hourlyRate?: FloatNullableFilter<'Facility'> | number | null;
    isActive?: BoolFilter<'Facility'> | boolean;
    amenities?: StringNullableListFilter<'Facility'>;
    rules?: StringNullableFilter<'Facility'> | string | null;
    images?: StringNullableListFilter<'Facility'>;
    createdAt?: DateTimeFilter<'Facility'> | Date | string;
    updatedAt?: DateTimeFilter<'Facility'> | Date | string;
    bookings?: FacilityBookingListRelationFilter;
  };

  export type FacilityOrderByWithRelationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
    isActive?: SortOrder;
    amenities?: SortOrder;
    rules?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    bookings?: FacilityBookingOrderByRelationAggregateInput;
  };

  export type FacilityWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FacilityWhereInput | FacilityWhereInput[];
      OR?: FacilityWhereInput[];
      NOT?: FacilityWhereInput | FacilityWhereInput[];
      name?: StringFilter<'Facility'> | string;
      description?: StringNullableFilter<'Facility'> | string | null;
      capacity?: IntNullableFilter<'Facility'> | number | null;
      hourlyRate?: FloatNullableFilter<'Facility'> | number | null;
      isActive?: BoolFilter<'Facility'> | boolean;
      amenities?: StringNullableListFilter<'Facility'>;
      rules?: StringNullableFilter<'Facility'> | string | null;
      images?: StringNullableListFilter<'Facility'>;
      createdAt?: DateTimeFilter<'Facility'> | Date | string;
      updatedAt?: DateTimeFilter<'Facility'> | Date | string;
      bookings?: FacilityBookingListRelationFilter;
    },
    'id'
  >;

  export type FacilityOrderByWithAggregationInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
    isActive?: SortOrder;
    amenities?: SortOrder;
    rules?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FacilityCountOrderByAggregateInput;
    _avg?: FacilityAvgOrderByAggregateInput;
    _max?: FacilityMaxOrderByAggregateInput;
    _min?: FacilityMinOrderByAggregateInput;
    _sum?: FacilitySumOrderByAggregateInput;
  };

  export type FacilityScalarWhereWithAggregatesInput = {
    AND?:
      | FacilityScalarWhereWithAggregatesInput
      | FacilityScalarWhereWithAggregatesInput[];
    OR?: FacilityScalarWhereWithAggregatesInput[];
    NOT?:
      | FacilityScalarWhereWithAggregatesInput
      | FacilityScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Facility'> | string;
    name?: StringWithAggregatesFilter<'Facility'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'Facility'>
      | string
      | null;
    capacity?: IntNullableWithAggregatesFilter<'Facility'> | number | null;
    hourlyRate?: FloatNullableWithAggregatesFilter<'Facility'> | number | null;
    isActive?: BoolWithAggregatesFilter<'Facility'> | boolean;
    amenities?: StringNullableListFilter<'Facility'>;
    rules?: StringNullableWithAggregatesFilter<'Facility'> | string | null;
    images?: StringNullableListFilter<'Facility'>;
    createdAt?: DateTimeWithAggregatesFilter<'Facility'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Facility'> | Date | string;
  };

  export type FacilityBookingWhereInput = {
    AND?: FacilityBookingWhereInput | FacilityBookingWhereInput[];
    OR?: FacilityBookingWhereInput[];
    NOT?: FacilityBookingWhereInput | FacilityBookingWhereInput[];
    id?: StringFilter<'FacilityBooking'> | string;
    userId?: StringFilter<'FacilityBooking'> | string;
    facilityId?: StringFilter<'FacilityBooking'> | string;
    startTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
    endTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
    purpose?: StringNullableFilter<'FacilityBooking'> | string | null;
    status?:
      | EnumFacilityBookingStatusFilter<'FacilityBooking'>
      | $Enums.FacilityBookingStatus;
    totalCost?: FloatNullableFilter<'FacilityBooking'> | number | null;
    notes?: StringNullableFilter<'FacilityBooking'> | string | null;
    createdAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
    updatedAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>;
  };

  export type FacilityBookingOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    facilityId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    purpose?: SortOrder;
    status?: SortOrder;
    totalCost?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
    facility?: FacilityOrderByWithRelationInput;
  };

  export type FacilityBookingWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: FacilityBookingWhereInput | FacilityBookingWhereInput[];
      OR?: FacilityBookingWhereInput[];
      NOT?: FacilityBookingWhereInput | FacilityBookingWhereInput[];
      userId?: StringFilter<'FacilityBooking'> | string;
      facilityId?: StringFilter<'FacilityBooking'> | string;
      startTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
      endTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
      purpose?: StringNullableFilter<'FacilityBooking'> | string | null;
      status?:
        | EnumFacilityBookingStatusFilter<'FacilityBooking'>
        | $Enums.FacilityBookingStatus;
      totalCost?: FloatNullableFilter<'FacilityBooking'> | number | null;
      notes?: StringNullableFilter<'FacilityBooking'> | string | null;
      createdAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
      updatedAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      facility?: XOR<FacilityScalarRelationFilter, FacilityWhereInput>;
    },
    'id'
  >;

  export type FacilityBookingOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    facilityId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    purpose?: SortOrder;
    status?: SortOrder;
    totalCost?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: FacilityBookingCountOrderByAggregateInput;
    _avg?: FacilityBookingAvgOrderByAggregateInput;
    _max?: FacilityBookingMaxOrderByAggregateInput;
    _min?: FacilityBookingMinOrderByAggregateInput;
    _sum?: FacilityBookingSumOrderByAggregateInput;
  };

  export type FacilityBookingScalarWhereWithAggregatesInput = {
    AND?:
      | FacilityBookingScalarWhereWithAggregatesInput
      | FacilityBookingScalarWhereWithAggregatesInput[];
    OR?: FacilityBookingScalarWhereWithAggregatesInput[];
    NOT?:
      | FacilityBookingScalarWhereWithAggregatesInput
      | FacilityBookingScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'FacilityBooking'> | string;
    userId?: StringWithAggregatesFilter<'FacilityBooking'> | string;
    facilityId?: StringWithAggregatesFilter<'FacilityBooking'> | string;
    startTime?: DateTimeWithAggregatesFilter<'FacilityBooking'> | Date | string;
    endTime?: DateTimeWithAggregatesFilter<'FacilityBooking'> | Date | string;
    purpose?:
      | StringNullableWithAggregatesFilter<'FacilityBooking'>
      | string
      | null;
    status?:
      | EnumFacilityBookingStatusWithAggregatesFilter<'FacilityBooking'>
      | $Enums.FacilityBookingStatus;
    totalCost?:
      | FloatNullableWithAggregatesFilter<'FacilityBooking'>
      | number
      | null;
    notes?:
      | StringNullableWithAggregatesFilter<'FacilityBooking'>
      | string
      | null;
    createdAt?: DateTimeWithAggregatesFilter<'FacilityBooking'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'FacilityBooking'> | Date | string;
  };

  export type ComplaintWhereInput = {
    AND?: ComplaintWhereInput | ComplaintWhereInput[];
    OR?: ComplaintWhereInput[];
    NOT?: ComplaintWhereInput | ComplaintWhereInput[];
    id?: StringFilter<'Complaint'> | string;
    title?: StringFilter<'Complaint'> | string;
    description?: StringFilter<'Complaint'> | string;
    type?: EnumComplaintTypeFilter<'Complaint'> | $Enums.ComplaintType;
    status?: EnumComplaintStatusFilter<'Complaint'> | $Enums.ComplaintStatus;
    userId?: StringFilter<'Complaint'> | string;
    resolvedAt?: DateTimeNullableFilter<'Complaint'> | Date | string | null;
    resolvedBy?: StringNullableFilter<'Complaint'> | string | null;
    rating?: IntNullableFilter<'Complaint'> | number | null;
    feedback?: StringNullableFilter<'Complaint'> | string | null;
    images?: StringNullableListFilter<'Complaint'>;
    createdAt?: DateTimeFilter<'Complaint'> | Date | string;
    updatedAt?: DateTimeFilter<'Complaint'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type ComplaintOrderByWithRelationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    resolvedAt?: SortOrder;
    resolvedBy?: SortOrder;
    rating?: SortOrder;
    feedback?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type ComplaintWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: ComplaintWhereInput | ComplaintWhereInput[];
      OR?: ComplaintWhereInput[];
      NOT?: ComplaintWhereInput | ComplaintWhereInput[];
      title?: StringFilter<'Complaint'> | string;
      description?: StringFilter<'Complaint'> | string;
      type?: EnumComplaintTypeFilter<'Complaint'> | $Enums.ComplaintType;
      status?: EnumComplaintStatusFilter<'Complaint'> | $Enums.ComplaintStatus;
      userId?: StringFilter<'Complaint'> | string;
      resolvedAt?: DateTimeNullableFilter<'Complaint'> | Date | string | null;
      resolvedBy?: StringNullableFilter<'Complaint'> | string | null;
      rating?: IntNullableFilter<'Complaint'> | number | null;
      feedback?: StringNullableFilter<'Complaint'> | string | null;
      images?: StringNullableListFilter<'Complaint'>;
      createdAt?: DateTimeFilter<'Complaint'> | Date | string;
      updatedAt?: DateTimeFilter<'Complaint'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type ComplaintOrderByWithAggregationInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    resolvedAt?: SortOrder;
    resolvedBy?: SortOrder;
    rating?: SortOrder;
    feedback?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: ComplaintCountOrderByAggregateInput;
    _avg?: ComplaintAvgOrderByAggregateInput;
    _max?: ComplaintMaxOrderByAggregateInput;
    _min?: ComplaintMinOrderByAggregateInput;
    _sum?: ComplaintSumOrderByAggregateInput;
  };

  export type ComplaintScalarWhereWithAggregatesInput = {
    AND?:
      | ComplaintScalarWhereWithAggregatesInput
      | ComplaintScalarWhereWithAggregatesInput[];
    OR?: ComplaintScalarWhereWithAggregatesInput[];
    NOT?:
      | ComplaintScalarWhereWithAggregatesInput
      | ComplaintScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Complaint'> | string;
    title?: StringWithAggregatesFilter<'Complaint'> | string;
    description?: StringWithAggregatesFilter<'Complaint'> | string;
    type?:
      | EnumComplaintTypeWithAggregatesFilter<'Complaint'>
      | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusWithAggregatesFilter<'Complaint'>
      | $Enums.ComplaintStatus;
    userId?: StringWithAggregatesFilter<'Complaint'> | string;
    resolvedAt?:
      | DateTimeNullableWithAggregatesFilter<'Complaint'>
      | Date
      | string
      | null;
    resolvedBy?:
      | StringNullableWithAggregatesFilter<'Complaint'>
      | string
      | null;
    rating?: IntNullableWithAggregatesFilter<'Complaint'> | number | null;
    feedback?: StringNullableWithAggregatesFilter<'Complaint'> | string | null;
    images?: StringNullableListFilter<'Complaint'>;
    createdAt?: DateTimeWithAggregatesFilter<'Complaint'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Complaint'> | Date | string;
  };

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[];
    OR?: PaymentWhereInput[];
    NOT?: PaymentWhereInput | PaymentWhereInput[];
    id?: StringFilter<'Payment'> | string;
    userId?: StringFilter<'Payment'> | string;
    amount?: FloatFilter<'Payment'> | number;
    type?: EnumPaymentTypeFilter<'Payment'> | $Enums.PaymentType;
    description?: StringFilter<'Payment'> | string;
    status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
    dueDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    paidDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    paymentMethod?:
      | EnumPaymentMethodNullableFilter<'Payment'>
      | $Enums.PaymentMethod
      | null;
    transactionId?: StringNullableFilter<'Payment'> | string | null;
    razorpayOrderId?: StringNullableFilter<'Payment'> | string | null;
    razorpayPaymentId?: StringNullableFilter<'Payment'> | string | null;
    receiptUrl?: StringNullableFilter<'Payment'> | string | null;
    createdAt?: DateTimeFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeFilter<'Payment'> | Date | string;
    user?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidDate?: SortOrder;
    paymentMethod?: SortOrder;
    transactionId?: SortOrder;
    razorpayOrderId?: SortOrder;
    razorpayPaymentId?: SortOrder;
    receiptUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    user?: UserOrderByWithRelationInput;
  };

  export type PaymentWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: PaymentWhereInput | PaymentWhereInput[];
      OR?: PaymentWhereInput[];
      NOT?: PaymentWhereInput | PaymentWhereInput[];
      userId?: StringFilter<'Payment'> | string;
      amount?: FloatFilter<'Payment'> | number;
      type?: EnumPaymentTypeFilter<'Payment'> | $Enums.PaymentType;
      description?: StringFilter<'Payment'> | string;
      status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
      dueDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
      paidDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
      paymentMethod?:
        | EnumPaymentMethodNullableFilter<'Payment'>
        | $Enums.PaymentMethod
        | null;
      transactionId?: StringNullableFilter<'Payment'> | string | null;
      razorpayOrderId?: StringNullableFilter<'Payment'> | string | null;
      razorpayPaymentId?: StringNullableFilter<'Payment'> | string | null;
      receiptUrl?: StringNullableFilter<'Payment'> | string | null;
      createdAt?: DateTimeFilter<'Payment'> | Date | string;
      updatedAt?: DateTimeFilter<'Payment'> | Date | string;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidDate?: SortOrder;
    paymentMethod?: SortOrder;
    transactionId?: SortOrder;
    razorpayOrderId?: SortOrder;
    razorpayPaymentId?: SortOrder;
    receiptUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: PaymentCountOrderByAggregateInput;
    _avg?: PaymentAvgOrderByAggregateInput;
    _max?: PaymentMaxOrderByAggregateInput;
    _min?: PaymentMinOrderByAggregateInput;
    _sum?: PaymentSumOrderByAggregateInput;
  };

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    OR?: PaymentScalarWhereWithAggregatesInput[];
    NOT?:
      | PaymentScalarWhereWithAggregatesInput
      | PaymentScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Payment'> | string;
    userId?: StringWithAggregatesFilter<'Payment'> | string;
    amount?: FloatWithAggregatesFilter<'Payment'> | number;
    type?: EnumPaymentTypeWithAggregatesFilter<'Payment'> | $Enums.PaymentType;
    description?: StringWithAggregatesFilter<'Payment'> | string;
    status?:
      | EnumPaymentStatusWithAggregatesFilter<'Payment'>
      | $Enums.PaymentStatus;
    dueDate?:
      | DateTimeNullableWithAggregatesFilter<'Payment'>
      | Date
      | string
      | null;
    paidDate?:
      | DateTimeNullableWithAggregatesFilter<'Payment'>
      | Date
      | string
      | null;
    paymentMethod?:
      | EnumPaymentMethodNullableWithAggregatesFilter<'Payment'>
      | $Enums.PaymentMethod
      | null;
    transactionId?:
      | StringNullableWithAggregatesFilter<'Payment'>
      | string
      | null;
    razorpayOrderId?:
      | StringNullableWithAggregatesFilter<'Payment'>
      | string
      | null;
    razorpayPaymentId?:
      | StringNullableWithAggregatesFilter<'Payment'>
      | string
      | null;
    receiptUrl?: StringNullableWithAggregatesFilter<'Payment'> | string | null;
    createdAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Payment'> | Date | string;
  };

  export type CommunityFinanceWhereInput = {
    AND?: CommunityFinanceWhereInput | CommunityFinanceWhereInput[];
    OR?: CommunityFinanceWhereInput[];
    NOT?: CommunityFinanceWhereInput | CommunityFinanceWhereInput[];
    id?: StringFilter<'CommunityFinance'> | string;
    amount?: FloatFilter<'CommunityFinance'> | number;
    type?: StringFilter<'CommunityFinance'> | string;
    category?: StringFilter<'CommunityFinance'> | string;
    description?: StringNullableFilter<'CommunityFinance'> | string | null;
    date?: DateTimeFilter<'CommunityFinance'> | Date | string;
    recordedById?: StringFilter<'CommunityFinance'> | string;
    createdAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
    updatedAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
    recordedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type CommunityFinanceOrderByWithRelationInput = {
    id?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    recordedById?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    recordedBy?: UserOrderByWithRelationInput;
  };

  export type CommunityFinanceWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: CommunityFinanceWhereInput | CommunityFinanceWhereInput[];
      OR?: CommunityFinanceWhereInput[];
      NOT?: CommunityFinanceWhereInput | CommunityFinanceWhereInput[];
      amount?: FloatFilter<'CommunityFinance'> | number;
      type?: StringFilter<'CommunityFinance'> | string;
      category?: StringFilter<'CommunityFinance'> | string;
      description?: StringNullableFilter<'CommunityFinance'> | string | null;
      date?: DateTimeFilter<'CommunityFinance'> | Date | string;
      recordedById?: StringFilter<'CommunityFinance'> | string;
      createdAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
      updatedAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
      recordedBy?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type CommunityFinanceOrderByWithAggregationInput = {
    id?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    recordedById?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: CommunityFinanceCountOrderByAggregateInput;
    _avg?: CommunityFinanceAvgOrderByAggregateInput;
    _max?: CommunityFinanceMaxOrderByAggregateInput;
    _min?: CommunityFinanceMinOrderByAggregateInput;
    _sum?: CommunityFinanceSumOrderByAggregateInput;
  };

  export type CommunityFinanceScalarWhereWithAggregatesInput = {
    AND?:
      | CommunityFinanceScalarWhereWithAggregatesInput
      | CommunityFinanceScalarWhereWithAggregatesInput[];
    OR?: CommunityFinanceScalarWhereWithAggregatesInput[];
    NOT?:
      | CommunityFinanceScalarWhereWithAggregatesInput
      | CommunityFinanceScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'CommunityFinance'> | string;
    amount?: FloatWithAggregatesFilter<'CommunityFinance'> | number;
    type?: StringWithAggregatesFilter<'CommunityFinance'> | string;
    category?: StringWithAggregatesFilter<'CommunityFinance'> | string;
    description?:
      | StringNullableWithAggregatesFilter<'CommunityFinance'>
      | string
      | null;
    date?: DateTimeWithAggregatesFilter<'CommunityFinance'> | Date | string;
    recordedById?: StringWithAggregatesFilter<'CommunityFinance'> | string;
    createdAt?:
      | DateTimeWithAggregatesFilter<'CommunityFinance'>
      | Date
      | string;
    updatedAt?:
      | DateTimeWithAggregatesFilter<'CommunityFinance'>
      | Date
      | string;
  };

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[];
    OR?: MessageWhereInput[];
    NOT?: MessageWhereInput | MessageWhereInput[];
    id?: StringFilter<'Message'> | string;
    content?: StringFilter<'Message'> | string;
    senderId?: StringFilter<'Message'> | string;
    createdAt?: DateTimeFilter<'Message'> | Date | string;
    updatedAt?: DateTimeFilter<'Message'> | Date | string;
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>;
  };

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder;
    content?: SortOrder;
    senderId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    sender?: UserOrderByWithRelationInput;
  };

  export type MessageWhereUniqueInput = Prisma.AtLeast<
    {
      id?: string;
      AND?: MessageWhereInput | MessageWhereInput[];
      OR?: MessageWhereInput[];
      NOT?: MessageWhereInput | MessageWhereInput[];
      content?: StringFilter<'Message'> | string;
      senderId?: StringFilter<'Message'> | string;
      createdAt?: DateTimeFilter<'Message'> | Date | string;
      updatedAt?: DateTimeFilter<'Message'> | Date | string;
      sender?: XOR<UserScalarRelationFilter, UserWhereInput>;
    },
    'id'
  >;

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder;
    content?: SortOrder;
    senderId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    _count?: MessageCountOrderByAggregateInput;
    _max?: MessageMaxOrderByAggregateInput;
    _min?: MessageMinOrderByAggregateInput;
  };

  export type MessageScalarWhereWithAggregatesInput = {
    AND?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    OR?: MessageScalarWhereWithAggregatesInput[];
    NOT?:
      | MessageScalarWhereWithAggregatesInput
      | MessageScalarWhereWithAggregatesInput[];
    id?: StringWithAggregatesFilter<'Message'> | string;
    content?: StringWithAggregatesFilter<'Message'> | string;
    senderId?: StringWithAggregatesFilter<'Message'> | string;
    createdAt?: DateTimeWithAggregatesFilter<'Message'> | Date | string;
    updatedAt?: DateTimeWithAggregatesFilter<'Message'> | Date | string;
  };

  export type UserCreateInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateManyInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
  };

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type RefreshTokenCreateInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutRefreshTokensInput;
  };

  export type RefreshTokenUncheckedCreateInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RefreshTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutRefreshTokensNestedInput;
  };

  export type RefreshTokenUncheckedUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenCreateManyInput = {
    id?: string;
    token: string;
    userId: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RefreshTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateManyInput = {
    token?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionCreateInput = {
    id?: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutPushSubscriptionsInput;
  };

  export type PushSubscriptionUncheckedCreateInput = {
    id?: string;
    userId: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionUpdateInput = {
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput;
  };

  export type PushSubscriptionUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionCreateManyInput = {
    id?: string;
    userId: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionUpdateManyMutationInput = {
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutNotificationsInput;
  };

  export type NotificationUncheckedCreateInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput;
  };

  export type NotificationUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationCreateManyInput = {
    id?: string;
    userId: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PropertyCreateInput = {
    id?: string;
    block: string;
    floor: string;
    flatNumber: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user?: UserCreateNestedOneWithoutPropertyInput;
  };

  export type PropertyUncheckedCreateInput = {
    id?: string;
    block: string;
    floor: string;
    flatNumber: string;
    userId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PropertyUpdateInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneWithoutPropertyNestedInput;
  };

  export type PropertyUncheckedUpdateInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PropertyCreateManyInput = {
    id?: string;
    block: string;
    floor: string;
    flatNumber: string;
    userId?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PropertyUpdateManyMutationInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PropertyUncheckedUpdateManyInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    userId?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCreateInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutAnnouncementsInput;
    likes?: AnnouncementLikeCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentCreateNestedManyWithoutAnnouncementInput;
    poll?: PollCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementUncheckedCreateInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    authorId: string;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    likes?: AnnouncementLikeUncheckedCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentUncheckedCreateNestedManyWithoutAnnouncementInput;
    poll?: PollUncheckedCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput;
    likes?: AnnouncementLikeUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: StringFieldUpdateOperationsInput | string;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUncheckedUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementCreateManyInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    authorId: string;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: StringFieldUpdateOperationsInput | string;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeCreateInput = {
    id?: string;
    createdAt?: Date | string;
    announcement: AnnouncementCreateNestedOneWithoutLikesInput;
    user: UserCreateNestedOneWithoutAnnouncementLikesInput;
  };

  export type AnnouncementLikeUncheckedCreateInput = {
    id?: string;
    announcementId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementLikeUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcement?: AnnouncementUpdateOneRequiredWithoutLikesNestedInput;
    user?: UserUpdateOneRequiredWithoutAnnouncementLikesNestedInput;
  };

  export type AnnouncementLikeUncheckedUpdateInput = {
    announcementId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeCreateManyInput = {
    id?: string;
    announcementId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementLikeUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeUncheckedUpdateManyInput = {
    announcementId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentCreateInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    announcement: AnnouncementCreateNestedOneWithoutCommentsInput;
    user: UserCreateNestedOneWithoutAnnouncementCommentsInput;
  };

  export type AnnouncementCommentUncheckedCreateInput = {
    id?: string;
    content: string;
    announcementId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCommentUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcement?: AnnouncementUpdateOneRequiredWithoutCommentsNestedInput;
    user?: UserUpdateOneRequiredWithoutAnnouncementCommentsNestedInput;
  };

  export type AnnouncementCommentUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string;
    announcementId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentCreateManyInput = {
    id?: string;
    content: string;
    announcementId: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCommentUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string;
    announcementId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApartmentConfigCreateInput = {
    id?: string;
    maxProperties?: number;
    numberOfBlocks?: number;
    blockNamingConvention?: $Enums.BlockNamingConvention;
    numberOfFloors?: number;
    unitsPerFloor?: number;
    updatedAt?: Date | string;
  };

  export type ApartmentConfigUncheckedCreateInput = {
    id?: string;
    maxProperties?: number;
    numberOfBlocks?: number;
    blockNamingConvention?: $Enums.BlockNamingConvention;
    numberOfFloors?: number;
    unitsPerFloor?: number;
    updatedAt?: Date | string;
  };

  export type ApartmentConfigUpdateInput = {
    maxProperties?: IntFieldUpdateOperationsInput | number;
    numberOfBlocks?: IntFieldUpdateOperationsInput | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionFieldUpdateOperationsInput
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntFieldUpdateOperationsInput | number;
    unitsPerFloor?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApartmentConfigUncheckedUpdateInput = {
    maxProperties?: IntFieldUpdateOperationsInput | number;
    numberOfBlocks?: IntFieldUpdateOperationsInput | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionFieldUpdateOperationsInput
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntFieldUpdateOperationsInput | number;
    unitsPerFloor?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApartmentConfigCreateManyInput = {
    id?: string;
    maxProperties?: number;
    numberOfBlocks?: number;
    blockNamingConvention?: $Enums.BlockNamingConvention;
    numberOfFloors?: number;
    unitsPerFloor?: number;
    updatedAt?: Date | string;
  };

  export type ApartmentConfigUpdateManyMutationInput = {
    maxProperties?: IntFieldUpdateOperationsInput | number;
    numberOfBlocks?: IntFieldUpdateOperationsInput | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionFieldUpdateOperationsInput
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntFieldUpdateOperationsInput | number;
    unitsPerFloor?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ApartmentConfigUncheckedUpdateManyInput = {
    maxProperties?: IntFieldUpdateOperationsInput | number;
    numberOfBlocks?: IntFieldUpdateOperationsInput | number;
    blockNamingConvention?:
      | EnumBlockNamingConventionFieldUpdateOperationsInput
      | $Enums.BlockNamingConvention;
    numberOfFloors?: IntFieldUpdateOperationsInput | number;
    unitsPerFloor?: IntFieldUpdateOperationsInput | number;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollCreateInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedPollsInput;
    options?: PollOptionCreateNestedManyWithoutPollInput;
    votes?: PollVoteCreateNestedManyWithoutPollInput;
    announcement?: AnnouncementCreateNestedOneWithoutPollInput;
  };

  export type PollUncheckedCreateInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    announcementId?: string | null;
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput;
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput;
  };

  export type PollUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput;
    options?: PollOptionUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUpdateManyWithoutPollNestedInput;
    announcement?: AnnouncementUpdateOneWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput;
  };

  export type PollCreateManyInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    announcementId?: string | null;
  };

  export type PollUpdateManyMutationInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollUncheckedUpdateManyInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PollOptionCreateInput = {
    id?: string;
    text: string;
    poll: PollCreateNestedOneWithoutOptionsInput;
    votes?: PollVoteCreateNestedManyWithoutOptionInput;
  };

  export type PollOptionUncheckedCreateInput = {
    id?: string;
    text: string;
    pollId: string;
    votes?: PollVoteUncheckedCreateNestedManyWithoutOptionInput;
  };

  export type PollOptionUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string;
    poll?: PollUpdateOneRequiredWithoutOptionsNestedInput;
    votes?: PollVoteUpdateManyWithoutOptionNestedInput;
  };

  export type PollOptionUncheckedUpdateInput = {
    text?: StringFieldUpdateOperationsInput | string;
    pollId?: StringFieldUpdateOperationsInput | string;
    votes?: PollVoteUncheckedUpdateManyWithoutOptionNestedInput;
  };

  export type PollOptionCreateManyInput = {
    id?: string;
    text: string;
    pollId: string;
  };

  export type PollOptionUpdateManyMutationInput = {
    text?: StringFieldUpdateOperationsInput | string;
  };

  export type PollOptionUncheckedUpdateManyInput = {
    text?: StringFieldUpdateOperationsInput | string;
    pollId?: StringFieldUpdateOperationsInput | string;
  };

  export type PollVoteCreateInput = {
    id?: string;
    createdAt?: Date | string;
    poll: PollCreateNestedOneWithoutVotesInput;
    option: PollOptionCreateNestedOneWithoutVotesInput;
    user: UserCreateNestedOneWithoutPollVotesInput;
  };

  export type PollVoteUncheckedCreateInput = {
    id?: string;
    pollId: string;
    optionId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollVoteUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    poll?: PollUpdateOneRequiredWithoutVotesNestedInput;
    option?: PollOptionUpdateOneRequiredWithoutVotesNestedInput;
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput;
  };

  export type PollVoteUncheckedUpdateInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    optionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteCreateManyInput = {
    id?: string;
    pollId: string;
    optionId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollVoteUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteUncheckedUpdateManyInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    optionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    capacity?: number | null;
    hourlyRate?: number | null;
    isActive?: boolean;
    amenities?: FacilityCreateamenitiesInput | string[];
    rules?: string | null;
    images?: FacilityCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    bookings?: FacilityBookingCreateNestedManyWithoutFacilityInput;
  };

  export type FacilityUncheckedCreateInput = {
    id?: string;
    name: string;
    description?: string | null;
    capacity?: number | null;
    hourlyRate?: number | null;
    isActive?: boolean;
    amenities?: FacilityCreateamenitiesInput | string[];
    rules?: string | null;
    images?: FacilityCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    bookings?: FacilityBookingUncheckedCreateNestedManyWithoutFacilityInput;
  };

  export type FacilityUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    bookings?: FacilityBookingUpdateManyWithoutFacilityNestedInput;
  };

  export type FacilityUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    bookings?: FacilityBookingUncheckedUpdateManyWithoutFacilityNestedInput;
  };

  export type FacilityCreateManyInput = {
    id?: string;
    name: string;
    description?: string | null;
    capacity?: number | null;
    hourlyRate?: number | null;
    isActive?: boolean;
    amenities?: FacilityCreateamenitiesInput | string[];
    rules?: string | null;
    images?: FacilityCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingCreateInput = {
    id?: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutFacilityBookingsInput;
    facility: FacilityCreateNestedOneWithoutBookingsInput;
  };

  export type FacilityBookingUncheckedCreateInput = {
    id?: string;
    userId: string;
    facilityId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityBookingUpdateInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutFacilityBookingsNestedInput;
    facility?: FacilityUpdateOneRequiredWithoutBookingsNestedInput;
  };

  export type FacilityBookingUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    facilityId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingCreateManyInput = {
    id?: string;
    userId: string;
    facilityId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityBookingUpdateManyMutationInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    facilityId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintCreateInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutComplaintsInput;
  };

  export type ComplaintUncheckedCreateInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    userId: string;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComplaintUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutComplaintsNestedInput;
  };

  export type ComplaintUncheckedUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    userId?: StringFieldUpdateOperationsInput | string;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintCreateManyInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    userId: string;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComplaintUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintUncheckedUpdateManyInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    userId?: StringFieldUpdateOperationsInput | string;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentCreateInput = {
    id?: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutPaymentsInput;
  };

  export type PaymentUncheckedCreateInput = {
    id?: string;
    userId: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutPaymentsNestedInput;
  };

  export type PaymentUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentCreateManyInput = {
    id?: string;
    userId: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceCreateInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    recordedBy: UserCreateNestedOneWithoutRecordedFinancesInput;
  };

  export type CommunityFinanceUncheckedCreateInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    recordedById: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommunityFinanceUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    recordedBy?: UserUpdateOneRequiredWithoutRecordedFinancesNestedInput;
  };

  export type CommunityFinanceUncheckedUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    recordedById?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceCreateManyInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    recordedById: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommunityFinanceUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceUncheckedUpdateManyInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    recordedById?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageCreateInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    sender: UserCreateNestedOneWithoutMessagesInput;
  };

  export type MessageUncheckedCreateInput = {
    id?: string;
    content: string;
    senderId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MessageUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput;
  };

  export type MessageUncheckedUpdateInput = {
    content?: StringFieldUpdateOperationsInput | string;
    senderId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageCreateManyInput = {
    id?: string;
    content: string;
    senderId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MessageUpdateManyMutationInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageUncheckedUpdateManyInput = {
    content?: StringFieldUpdateOperationsInput | string;
    senderId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type EnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus;
  };

  export type EnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider;
  };

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput;
    some?: RefreshTokenWhereInput;
    none?: RefreshTokenWhereInput;
  };

  export type PushSubscriptionListRelationFilter = {
    every?: PushSubscriptionWhereInput;
    some?: PushSubscriptionWhereInput;
    none?: PushSubscriptionWhereInput;
  };

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput;
    some?: NotificationWhereInput;
    none?: NotificationWhereInput;
  };

  export type PropertyNullableScalarRelationFilter = {
    is?: PropertyWhereInput | null;
    isNot?: PropertyWhereInput | null;
  };

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null;
    isNot?: UserWhereInput | null;
  };

  export type UserListRelationFilter = {
    every?: UserWhereInput;
    some?: UserWhereInput;
    none?: UserWhereInput;
  };

  export type AnnouncementListRelationFilter = {
    every?: AnnouncementWhereInput;
    some?: AnnouncementWhereInput;
    none?: AnnouncementWhereInput;
  };

  export type AnnouncementLikeListRelationFilter = {
    every?: AnnouncementLikeWhereInput;
    some?: AnnouncementLikeWhereInput;
    none?: AnnouncementLikeWhereInput;
  };

  export type AnnouncementCommentListRelationFilter = {
    every?: AnnouncementCommentWhereInput;
    some?: AnnouncementCommentWhereInput;
    none?: AnnouncementCommentWhereInput;
  };

  export type PollListRelationFilter = {
    every?: PollWhereInput;
    some?: PollWhereInput;
    none?: PollWhereInput;
  };

  export type PollVoteListRelationFilter = {
    every?: PollVoteWhereInput;
    some?: PollVoteWhereInput;
    none?: PollVoteWhereInput;
  };

  export type FacilityBookingListRelationFilter = {
    every?: FacilityBookingWhereInput;
    some?: FacilityBookingWhereInput;
    none?: FacilityBookingWhereInput;
  };

  export type ComplaintListRelationFilter = {
    every?: ComplaintWhereInput;
    some?: ComplaintWhereInput;
    none?: ComplaintWhereInput;
  };

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput;
    some?: PaymentWhereInput;
    none?: PaymentWhereInput;
  };

  export type CommunityFinanceListRelationFilter = {
    every?: CommunityFinanceWhereInput;
    some?: CommunityFinanceWhereInput;
    none?: CommunityFinanceWhereInput;
  };

  export type MessageListRelationFilter = {
    every?: MessageWhereInput;
    some?: MessageWhereInput;
    none?: MessageWhereInput;
  };

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PushSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnnouncementOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnnouncementLikeOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type AnnouncementCommentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PollOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PollVoteOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type FacilityBookingOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type ComplaintOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type CommunityFinanceOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    name?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    status?: SortOrder;
    rejectionReason?: SortOrder;
    provider?: SortOrder;
    image?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedById?: SortOrder;
    notificationsEnabled?: SortOrder;
  };

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    name?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    status?: SortOrder;
    rejectionReason?: SortOrder;
    provider?: SortOrder;
    image?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedById?: SortOrder;
    notificationsEnabled?: SortOrder;
  };

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder;
    email?: SortOrder;
    phone?: SortOrder;
    name?: SortOrder;
    password?: SortOrder;
    role?: SortOrder;
    status?: SortOrder;
    rejectionReason?: SortOrder;
    provider?: SortOrder;
    image?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    approvedById?: SortOrder;
    notificationsEnabled?: SortOrder;
  };

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    mode?: QueryMode;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.UserStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserStatusFilter<$PrismaModel>;
    _max?: NestedEnumUserStatusFilter<$PrismaModel>;
  };

  export type EnumAuthProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel>
      | $Enums.AuthProvider;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumAuthProviderFilter<$PrismaModel>;
    _max?: NestedEnumAuthProviderFilter<$PrismaModel>;
  };

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type UserScalarRelationFilter = {
    is?: UserWhereInput;
    isNot?: UserWhereInput;
  };

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    revoked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    revoked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder;
    token?: SortOrder;
    userId?: SortOrder;
    expiresAt?: SortOrder;
    revoked?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PushSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    endpoint?: SortOrder;
    p256dh?: SortOrder;
    auth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PushSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    endpoint?: SortOrder;
    p256dh?: SortOrder;
    auth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PushSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    endpoint?: SortOrder;
    p256dh?: SortOrder;
    auth?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    read?: SortOrder;
    link?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    read?: SortOrder;
    link?: SortOrder;
    createdAt?: SortOrder;
  };

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    title?: SortOrder;
    message?: SortOrder;
    type?: SortOrder;
    read?: SortOrder;
    link?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder;
    block?: SortOrder;
    floor?: SortOrder;
    flatNumber?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder;
    block?: SortOrder;
    floor?: SortOrder;
    flatNumber?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder;
    block?: SortOrder;
    floor?: SortOrder;
    flatNumber?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type PollNullableScalarRelationFilter = {
    is?: PollWhereInput | null;
    isNot?: PollWhereInput | null;
  };

  export type AnnouncementCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    imageUrl?: SortOrder;
    authorId?: SortOrder;
    commentsEnabled?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    imageUrl?: SortOrder;
    authorId?: SortOrder;
    commentsEnabled?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    content?: SortOrder;
    imageUrl?: SortOrder;
    authorId?: SortOrder;
    commentsEnabled?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    expiresAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?:
      | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
      | Date
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedDateTimeNullableFilter<$PrismaModel>;
    _max?: NestedDateTimeNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type AnnouncementScalarRelationFilter = {
    is?: AnnouncementWhereInput;
    isNot?: AnnouncementWhereInput;
  };

  export type AnnouncementLikeAnnouncementIdUserIdCompoundUniqueInput = {
    announcementId: string;
    userId: string;
  };

  export type AnnouncementLikeCountOrderByAggregateInput = {
    id?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AnnouncementLikeMaxOrderByAggregateInput = {
    id?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AnnouncementLikeMinOrderByAggregateInput = {
    id?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type AnnouncementCommentCountOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementCommentMaxOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type AnnouncementCommentMinOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    announcementId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type EnumBlockNamingConventionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.BlockNamingConvention
      | EnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBlockNamingConventionFilter<$PrismaModel>
      | $Enums.BlockNamingConvention;
  };

  export type ApartmentConfigCountOrderByAggregateInput = {
    id?: SortOrder;
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    blockNamingConvention?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApartmentConfigAvgOrderByAggregateInput = {
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
  };

  export type ApartmentConfigMaxOrderByAggregateInput = {
    id?: SortOrder;
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    blockNamingConvention?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApartmentConfigMinOrderByAggregateInput = {
    id?: SortOrder;
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    blockNamingConvention?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ApartmentConfigSumOrderByAggregateInput = {
    maxProperties?: SortOrder;
    numberOfBlocks?: SortOrder;
    numberOfFloors?: SortOrder;
    unitsPerFloor?: SortOrder;
  };

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type EnumBlockNamingConventionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.BlockNamingConvention
      | EnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBlockNamingConventionWithAggregatesFilter<$PrismaModel>
      | $Enums.BlockNamingConvention;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBlockNamingConventionFilter<$PrismaModel>;
    _max?: NestedEnumBlockNamingConventionFilter<$PrismaModel>;
  };

  export type PollOptionListRelationFilter = {
    every?: PollOptionWhereInput;
    some?: PollOptionWhereInput;
    none?: PollOptionWhereInput;
  };

  export type AnnouncementNullableScalarRelationFilter = {
    is?: AnnouncementWhereInput | null;
    isNot?: AnnouncementWhereInput | null;
  };

  export type PollOptionOrderByRelationAggregateInput = {
    _count?: SortOrder;
  };

  export type PollCountOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    description?: SortOrder;
    isAnonymous?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    endsAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    announcementId?: SortOrder;
  };

  export type PollMaxOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    description?: SortOrder;
    isAnonymous?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    endsAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    announcementId?: SortOrder;
  };

  export type PollMinOrderByAggregateInput = {
    id?: SortOrder;
    question?: SortOrder;
    description?: SortOrder;
    isAnonymous?: SortOrder;
    isPinned?: SortOrder;
    pinnedAt?: SortOrder;
    endsAt?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
    createdById?: SortOrder;
    announcementId?: SortOrder;
  };

  export type PollScalarRelationFilter = {
    is?: PollWhereInput;
    isNot?: PollWhereInput;
  };

  export type PollOptionCountOrderByAggregateInput = {
    id?: SortOrder;
    text?: SortOrder;
    pollId?: SortOrder;
  };

  export type PollOptionMaxOrderByAggregateInput = {
    id?: SortOrder;
    text?: SortOrder;
    pollId?: SortOrder;
  };

  export type PollOptionMinOrderByAggregateInput = {
    id?: SortOrder;
    text?: SortOrder;
    pollId?: SortOrder;
  };

  export type PollOptionScalarRelationFilter = {
    is?: PollOptionWhereInput;
    isNot?: PollOptionWhereInput;
  };

  export type PollVoteUserIdPollIdCompoundUniqueInput = {
    userId: string;
    pollId: string;
  };

  export type PollVoteCountOrderByAggregateInput = {
    id?: SortOrder;
    pollId?: SortOrder;
    optionId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PollVoteMaxOrderByAggregateInput = {
    id?: SortOrder;
    pollId?: SortOrder;
    optionId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type PollVoteMinOrderByAggregateInput = {
    id?: SortOrder;
    pollId?: SortOrder;
    optionId?: SortOrder;
    userId?: SortOrder;
    createdAt?: SortOrder;
  };

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    has?: string | StringFieldRefInput<$PrismaModel> | null;
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>;
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>;
    isEmpty?: boolean;
  };

  export type FacilityCountOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
    isActive?: SortOrder;
    amenities?: SortOrder;
    rules?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilityAvgOrderByAggregateInput = {
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
  };

  export type FacilityMaxOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
    isActive?: SortOrder;
    rules?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilityMinOrderByAggregateInput = {
    id?: SortOrder;
    name?: SortOrder;
    description?: SortOrder;
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
    isActive?: SortOrder;
    rules?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilitySumOrderByAggregateInput = {
    capacity?: SortOrder;
    hourlyRate?: SortOrder;
  };

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type EnumFacilityBookingStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.FacilityBookingStatus
      | EnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFacilityBookingStatusFilter<$PrismaModel>
      | $Enums.FacilityBookingStatus;
  };

  export type FacilityScalarRelationFilter = {
    is?: FacilityWhereInput;
    isNot?: FacilityWhereInput;
  };

  export type FacilityBookingCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    facilityId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    purpose?: SortOrder;
    status?: SortOrder;
    totalCost?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilityBookingAvgOrderByAggregateInput = {
    totalCost?: SortOrder;
  };

  export type FacilityBookingMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    facilityId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    purpose?: SortOrder;
    status?: SortOrder;
    totalCost?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilityBookingMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    facilityId?: SortOrder;
    startTime?: SortOrder;
    endTime?: SortOrder;
    purpose?: SortOrder;
    status?: SortOrder;
    totalCost?: SortOrder;
    notes?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type FacilityBookingSumOrderByAggregateInput = {
    totalCost?: SortOrder;
  };

  export type EnumFacilityBookingStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.FacilityBookingStatus
      | EnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFacilityBookingStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FacilityBookingStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFacilityBookingStatusFilter<$PrismaModel>;
    _max?: NestedEnumFacilityBookingStatusFilter<$PrismaModel>;
  };

  export type EnumComplaintTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintType
      | EnumComplaintTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumComplaintTypeFilter<$PrismaModel> | $Enums.ComplaintType;
  };

  export type EnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintStatus
      | EnumComplaintStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintStatusFilter<$PrismaModel>
      | $Enums.ComplaintStatus;
  };

  export type ComplaintCountOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    resolvedAt?: SortOrder;
    resolvedBy?: SortOrder;
    rating?: SortOrder;
    feedback?: SortOrder;
    images?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ComplaintAvgOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type ComplaintMaxOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    resolvedAt?: SortOrder;
    resolvedBy?: SortOrder;
    rating?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ComplaintMinOrderByAggregateInput = {
    id?: SortOrder;
    title?: SortOrder;
    description?: SortOrder;
    type?: SortOrder;
    status?: SortOrder;
    userId?: SortOrder;
    resolvedAt?: SortOrder;
    resolvedBy?: SortOrder;
    rating?: SortOrder;
    feedback?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type ComplaintSumOrderByAggregateInput = {
    rating?: SortOrder;
  };

  export type EnumComplaintTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintType
      | EnumComplaintTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ComplaintType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumComplaintTypeFilter<$PrismaModel>;
    _max?: NestedEnumComplaintTypeFilter<$PrismaModel>;
  };

  export type EnumComplaintStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintStatus
      | EnumComplaintStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ComplaintStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>;
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>;
  };

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentType[]
      | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType;
  };

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type EnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentMethod
      | EnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumPaymentMethodNullableFilter<$PrismaModel>
      | $Enums.PaymentMethod
      | null;
    isSet?: boolean;
  };

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidDate?: SortOrder;
    paymentMethod?: SortOrder;
    transactionId?: SortOrder;
    razorpayOrderId?: SortOrder;
    razorpayPaymentId?: SortOrder;
    receiptUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidDate?: SortOrder;
    paymentMethod?: SortOrder;
    transactionId?: SortOrder;
    razorpayOrderId?: SortOrder;
    razorpayPaymentId?: SortOrder;
    receiptUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder;
    userId?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    description?: SortOrder;
    status?: SortOrder;
    dueDate?: SortOrder;
    paidDate?: SortOrder;
    paymentMethod?: SortOrder;
    transactionId?: SortOrder;
    razorpayOrderId?: SortOrder;
    razorpayPaymentId?: SortOrder;
    receiptUrl?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentType[]
      | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>;
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>;
  };

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type EnumPaymentMethodNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PaymentMethod
      | EnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentMethod
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>;
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type CommunityFinanceCountOrderByAggregateInput = {
    id?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    recordedById?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommunityFinanceAvgOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type CommunityFinanceMaxOrderByAggregateInput = {
    id?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    recordedById?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommunityFinanceMinOrderByAggregateInput = {
    id?: SortOrder;
    amount?: SortOrder;
    type?: SortOrder;
    category?: SortOrder;
    description?: SortOrder;
    date?: SortOrder;
    recordedById?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type CommunityFinanceSumOrderByAggregateInput = {
    amount?: SortOrder;
  };

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    senderId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    senderId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder;
    content?: SortOrder;
    senderId?: SortOrder;
    createdAt?: SortOrder;
    updatedAt?: SortOrder;
  };

  export type RefreshTokenCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
  };

  export type PushSubscriptionCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
  };

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type PropertyCreateNestedOneWithoutUserInput = {
    create?: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput;
    connect?: PropertyWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutApprovalsInput = {
    create?: XOR<
      UserCreateWithoutApprovalsInput,
      UserUncheckedCreateWithoutApprovalsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserCreateNestedManyWithoutApprovedByInput = {
    create?:
      | XOR<
          UserCreateWithoutApprovedByInput,
          UserUncheckedCreateWithoutApprovedByInput
        >
      | UserCreateWithoutApprovedByInput[]
      | UserUncheckedCreateWithoutApprovedByInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutApprovedByInput
      | UserCreateOrConnectWithoutApprovedByInput[];
    createMany?: UserCreateManyApprovedByInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type AnnouncementCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutAuthorInput,
          AnnouncementUncheckedCreateWithoutAuthorInput
        >
      | AnnouncementCreateWithoutAuthorInput[]
      | AnnouncementUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutAuthorInput
      | AnnouncementCreateOrConnectWithoutAuthorInput[];
    createMany?: AnnouncementCreateManyAuthorInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type AnnouncementLikeCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutUserInput,
          AnnouncementLikeUncheckedCreateWithoutUserInput
        >
      | AnnouncementLikeCreateWithoutUserInput[]
      | AnnouncementLikeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutUserInput
      | AnnouncementLikeCreateOrConnectWithoutUserInput[];
    createMany?: AnnouncementLikeCreateManyUserInputEnvelope;
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
  };

  export type AnnouncementCommentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutUserInput,
          AnnouncementCommentUncheckedCreateWithoutUserInput
        >
      | AnnouncementCommentCreateWithoutUserInput[]
      | AnnouncementCommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutUserInput
      | AnnouncementCommentCreateOrConnectWithoutUserInput[];
    createMany?: AnnouncementCommentCreateManyUserInputEnvelope;
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
  };

  export type PollCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<
          PollCreateWithoutCreatedByInput,
          PollUncheckedCreateWithoutCreatedByInput
        >
      | PollCreateWithoutCreatedByInput[]
      | PollUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | PollCreateOrConnectWithoutCreatedByInput
      | PollCreateOrConnectWithoutCreatedByInput[];
    createMany?: PollCreateManyCreatedByInputEnvelope;
    connect?: PollWhereUniqueInput | PollWhereUniqueInput[];
  };

  export type PollVoteCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutUserInput,
          PollVoteUncheckedCreateWithoutUserInput
        >
      | PollVoteCreateWithoutUserInput[]
      | PollVoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutUserInput
      | PollVoteCreateOrConnectWithoutUserInput[];
    createMany?: PollVoteCreateManyUserInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type FacilityBookingCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutUserInput,
          FacilityBookingUncheckedCreateWithoutUserInput
        >
      | FacilityBookingCreateWithoutUserInput[]
      | FacilityBookingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutUserInput
      | FacilityBookingCreateOrConnectWithoutUserInput[];
    createMany?: FacilityBookingCreateManyUserInputEnvelope;
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
  };

  export type ComplaintCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ComplaintCreateWithoutUserInput,
          ComplaintUncheckedCreateWithoutUserInput
        >
      | ComplaintCreateWithoutUserInput[]
      | ComplaintUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ComplaintCreateOrConnectWithoutUserInput
      | ComplaintCreateOrConnectWithoutUserInput[];
    createMany?: ComplaintCreateManyUserInputEnvelope;
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
  };

  export type PaymentCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type CommunityFinanceCreateNestedManyWithoutRecordedByInput = {
    create?:
      | XOR<
          CommunityFinanceCreateWithoutRecordedByInput,
          CommunityFinanceUncheckedCreateWithoutRecordedByInput
        >
      | CommunityFinanceCreateWithoutRecordedByInput[]
      | CommunityFinanceUncheckedCreateWithoutRecordedByInput[];
    connectOrCreate?:
      | CommunityFinanceCreateOrConnectWithoutRecordedByInput
      | CommunityFinanceCreateOrConnectWithoutRecordedByInput[];
    createMany?: CommunityFinanceCreateManyRecordedByInputEnvelope;
    connect?:
      | CommunityFinanceWhereUniqueInput
      | CommunityFinanceWhereUniqueInput[];
  };

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?:
      | XOR<
          MessageCreateWithoutSenderInput,
          MessageUncheckedCreateWithoutSenderInput
        >
      | MessageCreateWithoutSenderInput[]
      | MessageUncheckedCreateWithoutSenderInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSenderInput
      | MessageCreateOrConnectWithoutSenderInput[];
    createMany?: MessageCreateManySenderInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type RefreshTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
  };

  export type PushSubscriptionUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
  };

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
  };

  export type PropertyUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput;
    connect?: PropertyWhereUniqueInput;
  };

  export type UserUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?:
      | XOR<
          UserCreateWithoutApprovedByInput,
          UserUncheckedCreateWithoutApprovedByInput
        >
      | UserCreateWithoutApprovedByInput[]
      | UserUncheckedCreateWithoutApprovedByInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutApprovedByInput
      | UserCreateOrConnectWithoutApprovedByInput[];
    createMany?: UserCreateManyApprovedByInputEnvelope;
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
  };

  export type AnnouncementUncheckedCreateNestedManyWithoutAuthorInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutAuthorInput,
          AnnouncementUncheckedCreateWithoutAuthorInput
        >
      | AnnouncementCreateWithoutAuthorInput[]
      | AnnouncementUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutAuthorInput
      | AnnouncementCreateOrConnectWithoutAuthorInput[];
    createMany?: AnnouncementCreateManyAuthorInputEnvelope;
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
  };

  export type AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutUserInput,
          AnnouncementLikeUncheckedCreateWithoutUserInput
        >
      | AnnouncementLikeCreateWithoutUserInput[]
      | AnnouncementLikeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutUserInput
      | AnnouncementLikeCreateOrConnectWithoutUserInput[];
    createMany?: AnnouncementLikeCreateManyUserInputEnvelope;
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
  };

  export type AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutUserInput,
          AnnouncementCommentUncheckedCreateWithoutUserInput
        >
      | AnnouncementCommentCreateWithoutUserInput[]
      | AnnouncementCommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutUserInput
      | AnnouncementCommentCreateOrConnectWithoutUserInput[];
    createMany?: AnnouncementCommentCreateManyUserInputEnvelope;
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
  };

  export type PollUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?:
      | XOR<
          PollCreateWithoutCreatedByInput,
          PollUncheckedCreateWithoutCreatedByInput
        >
      | PollCreateWithoutCreatedByInput[]
      | PollUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | PollCreateOrConnectWithoutCreatedByInput
      | PollCreateOrConnectWithoutCreatedByInput[];
    createMany?: PollCreateManyCreatedByInputEnvelope;
    connect?: PollWhereUniqueInput | PollWhereUniqueInput[];
  };

  export type PollVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutUserInput,
          PollVoteUncheckedCreateWithoutUserInput
        >
      | PollVoteCreateWithoutUserInput[]
      | PollVoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutUserInput
      | PollVoteCreateOrConnectWithoutUserInput[];
    createMany?: PollVoteCreateManyUserInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type FacilityBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutUserInput,
          FacilityBookingUncheckedCreateWithoutUserInput
        >
      | FacilityBookingCreateWithoutUserInput[]
      | FacilityBookingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutUserInput
      | FacilityBookingCreateOrConnectWithoutUserInput[];
    createMany?: FacilityBookingCreateManyUserInputEnvelope;
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
  };

  export type ComplaintUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          ComplaintCreateWithoutUserInput,
          ComplaintUncheckedCreateWithoutUserInput
        >
      | ComplaintCreateWithoutUserInput[]
      | ComplaintUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ComplaintCreateOrConnectWithoutUserInput
      | ComplaintCreateOrConnectWithoutUserInput[];
    createMany?: ComplaintCreateManyUserInputEnvelope;
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
  };

  export type PaymentUncheckedCreateNestedManyWithoutUserInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
  };

  export type CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput =
    {
      create?:
        | XOR<
            CommunityFinanceCreateWithoutRecordedByInput,
            CommunityFinanceUncheckedCreateWithoutRecordedByInput
          >
        | CommunityFinanceCreateWithoutRecordedByInput[]
        | CommunityFinanceUncheckedCreateWithoutRecordedByInput[];
      connectOrCreate?:
        | CommunityFinanceCreateOrConnectWithoutRecordedByInput
        | CommunityFinanceCreateOrConnectWithoutRecordedByInput[];
      createMany?: CommunityFinanceCreateManyRecordedByInputEnvelope;
      connect?:
        | CommunityFinanceWhereUniqueInput
        | CommunityFinanceWhereUniqueInput[];
    };

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?:
      | XOR<
          MessageCreateWithoutSenderInput,
          MessageUncheckedCreateWithoutSenderInput
        >
      | MessageCreateWithoutSenderInput[]
      | MessageUncheckedCreateWithoutSenderInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSenderInput
      | MessageCreateOrConnectWithoutSenderInput[];
    createMany?: MessageCreateManySenderInputEnvelope;
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
  };

  export type StringFieldUpdateOperationsInput = {
    set?: string;
  };

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null;
    unset?: boolean;
  };

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole;
  };

  export type EnumUserStatusFieldUpdateOperationsInput = {
    set?: $Enums.UserStatus;
  };

  export type EnumAuthProviderFieldUpdateOperationsInput = {
    set?: $Enums.AuthProvider;
  };

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string;
  };

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean;
  };

  export type RefreshTokenUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    update?:
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | RefreshTokenUpdateManyWithWhereWithoutUserInput
      | RefreshTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
  };

  export type PushSubscriptionUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    upsert?:
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[];
    disconnect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    delete?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    update?:
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PushSubscriptionScalarWhereInput
      | PushSubscriptionScalarWhereInput[];
  };

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type PropertyUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput;
    upsert?: PropertyUpsertWithoutUserInput;
    disconnect?: PropertyWhereInput | boolean;
    delete?: PropertyWhereInput | boolean;
    connect?: PropertyWhereUniqueInput;
    update?: XOR<
      XOR<
        PropertyUpdateToOneWithWhereWithoutUserInput,
        PropertyUpdateWithoutUserInput
      >,
      PropertyUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserUpdateOneWithoutApprovalsNestedInput = {
    create?: XOR<
      UserCreateWithoutApprovalsInput,
      UserUncheckedCreateWithoutApprovalsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutApprovalsInput;
    upsert?: UserUpsertWithoutApprovalsInput;
    disconnect?: boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutApprovalsInput,
        UserUpdateWithoutApprovalsInput
      >,
      UserUncheckedUpdateWithoutApprovalsInput
    >;
  };

  export type UserUpdateManyWithoutApprovedByNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutApprovedByInput,
          UserUncheckedCreateWithoutApprovedByInput
        >
      | UserCreateWithoutApprovedByInput[]
      | UserUncheckedCreateWithoutApprovedByInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutApprovedByInput
      | UserCreateOrConnectWithoutApprovedByInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutApprovedByInput
      | UserUpsertWithWhereUniqueWithoutApprovedByInput[];
    createMany?: UserCreateManyApprovedByInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutApprovedByInput
      | UserUpdateWithWhereUniqueWithoutApprovedByInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutApprovedByInput
      | UserUpdateManyWithWhereWithoutApprovedByInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type AnnouncementUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutAuthorInput,
          AnnouncementUncheckedCreateWithoutAuthorInput
        >
      | AnnouncementCreateWithoutAuthorInput[]
      | AnnouncementUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutAuthorInput
      | AnnouncementCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput
      | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: AnnouncementCreateManyAuthorInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput
      | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutAuthorInput
      | AnnouncementUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type AnnouncementLikeUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutUserInput,
          AnnouncementLikeUncheckedCreateWithoutUserInput
        >
      | AnnouncementLikeCreateWithoutUserInput[]
      | AnnouncementLikeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutUserInput
      | AnnouncementLikeCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnnouncementLikeUpsertWithWhereUniqueWithoutUserInput
      | AnnouncementLikeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnnouncementLikeCreateManyUserInputEnvelope;
    set?: AnnouncementLikeWhereUniqueInput | AnnouncementLikeWhereUniqueInput[];
    disconnect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    delete?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    update?:
      | AnnouncementLikeUpdateWithWhereUniqueWithoutUserInput
      | AnnouncementLikeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnnouncementLikeUpdateManyWithWhereWithoutUserInput
      | AnnouncementLikeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AnnouncementLikeScalarWhereInput
      | AnnouncementLikeScalarWhereInput[];
  };

  export type AnnouncementCommentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutUserInput,
          AnnouncementCommentUncheckedCreateWithoutUserInput
        >
      | AnnouncementCommentCreateWithoutUserInput[]
      | AnnouncementCommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutUserInput
      | AnnouncementCommentCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnnouncementCommentUpsertWithWhereUniqueWithoutUserInput
      | AnnouncementCommentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnnouncementCommentCreateManyUserInputEnvelope;
    set?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    disconnect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    delete?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    update?:
      | AnnouncementCommentUpdateWithWhereUniqueWithoutUserInput
      | AnnouncementCommentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnnouncementCommentUpdateManyWithWhereWithoutUserInput
      | AnnouncementCommentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AnnouncementCommentScalarWhereInput
      | AnnouncementCommentScalarWhereInput[];
  };

  export type PollUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<
          PollCreateWithoutCreatedByInput,
          PollUncheckedCreateWithoutCreatedByInput
        >
      | PollCreateWithoutCreatedByInput[]
      | PollUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | PollCreateOrConnectWithoutCreatedByInput
      | PollCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | PollUpsertWithWhereUniqueWithoutCreatedByInput
      | PollUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: PollCreateManyCreatedByInputEnvelope;
    set?: PollWhereUniqueInput | PollWhereUniqueInput[];
    disconnect?: PollWhereUniqueInput | PollWhereUniqueInput[];
    delete?: PollWhereUniqueInput | PollWhereUniqueInput[];
    connect?: PollWhereUniqueInput | PollWhereUniqueInput[];
    update?:
      | PollUpdateWithWhereUniqueWithoutCreatedByInput
      | PollUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | PollUpdateManyWithWhereWithoutCreatedByInput
      | PollUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: PollScalarWhereInput | PollScalarWhereInput[];
  };

  export type PollVoteUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutUserInput,
          PollVoteUncheckedCreateWithoutUserInput
        >
      | PollVoteCreateWithoutUserInput[]
      | PollVoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutUserInput
      | PollVoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutUserInput
      | PollVoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PollVoteCreateManyUserInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutUserInput
      | PollVoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutUserInput
      | PollVoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type FacilityBookingUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutUserInput,
          FacilityBookingUncheckedCreateWithoutUserInput
        >
      | FacilityBookingCreateWithoutUserInput[]
      | FacilityBookingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutUserInput
      | FacilityBookingCreateOrConnectWithoutUserInput[];
    upsert?:
      | FacilityBookingUpsertWithWhereUniqueWithoutUserInput
      | FacilityBookingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: FacilityBookingCreateManyUserInputEnvelope;
    set?: FacilityBookingWhereUniqueInput | FacilityBookingWhereUniqueInput[];
    disconnect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    delete?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    update?:
      | FacilityBookingUpdateWithWhereUniqueWithoutUserInput
      | FacilityBookingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | FacilityBookingUpdateManyWithWhereWithoutUserInput
      | FacilityBookingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | FacilityBookingScalarWhereInput
      | FacilityBookingScalarWhereInput[];
  };

  export type ComplaintUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ComplaintCreateWithoutUserInput,
          ComplaintUncheckedCreateWithoutUserInput
        >
      | ComplaintCreateWithoutUserInput[]
      | ComplaintUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ComplaintCreateOrConnectWithoutUserInput
      | ComplaintCreateOrConnectWithoutUserInput[];
    upsert?:
      | ComplaintUpsertWithWhereUniqueWithoutUserInput
      | ComplaintUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ComplaintCreateManyUserInputEnvelope;
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    update?:
      | ComplaintUpdateWithWhereUniqueWithoutUserInput
      | ComplaintUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ComplaintUpdateManyWithWhereWithoutUserInput
      | ComplaintUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[];
  };

  export type PaymentUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutUserInput
      | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutUserInput
      | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutUserInput
      | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type CommunityFinanceUpdateManyWithoutRecordedByNestedInput = {
    create?:
      | XOR<
          CommunityFinanceCreateWithoutRecordedByInput,
          CommunityFinanceUncheckedCreateWithoutRecordedByInput
        >
      | CommunityFinanceCreateWithoutRecordedByInput[]
      | CommunityFinanceUncheckedCreateWithoutRecordedByInput[];
    connectOrCreate?:
      | CommunityFinanceCreateOrConnectWithoutRecordedByInput
      | CommunityFinanceCreateOrConnectWithoutRecordedByInput[];
    upsert?:
      | CommunityFinanceUpsertWithWhereUniqueWithoutRecordedByInput
      | CommunityFinanceUpsertWithWhereUniqueWithoutRecordedByInput[];
    createMany?: CommunityFinanceCreateManyRecordedByInputEnvelope;
    set?: CommunityFinanceWhereUniqueInput | CommunityFinanceWhereUniqueInput[];
    disconnect?:
      | CommunityFinanceWhereUniqueInput
      | CommunityFinanceWhereUniqueInput[];
    delete?:
      | CommunityFinanceWhereUniqueInput
      | CommunityFinanceWhereUniqueInput[];
    connect?:
      | CommunityFinanceWhereUniqueInput
      | CommunityFinanceWhereUniqueInput[];
    update?:
      | CommunityFinanceUpdateWithWhereUniqueWithoutRecordedByInput
      | CommunityFinanceUpdateWithWhereUniqueWithoutRecordedByInput[];
    updateMany?:
      | CommunityFinanceUpdateManyWithWhereWithoutRecordedByInput
      | CommunityFinanceUpdateManyWithWhereWithoutRecordedByInput[];
    deleteMany?:
      | CommunityFinanceScalarWhereInput
      | CommunityFinanceScalarWhereInput[];
  };

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutSenderInput,
          MessageUncheckedCreateWithoutSenderInput
        >
      | MessageCreateWithoutSenderInput[]
      | MessageUncheckedCreateWithoutSenderInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSenderInput
      | MessageCreateOrConnectWithoutSenderInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutSenderInput
      | MessageUpsertWithWhereUniqueWithoutSenderInput[];
    createMany?: MessageCreateManySenderInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutSenderInput
      | MessageUpdateWithWhereUniqueWithoutSenderInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutSenderInput
      | MessageUpdateManyWithWhereWithoutSenderInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type RefreshTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          RefreshTokenCreateWithoutUserInput,
          RefreshTokenUncheckedCreateWithoutUserInput
        >
      | RefreshTokenCreateWithoutUserInput[]
      | RefreshTokenUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | RefreshTokenCreateOrConnectWithoutUserInput
      | RefreshTokenCreateOrConnectWithoutUserInput[];
    upsert?:
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput
      | RefreshTokenUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: RefreshTokenCreateManyUserInputEnvelope;
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[];
    update?:
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput
      | RefreshTokenUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | RefreshTokenUpdateManyWithWhereWithoutUserInput
      | RefreshTokenUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
  };

  export type PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PushSubscriptionCreateWithoutUserInput,
          PushSubscriptionUncheckedCreateWithoutUserInput
        >
      | PushSubscriptionCreateWithoutUserInput[]
      | PushSubscriptionUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PushSubscriptionCreateOrConnectWithoutUserInput
      | PushSubscriptionCreateOrConnectWithoutUserInput[];
    upsert?:
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PushSubscriptionCreateManyUserInputEnvelope;
    set?: PushSubscriptionWhereUniqueInput | PushSubscriptionWhereUniqueInput[];
    disconnect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    delete?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    connect?:
      | PushSubscriptionWhereUniqueInput
      | PushSubscriptionWhereUniqueInput[];
    update?:
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput
      | PushSubscriptionUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput
      | PushSubscriptionUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | PushSubscriptionScalarWhereInput
      | PushSubscriptionScalarWhereInput[];
  };

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          NotificationCreateWithoutUserInput,
          NotificationUncheckedCreateWithoutUserInput
        >
      | NotificationCreateWithoutUserInput[]
      | NotificationUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | NotificationCreateOrConnectWithoutUserInput
      | NotificationCreateOrConnectWithoutUserInput[];
    upsert?:
      | NotificationUpsertWithWhereUniqueWithoutUserInput
      | NotificationUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: NotificationCreateManyUserInputEnvelope;
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[];
    update?:
      | NotificationUpdateWithWhereUniqueWithoutUserInput
      | NotificationUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | NotificationUpdateManyWithWhereWithoutUserInput
      | NotificationUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
  };

  export type PropertyUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
    connectOrCreate?: PropertyCreateOrConnectWithoutUserInput;
    upsert?: PropertyUpsertWithoutUserInput;
    disconnect?: PropertyWhereInput | boolean;
    delete?: PropertyWhereInput | boolean;
    connect?: PropertyWhereUniqueInput;
    update?: XOR<
      XOR<
        PropertyUpdateToOneWithWhereWithoutUserInput,
        PropertyUpdateWithoutUserInput
      >,
      PropertyUncheckedUpdateWithoutUserInput
    >;
  };

  export type UserUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?:
      | XOR<
          UserCreateWithoutApprovedByInput,
          UserUncheckedCreateWithoutApprovedByInput
        >
      | UserCreateWithoutApprovedByInput[]
      | UserUncheckedCreateWithoutApprovedByInput[];
    connectOrCreate?:
      | UserCreateOrConnectWithoutApprovedByInput
      | UserCreateOrConnectWithoutApprovedByInput[];
    upsert?:
      | UserUpsertWithWhereUniqueWithoutApprovedByInput
      | UserUpsertWithWhereUniqueWithoutApprovedByInput[];
    createMany?: UserCreateManyApprovedByInputEnvelope;
    set?: UserWhereUniqueInput | UserWhereUniqueInput[];
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[];
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[];
    update?:
      | UserUpdateWithWhereUniqueWithoutApprovedByInput
      | UserUpdateWithWhereUniqueWithoutApprovedByInput[];
    updateMany?:
      | UserUpdateManyWithWhereWithoutApprovedByInput
      | UserUpdateManyWithWhereWithoutApprovedByInput[];
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[];
  };

  export type AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?:
      | XOR<
          AnnouncementCreateWithoutAuthorInput,
          AnnouncementUncheckedCreateWithoutAuthorInput
        >
      | AnnouncementCreateWithoutAuthorInput[]
      | AnnouncementUncheckedCreateWithoutAuthorInput[];
    connectOrCreate?:
      | AnnouncementCreateOrConnectWithoutAuthorInput
      | AnnouncementCreateOrConnectWithoutAuthorInput[];
    upsert?:
      | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput
      | AnnouncementUpsertWithWhereUniqueWithoutAuthorInput[];
    createMany?: AnnouncementCreateManyAuthorInputEnvelope;
    set?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    disconnect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    delete?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    connect?: AnnouncementWhereUniqueInput | AnnouncementWhereUniqueInput[];
    update?:
      | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput
      | AnnouncementUpdateWithWhereUniqueWithoutAuthorInput[];
    updateMany?:
      | AnnouncementUpdateManyWithWhereWithoutAuthorInput
      | AnnouncementUpdateManyWithWhereWithoutAuthorInput[];
    deleteMany?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
  };

  export type AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutUserInput,
          AnnouncementLikeUncheckedCreateWithoutUserInput
        >
      | AnnouncementLikeCreateWithoutUserInput[]
      | AnnouncementLikeUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutUserInput
      | AnnouncementLikeCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnnouncementLikeUpsertWithWhereUniqueWithoutUserInput
      | AnnouncementLikeUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnnouncementLikeCreateManyUserInputEnvelope;
    set?: AnnouncementLikeWhereUniqueInput | AnnouncementLikeWhereUniqueInput[];
    disconnect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    delete?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    update?:
      | AnnouncementLikeUpdateWithWhereUniqueWithoutUserInput
      | AnnouncementLikeUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnnouncementLikeUpdateManyWithWhereWithoutUserInput
      | AnnouncementLikeUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AnnouncementLikeScalarWhereInput
      | AnnouncementLikeScalarWhereInput[];
  };

  export type AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutUserInput,
          AnnouncementCommentUncheckedCreateWithoutUserInput
        >
      | AnnouncementCommentCreateWithoutUserInput[]
      | AnnouncementCommentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutUserInput
      | AnnouncementCommentCreateOrConnectWithoutUserInput[];
    upsert?:
      | AnnouncementCommentUpsertWithWhereUniqueWithoutUserInput
      | AnnouncementCommentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: AnnouncementCommentCreateManyUserInputEnvelope;
    set?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    disconnect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    delete?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    update?:
      | AnnouncementCommentUpdateWithWhereUniqueWithoutUserInput
      | AnnouncementCommentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | AnnouncementCommentUpdateManyWithWhereWithoutUserInput
      | AnnouncementCommentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | AnnouncementCommentScalarWhereInput
      | AnnouncementCommentScalarWhereInput[];
  };

  export type PollUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?:
      | XOR<
          PollCreateWithoutCreatedByInput,
          PollUncheckedCreateWithoutCreatedByInput
        >
      | PollCreateWithoutCreatedByInput[]
      | PollUncheckedCreateWithoutCreatedByInput[];
    connectOrCreate?:
      | PollCreateOrConnectWithoutCreatedByInput
      | PollCreateOrConnectWithoutCreatedByInput[];
    upsert?:
      | PollUpsertWithWhereUniqueWithoutCreatedByInput
      | PollUpsertWithWhereUniqueWithoutCreatedByInput[];
    createMany?: PollCreateManyCreatedByInputEnvelope;
    set?: PollWhereUniqueInput | PollWhereUniqueInput[];
    disconnect?: PollWhereUniqueInput | PollWhereUniqueInput[];
    delete?: PollWhereUniqueInput | PollWhereUniqueInput[];
    connect?: PollWhereUniqueInput | PollWhereUniqueInput[];
    update?:
      | PollUpdateWithWhereUniqueWithoutCreatedByInput
      | PollUpdateWithWhereUniqueWithoutCreatedByInput[];
    updateMany?:
      | PollUpdateManyWithWhereWithoutCreatedByInput
      | PollUpdateManyWithWhereWithoutCreatedByInput[];
    deleteMany?: PollScalarWhereInput | PollScalarWhereInput[];
  };

  export type PollVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutUserInput,
          PollVoteUncheckedCreateWithoutUserInput
        >
      | PollVoteCreateWithoutUserInput[]
      | PollVoteUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutUserInput
      | PollVoteCreateOrConnectWithoutUserInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutUserInput
      | PollVoteUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PollVoteCreateManyUserInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutUserInput
      | PollVoteUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutUserInput
      | PollVoteUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type FacilityBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutUserInput,
          FacilityBookingUncheckedCreateWithoutUserInput
        >
      | FacilityBookingCreateWithoutUserInput[]
      | FacilityBookingUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutUserInput
      | FacilityBookingCreateOrConnectWithoutUserInput[];
    upsert?:
      | FacilityBookingUpsertWithWhereUniqueWithoutUserInput
      | FacilityBookingUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: FacilityBookingCreateManyUserInputEnvelope;
    set?: FacilityBookingWhereUniqueInput | FacilityBookingWhereUniqueInput[];
    disconnect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    delete?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    update?:
      | FacilityBookingUpdateWithWhereUniqueWithoutUserInput
      | FacilityBookingUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | FacilityBookingUpdateManyWithWhereWithoutUserInput
      | FacilityBookingUpdateManyWithWhereWithoutUserInput[];
    deleteMany?:
      | FacilityBookingScalarWhereInput
      | FacilityBookingScalarWhereInput[];
  };

  export type ComplaintUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          ComplaintCreateWithoutUserInput,
          ComplaintUncheckedCreateWithoutUserInput
        >
      | ComplaintCreateWithoutUserInput[]
      | ComplaintUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | ComplaintCreateOrConnectWithoutUserInput
      | ComplaintCreateOrConnectWithoutUserInput[];
    upsert?:
      | ComplaintUpsertWithWhereUniqueWithoutUserInput
      | ComplaintUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: ComplaintCreateManyUserInputEnvelope;
    set?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    disconnect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    delete?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    connect?: ComplaintWhereUniqueInput | ComplaintWhereUniqueInput[];
    update?:
      | ComplaintUpdateWithWhereUniqueWithoutUserInput
      | ComplaintUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | ComplaintUpdateManyWithWhereWithoutUserInput
      | ComplaintUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[];
  };

  export type PaymentUncheckedUpdateManyWithoutUserNestedInput = {
    create?:
      | XOR<
          PaymentCreateWithoutUserInput,
          PaymentUncheckedCreateWithoutUserInput
        >
      | PaymentCreateWithoutUserInput[]
      | PaymentUncheckedCreateWithoutUserInput[];
    connectOrCreate?:
      | PaymentCreateOrConnectWithoutUserInput
      | PaymentCreateOrConnectWithoutUserInput[];
    upsert?:
      | PaymentUpsertWithWhereUniqueWithoutUserInput
      | PaymentUpsertWithWhereUniqueWithoutUserInput[];
    createMany?: PaymentCreateManyUserInputEnvelope;
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[];
    update?:
      | PaymentUpdateWithWhereUniqueWithoutUserInput
      | PaymentUpdateWithWhereUniqueWithoutUserInput[];
    updateMany?:
      | PaymentUpdateManyWithWhereWithoutUserInput
      | PaymentUpdateManyWithWhereWithoutUserInput[];
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
  };

  export type CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput =
    {
      create?:
        | XOR<
            CommunityFinanceCreateWithoutRecordedByInput,
            CommunityFinanceUncheckedCreateWithoutRecordedByInput
          >
        | CommunityFinanceCreateWithoutRecordedByInput[]
        | CommunityFinanceUncheckedCreateWithoutRecordedByInput[];
      connectOrCreate?:
        | CommunityFinanceCreateOrConnectWithoutRecordedByInput
        | CommunityFinanceCreateOrConnectWithoutRecordedByInput[];
      upsert?:
        | CommunityFinanceUpsertWithWhereUniqueWithoutRecordedByInput
        | CommunityFinanceUpsertWithWhereUniqueWithoutRecordedByInput[];
      createMany?: CommunityFinanceCreateManyRecordedByInputEnvelope;
      set?:
        | CommunityFinanceWhereUniqueInput
        | CommunityFinanceWhereUniqueInput[];
      disconnect?:
        | CommunityFinanceWhereUniqueInput
        | CommunityFinanceWhereUniqueInput[];
      delete?:
        | CommunityFinanceWhereUniqueInput
        | CommunityFinanceWhereUniqueInput[];
      connect?:
        | CommunityFinanceWhereUniqueInput
        | CommunityFinanceWhereUniqueInput[];
      update?:
        | CommunityFinanceUpdateWithWhereUniqueWithoutRecordedByInput
        | CommunityFinanceUpdateWithWhereUniqueWithoutRecordedByInput[];
      updateMany?:
        | CommunityFinanceUpdateManyWithWhereWithoutRecordedByInput
        | CommunityFinanceUpdateManyWithWhereWithoutRecordedByInput[];
      deleteMany?:
        | CommunityFinanceScalarWhereInput
        | CommunityFinanceScalarWhereInput[];
    };

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?:
      | XOR<
          MessageCreateWithoutSenderInput,
          MessageUncheckedCreateWithoutSenderInput
        >
      | MessageCreateWithoutSenderInput[]
      | MessageUncheckedCreateWithoutSenderInput[];
    connectOrCreate?:
      | MessageCreateOrConnectWithoutSenderInput
      | MessageCreateOrConnectWithoutSenderInput[];
    upsert?:
      | MessageUpsertWithWhereUniqueWithoutSenderInput
      | MessageUpsertWithWhereUniqueWithoutSenderInput[];
    createMany?: MessageCreateManySenderInputEnvelope;
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[];
    update?:
      | MessageUpdateWithWhereUniqueWithoutSenderInput
      | MessageUpdateWithWhereUniqueWithoutSenderInput[];
    updateMany?:
      | MessageUpdateManyWithWhereWithoutSenderInput
      | MessageUpdateManyWithWhereWithoutSenderInput[];
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRefreshTokensInput;
    upsert?: UserUpsertWithoutRefreshTokensInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRefreshTokensInput,
        UserUpdateWithoutRefreshTokensInput
      >,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
  };

  export type UserCreateNestedOneWithoutPushSubscriptionsInput = {
    create?: XOR<
      UserCreateWithoutPushSubscriptionsInput,
      UserUncheckedCreateWithoutPushSubscriptionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutPushSubscriptionsNestedInput = {
    create?: XOR<
      UserCreateWithoutPushSubscriptionsInput,
      UserUncheckedCreateWithoutPushSubscriptionsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPushSubscriptionsInput;
    upsert?: UserUpsertWithoutPushSubscriptionsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPushSubscriptionsInput,
        UserUpdateWithoutPushSubscriptionsInput
      >,
      UserUncheckedUpdateWithoutPushSubscriptionsInput
    >;
  };

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput;
    upsert?: UserUpsertWithoutNotificationsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutNotificationsInput,
        UserUpdateWithoutNotificationsInput
      >,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserCreateNestedOneWithoutPropertyInput = {
    create?: XOR<
      UserCreateWithoutPropertyInput,
      UserUncheckedCreateWithoutPropertyInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneWithoutPropertyNestedInput = {
    create?: XOR<
      UserCreateWithoutPropertyInput,
      UserUncheckedCreateWithoutPropertyInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPropertyInput;
    upsert?: UserUpsertWithoutPropertyInput;
    disconnect?: boolean;
    delete?: UserWhereInput | boolean;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPropertyInput,
        UserUpdateWithoutPropertyInput
      >,
      UserUncheckedUpdateWithoutPropertyInput
    >;
  };

  export type UserCreateNestedOneWithoutAnnouncementsInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementsInput,
      UserUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AnnouncementLikeCreateNestedManyWithoutAnnouncementInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutAnnouncementInput,
          AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
        >
      | AnnouncementLikeCreateWithoutAnnouncementInput[]
      | AnnouncementLikeUncheckedCreateWithoutAnnouncementInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput
      | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput[];
    createMany?: AnnouncementLikeCreateManyAnnouncementInputEnvelope;
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
  };

  export type AnnouncementCommentCreateNestedManyWithoutAnnouncementInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutAnnouncementInput,
          AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
        >
      | AnnouncementCommentCreateWithoutAnnouncementInput[]
      | AnnouncementCommentUncheckedCreateWithoutAnnouncementInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput
      | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput[];
    createMany?: AnnouncementCommentCreateManyAnnouncementInputEnvelope;
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
  };

  export type PollCreateNestedOneWithoutAnnouncementInput = {
    create?: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutAnnouncementInput;
    connect?: PollWhereUniqueInput;
  };

  export type AnnouncementLikeUncheckedCreateNestedManyWithoutAnnouncementInput =
    {
      create?:
        | XOR<
            AnnouncementLikeCreateWithoutAnnouncementInput,
            AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
          >
        | AnnouncementLikeCreateWithoutAnnouncementInput[]
        | AnnouncementLikeUncheckedCreateWithoutAnnouncementInput[];
      connectOrCreate?:
        | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput
        | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput[];
      createMany?: AnnouncementLikeCreateManyAnnouncementInputEnvelope;
      connect?:
        | AnnouncementLikeWhereUniqueInput
        | AnnouncementLikeWhereUniqueInput[];
    };

  export type AnnouncementCommentUncheckedCreateNestedManyWithoutAnnouncementInput =
    {
      create?:
        | XOR<
            AnnouncementCommentCreateWithoutAnnouncementInput,
            AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
          >
        | AnnouncementCommentCreateWithoutAnnouncementInput[]
        | AnnouncementCommentUncheckedCreateWithoutAnnouncementInput[];
      connectOrCreate?:
        | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput
        | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput[];
      createMany?: AnnouncementCommentCreateManyAnnouncementInputEnvelope;
      connect?:
        | AnnouncementCommentWhereUniqueInput
        | AnnouncementCommentWhereUniqueInput[];
    };

  export type PollUncheckedCreateNestedOneWithoutAnnouncementInput = {
    create?: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutAnnouncementInput;
    connect?: PollWhereUniqueInput;
  };

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null;
    unset?: boolean;
  };

  export type UserUpdateOneRequiredWithoutAnnouncementsNestedInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementsInput,
      UserUncheckedCreateWithoutAnnouncementsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementsInput;
    upsert?: UserUpsertWithoutAnnouncementsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAnnouncementsInput,
        UserUpdateWithoutAnnouncementsInput
      >,
      UserUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type AnnouncementLikeUpdateManyWithoutAnnouncementNestedInput = {
    create?:
      | XOR<
          AnnouncementLikeCreateWithoutAnnouncementInput,
          AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
        >
      | AnnouncementLikeCreateWithoutAnnouncementInput[]
      | AnnouncementLikeUncheckedCreateWithoutAnnouncementInput[];
    connectOrCreate?:
      | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput
      | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput[];
    upsert?:
      | AnnouncementLikeUpsertWithWhereUniqueWithoutAnnouncementInput
      | AnnouncementLikeUpsertWithWhereUniqueWithoutAnnouncementInput[];
    createMany?: AnnouncementLikeCreateManyAnnouncementInputEnvelope;
    set?: AnnouncementLikeWhereUniqueInput | AnnouncementLikeWhereUniqueInput[];
    disconnect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    delete?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    connect?:
      | AnnouncementLikeWhereUniqueInput
      | AnnouncementLikeWhereUniqueInput[];
    update?:
      | AnnouncementLikeUpdateWithWhereUniqueWithoutAnnouncementInput
      | AnnouncementLikeUpdateWithWhereUniqueWithoutAnnouncementInput[];
    updateMany?:
      | AnnouncementLikeUpdateManyWithWhereWithoutAnnouncementInput
      | AnnouncementLikeUpdateManyWithWhereWithoutAnnouncementInput[];
    deleteMany?:
      | AnnouncementLikeScalarWhereInput
      | AnnouncementLikeScalarWhereInput[];
  };

  export type AnnouncementCommentUpdateManyWithoutAnnouncementNestedInput = {
    create?:
      | XOR<
          AnnouncementCommentCreateWithoutAnnouncementInput,
          AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
        >
      | AnnouncementCommentCreateWithoutAnnouncementInput[]
      | AnnouncementCommentUncheckedCreateWithoutAnnouncementInput[];
    connectOrCreate?:
      | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput
      | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput[];
    upsert?:
      | AnnouncementCommentUpsertWithWhereUniqueWithoutAnnouncementInput
      | AnnouncementCommentUpsertWithWhereUniqueWithoutAnnouncementInput[];
    createMany?: AnnouncementCommentCreateManyAnnouncementInputEnvelope;
    set?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    disconnect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    delete?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    connect?:
      | AnnouncementCommentWhereUniqueInput
      | AnnouncementCommentWhereUniqueInput[];
    update?:
      | AnnouncementCommentUpdateWithWhereUniqueWithoutAnnouncementInput
      | AnnouncementCommentUpdateWithWhereUniqueWithoutAnnouncementInput[];
    updateMany?:
      | AnnouncementCommentUpdateManyWithWhereWithoutAnnouncementInput
      | AnnouncementCommentUpdateManyWithWhereWithoutAnnouncementInput[];
    deleteMany?:
      | AnnouncementCommentScalarWhereInput
      | AnnouncementCommentScalarWhereInput[];
  };

  export type PollUpdateOneWithoutAnnouncementNestedInput = {
    create?: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutAnnouncementInput;
    upsert?: PollUpsertWithoutAnnouncementInput;
    disconnect?: PollWhereInput | boolean;
    delete?: PollWhereInput | boolean;
    connect?: PollWhereUniqueInput;
    update?: XOR<
      XOR<
        PollUpdateToOneWithWhereWithoutAnnouncementInput,
        PollUpdateWithoutAnnouncementInput
      >,
      PollUncheckedUpdateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementNestedInput =
    {
      create?:
        | XOR<
            AnnouncementLikeCreateWithoutAnnouncementInput,
            AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
          >
        | AnnouncementLikeCreateWithoutAnnouncementInput[]
        | AnnouncementLikeUncheckedCreateWithoutAnnouncementInput[];
      connectOrCreate?:
        | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput
        | AnnouncementLikeCreateOrConnectWithoutAnnouncementInput[];
      upsert?:
        | AnnouncementLikeUpsertWithWhereUniqueWithoutAnnouncementInput
        | AnnouncementLikeUpsertWithWhereUniqueWithoutAnnouncementInput[];
      createMany?: AnnouncementLikeCreateManyAnnouncementInputEnvelope;
      set?:
        | AnnouncementLikeWhereUniqueInput
        | AnnouncementLikeWhereUniqueInput[];
      disconnect?:
        | AnnouncementLikeWhereUniqueInput
        | AnnouncementLikeWhereUniqueInput[];
      delete?:
        | AnnouncementLikeWhereUniqueInput
        | AnnouncementLikeWhereUniqueInput[];
      connect?:
        | AnnouncementLikeWhereUniqueInput
        | AnnouncementLikeWhereUniqueInput[];
      update?:
        | AnnouncementLikeUpdateWithWhereUniqueWithoutAnnouncementInput
        | AnnouncementLikeUpdateWithWhereUniqueWithoutAnnouncementInput[];
      updateMany?:
        | AnnouncementLikeUpdateManyWithWhereWithoutAnnouncementInput
        | AnnouncementLikeUpdateManyWithWhereWithoutAnnouncementInput[];
      deleteMany?:
        | AnnouncementLikeScalarWhereInput
        | AnnouncementLikeScalarWhereInput[];
    };

  export type AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementNestedInput =
    {
      create?:
        | XOR<
            AnnouncementCommentCreateWithoutAnnouncementInput,
            AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
          >
        | AnnouncementCommentCreateWithoutAnnouncementInput[]
        | AnnouncementCommentUncheckedCreateWithoutAnnouncementInput[];
      connectOrCreate?:
        | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput
        | AnnouncementCommentCreateOrConnectWithoutAnnouncementInput[];
      upsert?:
        | AnnouncementCommentUpsertWithWhereUniqueWithoutAnnouncementInput
        | AnnouncementCommentUpsertWithWhereUniqueWithoutAnnouncementInput[];
      createMany?: AnnouncementCommentCreateManyAnnouncementInputEnvelope;
      set?:
        | AnnouncementCommentWhereUniqueInput
        | AnnouncementCommentWhereUniqueInput[];
      disconnect?:
        | AnnouncementCommentWhereUniqueInput
        | AnnouncementCommentWhereUniqueInput[];
      delete?:
        | AnnouncementCommentWhereUniqueInput
        | AnnouncementCommentWhereUniqueInput[];
      connect?:
        | AnnouncementCommentWhereUniqueInput
        | AnnouncementCommentWhereUniqueInput[];
      update?:
        | AnnouncementCommentUpdateWithWhereUniqueWithoutAnnouncementInput
        | AnnouncementCommentUpdateWithWhereUniqueWithoutAnnouncementInput[];
      updateMany?:
        | AnnouncementCommentUpdateManyWithWhereWithoutAnnouncementInput
        | AnnouncementCommentUpdateManyWithWhereWithoutAnnouncementInput[];
      deleteMany?:
        | AnnouncementCommentScalarWhereInput
        | AnnouncementCommentScalarWhereInput[];
    };

  export type PollUncheckedUpdateOneWithoutAnnouncementNestedInput = {
    create?: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutAnnouncementInput;
    upsert?: PollUpsertWithoutAnnouncementInput;
    disconnect?: PollWhereInput | boolean;
    delete?: PollWhereInput | boolean;
    connect?: PollWhereUniqueInput;
    update?: XOR<
      XOR<
        PollUpdateToOneWithWhereWithoutAnnouncementInput,
        PollUpdateWithoutAnnouncementInput
      >,
      PollUncheckedUpdateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementCreateNestedOneWithoutLikesInput = {
    create?: XOR<
      AnnouncementCreateWithoutLikesInput,
      AnnouncementUncheckedCreateWithoutLikesInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutLikesInput;
    connect?: AnnouncementWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAnnouncementLikesInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementLikesInput,
      UserUncheckedCreateWithoutAnnouncementLikesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementLikesInput;
    connect?: UserWhereUniqueInput;
  };

  export type AnnouncementUpdateOneRequiredWithoutLikesNestedInput = {
    create?: XOR<
      AnnouncementCreateWithoutLikesInput,
      AnnouncementUncheckedCreateWithoutLikesInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutLikesInput;
    upsert?: AnnouncementUpsertWithoutLikesInput;
    connect?: AnnouncementWhereUniqueInput;
    update?: XOR<
      XOR<
        AnnouncementUpdateToOneWithWhereWithoutLikesInput,
        AnnouncementUpdateWithoutLikesInput
      >,
      AnnouncementUncheckedUpdateWithoutLikesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutAnnouncementLikesNestedInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementLikesInput,
      UserUncheckedCreateWithoutAnnouncementLikesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementLikesInput;
    upsert?: UserUpsertWithoutAnnouncementLikesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAnnouncementLikesInput,
        UserUpdateWithoutAnnouncementLikesInput
      >,
      UserUncheckedUpdateWithoutAnnouncementLikesInput
    >;
  };

  export type AnnouncementCreateNestedOneWithoutCommentsInput = {
    create?: XOR<
      AnnouncementCreateWithoutCommentsInput,
      AnnouncementUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCommentsInput;
    connect?: AnnouncementWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutAnnouncementCommentsInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementCommentsInput,
      UserUncheckedCreateWithoutAnnouncementCommentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementCommentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type AnnouncementUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<
      AnnouncementCreateWithoutCommentsInput,
      AnnouncementUncheckedCreateWithoutCommentsInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutCommentsInput;
    upsert?: AnnouncementUpsertWithoutCommentsInput;
    connect?: AnnouncementWhereUniqueInput;
    update?: XOR<
      XOR<
        AnnouncementUpdateToOneWithWhereWithoutCommentsInput,
        AnnouncementUpdateWithoutCommentsInput
      >,
      AnnouncementUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type UserUpdateOneRequiredWithoutAnnouncementCommentsNestedInput = {
    create?: XOR<
      UserCreateWithoutAnnouncementCommentsInput,
      UserUncheckedCreateWithoutAnnouncementCommentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutAnnouncementCommentsInput;
    upsert?: UserUpsertWithoutAnnouncementCommentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutAnnouncementCommentsInput,
        UserUpdateWithoutAnnouncementCommentsInput
      >,
      UserUncheckedUpdateWithoutAnnouncementCommentsInput
    >;
  };

  export type IntFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumBlockNamingConventionFieldUpdateOperationsInput = {
    set?: $Enums.BlockNamingConvention;
  };

  export type UserCreateNestedOneWithoutCreatedPollsInput = {
    create?: XOR<
      UserCreateWithoutCreatedPollsInput,
      UserUncheckedCreateWithoutCreatedPollsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPollsInput;
    connect?: UserWhereUniqueInput;
  };

  export type PollOptionCreateNestedManyWithoutPollInput = {
    create?:
      | XOR<
          PollOptionCreateWithoutPollInput,
          PollOptionUncheckedCreateWithoutPollInput
        >
      | PollOptionCreateWithoutPollInput[]
      | PollOptionUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollOptionCreateOrConnectWithoutPollInput
      | PollOptionCreateOrConnectWithoutPollInput[];
    createMany?: PollOptionCreateManyPollInputEnvelope;
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
  };

  export type PollVoteCreateNestedManyWithoutPollInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutPollInput,
          PollVoteUncheckedCreateWithoutPollInput
        >
      | PollVoteCreateWithoutPollInput[]
      | PollVoteUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutPollInput
      | PollVoteCreateOrConnectWithoutPollInput[];
    createMany?: PollVoteCreateManyPollInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type AnnouncementCreateNestedOneWithoutPollInput = {
    create?: XOR<
      AnnouncementCreateWithoutPollInput,
      AnnouncementUncheckedCreateWithoutPollInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPollInput;
    connect?: AnnouncementWhereUniqueInput;
  };

  export type PollOptionUncheckedCreateNestedManyWithoutPollInput = {
    create?:
      | XOR<
          PollOptionCreateWithoutPollInput,
          PollOptionUncheckedCreateWithoutPollInput
        >
      | PollOptionCreateWithoutPollInput[]
      | PollOptionUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollOptionCreateOrConnectWithoutPollInput
      | PollOptionCreateOrConnectWithoutPollInput[];
    createMany?: PollOptionCreateManyPollInputEnvelope;
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
  };

  export type PollVoteUncheckedCreateNestedManyWithoutPollInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutPollInput,
          PollVoteUncheckedCreateWithoutPollInput
        >
      | PollVoteCreateWithoutPollInput[]
      | PollVoteUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutPollInput
      | PollVoteCreateOrConnectWithoutPollInput[];
    createMany?: PollVoteCreateManyPollInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type UserUpdateOneRequiredWithoutCreatedPollsNestedInput = {
    create?: XOR<
      UserCreateWithoutCreatedPollsInput,
      UserUncheckedCreateWithoutCreatedPollsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutCreatedPollsInput;
    upsert?: UserUpsertWithoutCreatedPollsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutCreatedPollsInput,
        UserUpdateWithoutCreatedPollsInput
      >,
      UserUncheckedUpdateWithoutCreatedPollsInput
    >;
  };

  export type PollOptionUpdateManyWithoutPollNestedInput = {
    create?:
      | XOR<
          PollOptionCreateWithoutPollInput,
          PollOptionUncheckedCreateWithoutPollInput
        >
      | PollOptionCreateWithoutPollInput[]
      | PollOptionUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollOptionCreateOrConnectWithoutPollInput
      | PollOptionCreateOrConnectWithoutPollInput[];
    upsert?:
      | PollOptionUpsertWithWhereUniqueWithoutPollInput
      | PollOptionUpsertWithWhereUniqueWithoutPollInput[];
    createMany?: PollOptionCreateManyPollInputEnvelope;
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    update?:
      | PollOptionUpdateWithWhereUniqueWithoutPollInput
      | PollOptionUpdateWithWhereUniqueWithoutPollInput[];
    updateMany?:
      | PollOptionUpdateManyWithWhereWithoutPollInput
      | PollOptionUpdateManyWithWhereWithoutPollInput[];
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[];
  };

  export type PollVoteUpdateManyWithoutPollNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutPollInput,
          PollVoteUncheckedCreateWithoutPollInput
        >
      | PollVoteCreateWithoutPollInput[]
      | PollVoteUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutPollInput
      | PollVoteCreateOrConnectWithoutPollInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutPollInput
      | PollVoteUpsertWithWhereUniqueWithoutPollInput[];
    createMany?: PollVoteCreateManyPollInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutPollInput
      | PollVoteUpdateWithWhereUniqueWithoutPollInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutPollInput
      | PollVoteUpdateManyWithWhereWithoutPollInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type AnnouncementUpdateOneWithoutPollNestedInput = {
    create?: XOR<
      AnnouncementCreateWithoutPollInput,
      AnnouncementUncheckedCreateWithoutPollInput
    >;
    connectOrCreate?: AnnouncementCreateOrConnectWithoutPollInput;
    upsert?: AnnouncementUpsertWithoutPollInput;
    disconnect?: boolean;
    delete?: AnnouncementWhereInput | boolean;
    connect?: AnnouncementWhereUniqueInput;
    update?: XOR<
      XOR<
        AnnouncementUpdateToOneWithWhereWithoutPollInput,
        AnnouncementUpdateWithoutPollInput
      >,
      AnnouncementUncheckedUpdateWithoutPollInput
    >;
  };

  export type PollOptionUncheckedUpdateManyWithoutPollNestedInput = {
    create?:
      | XOR<
          PollOptionCreateWithoutPollInput,
          PollOptionUncheckedCreateWithoutPollInput
        >
      | PollOptionCreateWithoutPollInput[]
      | PollOptionUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollOptionCreateOrConnectWithoutPollInput
      | PollOptionCreateOrConnectWithoutPollInput[];
    upsert?:
      | PollOptionUpsertWithWhereUniqueWithoutPollInput
      | PollOptionUpsertWithWhereUniqueWithoutPollInput[];
    createMany?: PollOptionCreateManyPollInputEnvelope;
    set?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    disconnect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    delete?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    connect?: PollOptionWhereUniqueInput | PollOptionWhereUniqueInput[];
    update?:
      | PollOptionUpdateWithWhereUniqueWithoutPollInput
      | PollOptionUpdateWithWhereUniqueWithoutPollInput[];
    updateMany?:
      | PollOptionUpdateManyWithWhereWithoutPollInput
      | PollOptionUpdateManyWithWhereWithoutPollInput[];
    deleteMany?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[];
  };

  export type PollVoteUncheckedUpdateManyWithoutPollNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutPollInput,
          PollVoteUncheckedCreateWithoutPollInput
        >
      | PollVoteCreateWithoutPollInput[]
      | PollVoteUncheckedCreateWithoutPollInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutPollInput
      | PollVoteCreateOrConnectWithoutPollInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutPollInput
      | PollVoteUpsertWithWhereUniqueWithoutPollInput[];
    createMany?: PollVoteCreateManyPollInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutPollInput
      | PollVoteUpdateWithWhereUniqueWithoutPollInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutPollInput
      | PollVoteUpdateManyWithWhereWithoutPollInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type PollCreateNestedOneWithoutOptionsInput = {
    create?: XOR<
      PollCreateWithoutOptionsInput,
      PollUncheckedCreateWithoutOptionsInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutOptionsInput;
    connect?: PollWhereUniqueInput;
  };

  export type PollVoteCreateNestedManyWithoutOptionInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutOptionInput,
          PollVoteUncheckedCreateWithoutOptionInput
        >
      | PollVoteCreateWithoutOptionInput[]
      | PollVoteUncheckedCreateWithoutOptionInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutOptionInput
      | PollVoteCreateOrConnectWithoutOptionInput[];
    createMany?: PollVoteCreateManyOptionInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type PollVoteUncheckedCreateNestedManyWithoutOptionInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutOptionInput,
          PollVoteUncheckedCreateWithoutOptionInput
        >
      | PollVoteCreateWithoutOptionInput[]
      | PollVoteUncheckedCreateWithoutOptionInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutOptionInput
      | PollVoteCreateOrConnectWithoutOptionInput[];
    createMany?: PollVoteCreateManyOptionInputEnvelope;
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
  };

  export type PollUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<
      PollCreateWithoutOptionsInput,
      PollUncheckedCreateWithoutOptionsInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutOptionsInput;
    upsert?: PollUpsertWithoutOptionsInput;
    connect?: PollWhereUniqueInput;
    update?: XOR<
      XOR<
        PollUpdateToOneWithWhereWithoutOptionsInput,
        PollUpdateWithoutOptionsInput
      >,
      PollUncheckedUpdateWithoutOptionsInput
    >;
  };

  export type PollVoteUpdateManyWithoutOptionNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutOptionInput,
          PollVoteUncheckedCreateWithoutOptionInput
        >
      | PollVoteCreateWithoutOptionInput[]
      | PollVoteUncheckedCreateWithoutOptionInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutOptionInput
      | PollVoteCreateOrConnectWithoutOptionInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutOptionInput
      | PollVoteUpsertWithWhereUniqueWithoutOptionInput[];
    createMany?: PollVoteCreateManyOptionInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutOptionInput
      | PollVoteUpdateWithWhereUniqueWithoutOptionInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutOptionInput
      | PollVoteUpdateManyWithWhereWithoutOptionInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type PollVoteUncheckedUpdateManyWithoutOptionNestedInput = {
    create?:
      | XOR<
          PollVoteCreateWithoutOptionInput,
          PollVoteUncheckedCreateWithoutOptionInput
        >
      | PollVoteCreateWithoutOptionInput[]
      | PollVoteUncheckedCreateWithoutOptionInput[];
    connectOrCreate?:
      | PollVoteCreateOrConnectWithoutOptionInput
      | PollVoteCreateOrConnectWithoutOptionInput[];
    upsert?:
      | PollVoteUpsertWithWhereUniqueWithoutOptionInput
      | PollVoteUpsertWithWhereUniqueWithoutOptionInput[];
    createMany?: PollVoteCreateManyOptionInputEnvelope;
    set?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    disconnect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    delete?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    connect?: PollVoteWhereUniqueInput | PollVoteWhereUniqueInput[];
    update?:
      | PollVoteUpdateWithWhereUniqueWithoutOptionInput
      | PollVoteUpdateWithWhereUniqueWithoutOptionInput[];
    updateMany?:
      | PollVoteUpdateManyWithWhereWithoutOptionInput
      | PollVoteUpdateManyWithWhereWithoutOptionInput[];
    deleteMany?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
  };

  export type PollCreateNestedOneWithoutVotesInput = {
    create?: XOR<
      PollCreateWithoutVotesInput,
      PollUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutVotesInput;
    connect?: PollWhereUniqueInput;
  };

  export type PollOptionCreateNestedOneWithoutVotesInput = {
    create?: XOR<
      PollOptionCreateWithoutVotesInput,
      PollOptionUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: PollOptionCreateOrConnectWithoutVotesInput;
    connect?: PollOptionWhereUniqueInput;
  };

  export type UserCreateNestedOneWithoutPollVotesInput = {
    create?: XOR<
      UserCreateWithoutPollVotesInput,
      UserUncheckedCreateWithoutPollVotesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput;
    connect?: UserWhereUniqueInput;
  };

  export type PollUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<
      PollCreateWithoutVotesInput,
      PollUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: PollCreateOrConnectWithoutVotesInput;
    upsert?: PollUpsertWithoutVotesInput;
    connect?: PollWhereUniqueInput;
    update?: XOR<
      XOR<
        PollUpdateToOneWithWhereWithoutVotesInput,
        PollUpdateWithoutVotesInput
      >,
      PollUncheckedUpdateWithoutVotesInput
    >;
  };

  export type PollOptionUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<
      PollOptionCreateWithoutVotesInput,
      PollOptionUncheckedCreateWithoutVotesInput
    >;
    connectOrCreate?: PollOptionCreateOrConnectWithoutVotesInput;
    upsert?: PollOptionUpsertWithoutVotesInput;
    connect?: PollOptionWhereUniqueInput;
    update?: XOR<
      XOR<
        PollOptionUpdateToOneWithWhereWithoutVotesInput,
        PollOptionUpdateWithoutVotesInput
      >,
      PollOptionUncheckedUpdateWithoutVotesInput
    >;
  };

  export type UserUpdateOneRequiredWithoutPollVotesNestedInput = {
    create?: XOR<
      UserCreateWithoutPollVotesInput,
      UserUncheckedCreateWithoutPollVotesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPollVotesInput;
    upsert?: UserUpsertWithoutPollVotesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPollVotesInput,
        UserUpdateWithoutPollVotesInput
      >,
      UserUncheckedUpdateWithoutPollVotesInput
    >;
  };

  export type FacilityCreateamenitiesInput = {
    set: string[];
  };

  export type FacilityCreateimagesInput = {
    set: string[];
  };

  export type FacilityBookingCreateNestedManyWithoutFacilityInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutFacilityInput,
          FacilityBookingUncheckedCreateWithoutFacilityInput
        >
      | FacilityBookingCreateWithoutFacilityInput[]
      | FacilityBookingUncheckedCreateWithoutFacilityInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutFacilityInput
      | FacilityBookingCreateOrConnectWithoutFacilityInput[];
    createMany?: FacilityBookingCreateManyFacilityInputEnvelope;
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
  };

  export type FacilityBookingUncheckedCreateNestedManyWithoutFacilityInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutFacilityInput,
          FacilityBookingUncheckedCreateWithoutFacilityInput
        >
      | FacilityBookingCreateWithoutFacilityInput[]
      | FacilityBookingUncheckedCreateWithoutFacilityInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutFacilityInput
      | FacilityBookingCreateOrConnectWithoutFacilityInput[];
    createMany?: FacilityBookingCreateManyFacilityInputEnvelope;
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
  };

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
    unset?: boolean;
  };

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
    unset?: boolean;
  };

  export type FacilityUpdateamenitiesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FacilityUpdateimagesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type FacilityBookingUpdateManyWithoutFacilityNestedInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutFacilityInput,
          FacilityBookingUncheckedCreateWithoutFacilityInput
        >
      | FacilityBookingCreateWithoutFacilityInput[]
      | FacilityBookingUncheckedCreateWithoutFacilityInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutFacilityInput
      | FacilityBookingCreateOrConnectWithoutFacilityInput[];
    upsert?:
      | FacilityBookingUpsertWithWhereUniqueWithoutFacilityInput
      | FacilityBookingUpsertWithWhereUniqueWithoutFacilityInput[];
    createMany?: FacilityBookingCreateManyFacilityInputEnvelope;
    set?: FacilityBookingWhereUniqueInput | FacilityBookingWhereUniqueInput[];
    disconnect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    delete?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    update?:
      | FacilityBookingUpdateWithWhereUniqueWithoutFacilityInput
      | FacilityBookingUpdateWithWhereUniqueWithoutFacilityInput[];
    updateMany?:
      | FacilityBookingUpdateManyWithWhereWithoutFacilityInput
      | FacilityBookingUpdateManyWithWhereWithoutFacilityInput[];
    deleteMany?:
      | FacilityBookingScalarWhereInput
      | FacilityBookingScalarWhereInput[];
  };

  export type FacilityBookingUncheckedUpdateManyWithoutFacilityNestedInput = {
    create?:
      | XOR<
          FacilityBookingCreateWithoutFacilityInput,
          FacilityBookingUncheckedCreateWithoutFacilityInput
        >
      | FacilityBookingCreateWithoutFacilityInput[]
      | FacilityBookingUncheckedCreateWithoutFacilityInput[];
    connectOrCreate?:
      | FacilityBookingCreateOrConnectWithoutFacilityInput
      | FacilityBookingCreateOrConnectWithoutFacilityInput[];
    upsert?:
      | FacilityBookingUpsertWithWhereUniqueWithoutFacilityInput
      | FacilityBookingUpsertWithWhereUniqueWithoutFacilityInput[];
    createMany?: FacilityBookingCreateManyFacilityInputEnvelope;
    set?: FacilityBookingWhereUniqueInput | FacilityBookingWhereUniqueInput[];
    disconnect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    delete?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    connect?:
      | FacilityBookingWhereUniqueInput
      | FacilityBookingWhereUniqueInput[];
    update?:
      | FacilityBookingUpdateWithWhereUniqueWithoutFacilityInput
      | FacilityBookingUpdateWithWhereUniqueWithoutFacilityInput[];
    updateMany?:
      | FacilityBookingUpdateManyWithWhereWithoutFacilityInput
      | FacilityBookingUpdateManyWithWhereWithoutFacilityInput[];
    deleteMany?:
      | FacilityBookingScalarWhereInput
      | FacilityBookingScalarWhereInput[];
  };

  export type UserCreateNestedOneWithoutFacilityBookingsInput = {
    create?: XOR<
      UserCreateWithoutFacilityBookingsInput,
      UserUncheckedCreateWithoutFacilityBookingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFacilityBookingsInput;
    connect?: UserWhereUniqueInput;
  };

  export type FacilityCreateNestedOneWithoutBookingsInput = {
    create?: XOR<
      FacilityCreateWithoutBookingsInput,
      FacilityUncheckedCreateWithoutBookingsInput
    >;
    connectOrCreate?: FacilityCreateOrConnectWithoutBookingsInput;
    connect?: FacilityWhereUniqueInput;
  };

  export type EnumFacilityBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.FacilityBookingStatus;
  };

  export type UserUpdateOneRequiredWithoutFacilityBookingsNestedInput = {
    create?: XOR<
      UserCreateWithoutFacilityBookingsInput,
      UserUncheckedCreateWithoutFacilityBookingsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutFacilityBookingsInput;
    upsert?: UserUpsertWithoutFacilityBookingsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutFacilityBookingsInput,
        UserUpdateWithoutFacilityBookingsInput
      >,
      UserUncheckedUpdateWithoutFacilityBookingsInput
    >;
  };

  export type FacilityUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<
      FacilityCreateWithoutBookingsInput,
      FacilityUncheckedCreateWithoutBookingsInput
    >;
    connectOrCreate?: FacilityCreateOrConnectWithoutBookingsInput;
    upsert?: FacilityUpsertWithoutBookingsInput;
    connect?: FacilityWhereUniqueInput;
    update?: XOR<
      XOR<
        FacilityUpdateToOneWithWhereWithoutBookingsInput,
        FacilityUpdateWithoutBookingsInput
      >,
      FacilityUncheckedUpdateWithoutBookingsInput
    >;
  };

  export type ComplaintCreateimagesInput = {
    set: string[];
  };

  export type UserCreateNestedOneWithoutComplaintsInput = {
    create?: XOR<
      UserCreateWithoutComplaintsInput,
      UserUncheckedCreateWithoutComplaintsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput;
    connect?: UserWhereUniqueInput;
  };

  export type EnumComplaintTypeFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintType;
  };

  export type EnumComplaintStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplaintStatus;
  };

  export type ComplaintUpdateimagesInput = {
    set?: string[];
    push?: string | string[];
  };

  export type UserUpdateOneRequiredWithoutComplaintsNestedInput = {
    create?: XOR<
      UserCreateWithoutComplaintsInput,
      UserUncheckedCreateWithoutComplaintsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutComplaintsInput;
    upsert?: UserUpsertWithoutComplaintsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutComplaintsInput,
        UserUpdateWithoutComplaintsInput
      >,
      UserUncheckedUpdateWithoutComplaintsInput
    >;
  };

  export type UserCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<
      UserCreateWithoutPaymentsInput,
      UserUncheckedCreateWithoutPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput;
    connect?: UserWhereUniqueInput;
  };

  export type FloatFieldUpdateOperationsInput = {
    set?: number;
    increment?: number;
    decrement?: number;
    multiply?: number;
    divide?: number;
  };

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType;
  };

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus;
  };

  export type NullableEnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod | null;
    unset?: boolean;
  };

  export type UserUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<
      UserCreateWithoutPaymentsInput,
      UserUncheckedCreateWithoutPaymentsInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutPaymentsInput;
    upsert?: UserUpsertWithoutPaymentsInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutPaymentsInput,
        UserUpdateWithoutPaymentsInput
      >,
      UserUncheckedUpdateWithoutPaymentsInput
    >;
  };

  export type UserCreateNestedOneWithoutRecordedFinancesInput = {
    create?: XOR<
      UserCreateWithoutRecordedFinancesInput,
      UserUncheckedCreateWithoutRecordedFinancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRecordedFinancesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutRecordedFinancesNestedInput = {
    create?: XOR<
      UserCreateWithoutRecordedFinancesInput,
      UserUncheckedCreateWithoutRecordedFinancesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutRecordedFinancesInput;
    upsert?: UserUpsertWithoutRecordedFinancesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutRecordedFinancesInput,
        UserUpdateWithoutRecordedFinancesInput
      >,
      UserUncheckedUpdateWithoutRecordedFinancesInput
    >;
  };

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<
      UserCreateWithoutMessagesInput,
      UserUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput;
    connect?: UserWhereUniqueInput;
  };

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<
      UserCreateWithoutMessagesInput,
      UserUncheckedCreateWithoutMessagesInput
    >;
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput;
    upsert?: UserUpsertWithoutMessagesInput;
    connect?: UserWhereUniqueInput;
    update?: XOR<
      XOR<
        UserUpdateToOneWithWhereWithoutMessagesInput,
        UserUpdateWithoutMessagesInput
      >,
      UserUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringFilter<$PrismaModel> | string;
  };

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringNullableFilter<$PrismaModel> | string | null;
    isSet?: boolean;
  };

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
  };

  export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus;
  };

  export type NestedEnumAuthProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthProvider | EnumAuthProviderFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.AuthProvider[]
      | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
    not?: NestedEnumAuthProviderFilter<$PrismaModel> | $Enums.AuthProvider;
  };

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
  };

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolFilter<$PrismaModel> | boolean;
  };

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>;
    in?: string[] | ListStringFieldRefInput<$PrismaModel>;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedStringFilter<$PrismaModel>;
    _max?: NestedStringFilter<$PrismaModel>;
  };

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntFilter<$PrismaModel> | number;
  };

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null;
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null;
    lt?: string | StringFieldRefInput<$PrismaModel>;
    lte?: string | StringFieldRefInput<$PrismaModel>;
    gt?: string | StringFieldRefInput<$PrismaModel>;
    gte?: string | StringFieldRefInput<$PrismaModel>;
    contains?: string | StringFieldRefInput<$PrismaModel>;
    startsWith?: string | StringFieldRefInput<$PrismaModel>;
    endsWith?: string | StringFieldRefInput<$PrismaModel>;
    not?:
      | NestedStringNullableWithAggregatesFilter<$PrismaModel>
      | string
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedStringNullableFilter<$PrismaModel>;
    _max?: NestedStringNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserRoleWithAggregatesFilter<$PrismaModel>
      | $Enums.UserRole;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserRoleFilter<$PrismaModel>;
    _max?: NestedEnumUserRoleFilter<$PrismaModel>;
  };

  export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
    in?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    notIn?: $Enums.UserStatus[] | ListEnumUserStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumUserStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.UserStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumUserStatusFilter<$PrismaModel>;
    _max?: NestedEnumUserStatusFilter<$PrismaModel>;
  };

  export type NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?:
        | $Enums.AuthProvider
        | EnumAuthProviderFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.AuthProvider[]
        | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.AuthProvider[]
        | ListEnumAuthProviderFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumAuthProviderWithAggregatesFilter<$PrismaModel>
        | $Enums.AuthProvider;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumAuthProviderFilter<$PrismaModel>;
      _max?: NestedEnumAuthProviderFilter<$PrismaModel>;
    };

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedDateTimeFilter<$PrismaModel>;
    _max?: NestedDateTimeFilter<$PrismaModel>;
  };

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedBoolFilter<$PrismaModel>;
    _max?: NestedBoolFilter<$PrismaModel>;
  };

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
    isSet?: boolean;
  };

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null;
      notIn?:
        | Date[]
        | string[]
        | ListDateTimeFieldRefInput<$PrismaModel>
        | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?:
        | NestedDateTimeNullableWithAggregatesFilter<$PrismaModel>
        | Date
        | string
        | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
      isSet?: boolean;
    };

  export type NestedEnumBlockNamingConventionFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.BlockNamingConvention
      | EnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBlockNamingConventionFilter<$PrismaModel>
      | $Enums.BlockNamingConvention;
  };

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>;
    in?: number[] | ListIntFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedIntFilter<$PrismaModel>;
    _min?: NestedIntFilter<$PrismaModel>;
    _max?: NestedIntFilter<$PrismaModel>;
  };

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatFilter<$PrismaModel> | number;
  };

  export type NestedEnumBlockNamingConventionWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.BlockNamingConvention
      | EnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.BlockNamingConvention[]
      | ListEnumBlockNamingConventionFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumBlockNamingConventionWithAggregatesFilter<$PrismaModel>
      | $Enums.BlockNamingConvention;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumBlockNamingConventionFilter<$PrismaModel>;
    _max?: NestedEnumBlockNamingConventionFilter<$PrismaModel>;
  };

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
    isSet?: boolean;
  };

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null;
    lt?: number | IntFieldRefInput<$PrismaModel>;
    lte?: number | IntFieldRefInput<$PrismaModel>;
    gt?: number | IntFieldRefInput<$PrismaModel>;
    gte?: number | IntFieldRefInput<$PrismaModel>;
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedIntNullableFilter<$PrismaModel>;
    _max?: NestedIntNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _avg?: NestedFloatNullableFilter<$PrismaModel>;
    _sum?: NestedFloatNullableFilter<$PrismaModel>;
    _min?: NestedFloatNullableFilter<$PrismaModel>;
    _max?: NestedFloatNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type NestedEnumFacilityBookingStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.FacilityBookingStatus
      | EnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFacilityBookingStatusFilter<$PrismaModel>
      | $Enums.FacilityBookingStatus;
  };

  export type NestedEnumFacilityBookingStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.FacilityBookingStatus
      | EnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.FacilityBookingStatus[]
      | ListEnumFacilityBookingStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumFacilityBookingStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.FacilityBookingStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumFacilityBookingStatusFilter<$PrismaModel>;
    _max?: NestedEnumFacilityBookingStatusFilter<$PrismaModel>;
  };

  export type NestedEnumComplaintTypeFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintType
      | EnumComplaintTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumComplaintTypeFilter<$PrismaModel> | $Enums.ComplaintType;
  };

  export type NestedEnumComplaintStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.ComplaintStatus
      | EnumComplaintStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintStatusFilter<$PrismaModel>
      | $Enums.ComplaintStatus;
  };

  export type NestedEnumComplaintTypeWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ComplaintType
      | EnumComplaintTypeFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintType[]
      | ListEnumComplaintTypeFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintTypeWithAggregatesFilter<$PrismaModel>
      | $Enums.ComplaintType;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumComplaintTypeFilter<$PrismaModel>;
    _max?: NestedEnumComplaintTypeFilter<$PrismaModel>;
  };

  export type NestedEnumComplaintStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.ComplaintStatus
      | EnumComplaintStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.ComplaintStatus[]
      | ListEnumComplaintStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumComplaintStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.ComplaintStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumComplaintStatusFilter<$PrismaModel>;
    _max?: NestedEnumComplaintStatusFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>;
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentType[]
      | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType;
  };

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus;
  };

  export type NestedEnumPaymentMethodNullableFilter<$PrismaModel = never> = {
    equals?:
      | $Enums.PaymentMethod
      | EnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumPaymentMethodNullableFilter<$PrismaModel>
      | $Enums.PaymentMethod
      | null;
    isSet?: boolean;
  };

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>;
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>;
    lt?: number | FloatFieldRefInput<$PrismaModel>;
    lte?: number | FloatFieldRefInput<$PrismaModel>;
    gt?: number | FloatFieldRefInput<$PrismaModel>;
    gte?: number | FloatFieldRefInput<$PrismaModel>;
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number;
    _count?: NestedIntFilter<$PrismaModel>;
    _avg?: NestedFloatFilter<$PrismaModel>;
    _sum?: NestedFloatFilter<$PrismaModel>;
    _min?: NestedFloatFilter<$PrismaModel>;
    _max?: NestedFloatFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> =
    {
      equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>;
      in?:
        | $Enums.PaymentType[]
        | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
      notIn?:
        | $Enums.PaymentType[]
        | ListEnumPaymentTypeFieldRefInput<$PrismaModel>;
      not?:
        | NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel>
        | $Enums.PaymentType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumPaymentTypeFilter<$PrismaModel>;
      _max?: NestedEnumPaymentTypeFilter<$PrismaModel>;
    };

  export type NestedEnumPaymentStatusWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PaymentStatus
      | EnumPaymentStatusFieldRefInput<$PrismaModel>;
    in?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    notIn?:
      | $Enums.PaymentStatus[]
      | ListEnumPaymentStatusFieldRefInput<$PrismaModel>;
    not?:
      | NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentStatus;
    _count?: NestedIntFilter<$PrismaModel>;
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>;
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>;
  };

  export type NestedEnumPaymentMethodNullableWithAggregatesFilter<
    $PrismaModel = never,
  > = {
    equals?:
      | $Enums.PaymentMethod
      | EnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    in?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    notIn?:
      | $Enums.PaymentMethod[]
      | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
      | null;
    not?:
      | NestedEnumPaymentMethodNullableWithAggregatesFilter<$PrismaModel>
      | $Enums.PaymentMethod
      | null;
    _count?: NestedIntNullableFilter<$PrismaModel>;
    _min?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>;
    _max?: NestedEnumPaymentMethodNullableFilter<$PrismaModel>;
    isSet?: boolean;
  };

  export type RefreshTokenCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RefreshTokenUncheckedCreateWithoutUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RefreshTokenCreateOrConnectWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    create: XOR<
      RefreshTokenCreateWithoutUserInput,
      RefreshTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type RefreshTokenCreateManyUserInputEnvelope = {
    data: RefreshTokenCreateManyUserInput | RefreshTokenCreateManyUserInput[];
  };

  export type PushSubscriptionCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionUncheckedCreateWithoutUserInput = {
    id?: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionCreateOrConnectWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    create: XOR<
      PushSubscriptionCreateWithoutUserInput,
      PushSubscriptionUncheckedCreateWithoutUserInput
    >;
  };

  export type PushSubscriptionCreateManyUserInputEnvelope = {
    data:
      | PushSubscriptionCreateManyUserInput
      | PushSubscriptionCreateManyUserInput[];
  };

  export type NotificationCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
  };

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[];
  };

  export type PropertyCreateWithoutUserInput = {
    id?: string;
    block: string;
    floor: string;
    flatNumber: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PropertyUncheckedCreateWithoutUserInput = {
    id?: string;
    block: string;
    floor: string;
    flatNumber: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PropertyCreateOrConnectWithoutUserInput = {
    where: PropertyWhereUniqueInput;
    create: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
  };

  export type UserCreateWithoutApprovalsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutApprovalsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutApprovalsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApprovalsInput,
      UserUncheckedCreateWithoutApprovalsInput
    >;
  };

  export type UserCreateWithoutApprovedByInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutApprovedByInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutApprovedByInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutApprovedByInput,
      UserUncheckedCreateWithoutApprovedByInput
    >;
  };

  export type UserCreateManyApprovedByInputEnvelope = {
    data: UserCreateManyApprovedByInput | UserCreateManyApprovedByInput[];
  };

  export type AnnouncementCreateWithoutAuthorInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    likes?: AnnouncementLikeCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentCreateNestedManyWithoutAnnouncementInput;
    poll?: PollCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementUncheckedCreateWithoutAuthorInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    likes?: AnnouncementLikeUncheckedCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentUncheckedCreateNestedManyWithoutAnnouncementInput;
    poll?: PollUncheckedCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementCreateOrConnectWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutAuthorInput,
      AnnouncementUncheckedCreateWithoutAuthorInput
    >;
  };

  export type AnnouncementCreateManyAuthorInputEnvelope = {
    data:
      | AnnouncementCreateManyAuthorInput
      | AnnouncementCreateManyAuthorInput[];
  };

  export type AnnouncementLikeCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    announcement: AnnouncementCreateNestedOneWithoutLikesInput;
  };

  export type AnnouncementLikeUncheckedCreateWithoutUserInput = {
    id?: string;
    announcementId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementLikeCreateOrConnectWithoutUserInput = {
    where: AnnouncementLikeWhereUniqueInput;
    create: XOR<
      AnnouncementLikeCreateWithoutUserInput,
      AnnouncementLikeUncheckedCreateWithoutUserInput
    >;
  };

  export type AnnouncementLikeCreateManyUserInputEnvelope = {
    data:
      | AnnouncementLikeCreateManyUserInput
      | AnnouncementLikeCreateManyUserInput[];
  };

  export type AnnouncementCommentCreateWithoutUserInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    announcement: AnnouncementCreateNestedOneWithoutCommentsInput;
  };

  export type AnnouncementCommentUncheckedCreateWithoutUserInput = {
    id?: string;
    content: string;
    announcementId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCommentCreateOrConnectWithoutUserInput = {
    where: AnnouncementCommentWhereUniqueInput;
    create: XOR<
      AnnouncementCommentCreateWithoutUserInput,
      AnnouncementCommentUncheckedCreateWithoutUserInput
    >;
  };

  export type AnnouncementCommentCreateManyUserInputEnvelope = {
    data:
      | AnnouncementCommentCreateManyUserInput
      | AnnouncementCommentCreateManyUserInput[];
  };

  export type PollCreateWithoutCreatedByInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    options?: PollOptionCreateNestedManyWithoutPollInput;
    votes?: PollVoteCreateNestedManyWithoutPollInput;
    announcement?: AnnouncementCreateNestedOneWithoutPollInput;
  };

  export type PollUncheckedCreateWithoutCreatedByInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    announcementId?: string | null;
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput;
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput;
  };

  export type PollCreateOrConnectWithoutCreatedByInput = {
    where: PollWhereUniqueInput;
    create: XOR<
      PollCreateWithoutCreatedByInput,
      PollUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type PollCreateManyCreatedByInputEnvelope = {
    data: PollCreateManyCreatedByInput | PollCreateManyCreatedByInput[];
  };

  export type PollVoteCreateWithoutUserInput = {
    id?: string;
    createdAt?: Date | string;
    poll: PollCreateNestedOneWithoutVotesInput;
    option: PollOptionCreateNestedOneWithoutVotesInput;
  };

  export type PollVoteUncheckedCreateWithoutUserInput = {
    id?: string;
    pollId: string;
    optionId: string;
    createdAt?: Date | string;
  };

  export type PollVoteCreateOrConnectWithoutUserInput = {
    where: PollVoteWhereUniqueInput;
    create: XOR<
      PollVoteCreateWithoutUserInput,
      PollVoteUncheckedCreateWithoutUserInput
    >;
  };

  export type PollVoteCreateManyUserInputEnvelope = {
    data: PollVoteCreateManyUserInput | PollVoteCreateManyUserInput[];
  };

  export type FacilityBookingCreateWithoutUserInput = {
    id?: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    facility: FacilityCreateNestedOneWithoutBookingsInput;
  };

  export type FacilityBookingUncheckedCreateWithoutUserInput = {
    id?: string;
    facilityId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityBookingCreateOrConnectWithoutUserInput = {
    where: FacilityBookingWhereUniqueInput;
    create: XOR<
      FacilityBookingCreateWithoutUserInput,
      FacilityBookingUncheckedCreateWithoutUserInput
    >;
  };

  export type FacilityBookingCreateManyUserInputEnvelope = {
    data:
      | FacilityBookingCreateManyUserInput
      | FacilityBookingCreateManyUserInput[];
  };

  export type ComplaintCreateWithoutUserInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComplaintUncheckedCreateWithoutUserInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComplaintCreateOrConnectWithoutUserInput = {
    where: ComplaintWhereUniqueInput;
    create: XOR<
      ComplaintCreateWithoutUserInput,
      ComplaintUncheckedCreateWithoutUserInput
    >;
  };

  export type ComplaintCreateManyUserInputEnvelope = {
    data: ComplaintCreateManyUserInput | ComplaintCreateManyUserInput[];
  };

  export type PaymentCreateWithoutUserInput = {
    id?: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentUncheckedCreateWithoutUserInput = {
    id?: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentCreateOrConnectWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    create: XOR<
      PaymentCreateWithoutUserInput,
      PaymentUncheckedCreateWithoutUserInput
    >;
  };

  export type PaymentCreateManyUserInputEnvelope = {
    data: PaymentCreateManyUserInput | PaymentCreateManyUserInput[];
  };

  export type CommunityFinanceCreateWithoutRecordedByInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommunityFinanceUncheckedCreateWithoutRecordedByInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommunityFinanceCreateOrConnectWithoutRecordedByInput = {
    where: CommunityFinanceWhereUniqueInput;
    create: XOR<
      CommunityFinanceCreateWithoutRecordedByInput,
      CommunityFinanceUncheckedCreateWithoutRecordedByInput
    >;
  };

  export type CommunityFinanceCreateManyRecordedByInputEnvelope = {
    data:
      | CommunityFinanceCreateManyRecordedByInput
      | CommunityFinanceCreateManyRecordedByInput[];
  };

  export type MessageCreateWithoutSenderInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput;
    create: XOR<
      MessageCreateWithoutSenderInput,
      MessageUncheckedCreateWithoutSenderInput
    >;
  };

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[];
  };

  export type RefreshTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    update: XOR<
      RefreshTokenUpdateWithoutUserInput,
      RefreshTokenUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      RefreshTokenCreateWithoutUserInput,
      RefreshTokenUncheckedCreateWithoutUserInput
    >;
  };

  export type RefreshTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: RefreshTokenWhereUniqueInput;
    data: XOR<
      RefreshTokenUpdateWithoutUserInput,
      RefreshTokenUncheckedUpdateWithoutUserInput
    >;
  };

  export type RefreshTokenUpdateManyWithWhereWithoutUserInput = {
    where: RefreshTokenScalarWhereInput;
    data: XOR<
      RefreshTokenUpdateManyMutationInput,
      RefreshTokenUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
    OR?: RefreshTokenScalarWhereInput[];
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[];
    id?: StringFilter<'RefreshToken'> | string;
    token?: StringFilter<'RefreshToken'> | string;
    userId?: StringFilter<'RefreshToken'> | string;
    expiresAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    revoked?: BoolFilter<'RefreshToken'> | boolean;
    createdAt?: DateTimeFilter<'RefreshToken'> | Date | string;
    updatedAt?: DateTimeFilter<'RefreshToken'> | Date | string;
  };

  export type PushSubscriptionUpsertWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    update: XOR<
      PushSubscriptionUpdateWithoutUserInput,
      PushSubscriptionUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PushSubscriptionCreateWithoutUserInput,
      PushSubscriptionUncheckedCreateWithoutUserInput
    >;
  };

  export type PushSubscriptionUpdateWithWhereUniqueWithoutUserInput = {
    where: PushSubscriptionWhereUniqueInput;
    data: XOR<
      PushSubscriptionUpdateWithoutUserInput,
      PushSubscriptionUncheckedUpdateWithoutUserInput
    >;
  };

  export type PushSubscriptionUpdateManyWithWhereWithoutUserInput = {
    where: PushSubscriptionScalarWhereInput;
    data: XOR<
      PushSubscriptionUpdateManyMutationInput,
      PushSubscriptionUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PushSubscriptionScalarWhereInput = {
    AND?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[];
    OR?: PushSubscriptionScalarWhereInput[];
    NOT?: PushSubscriptionScalarWhereInput | PushSubscriptionScalarWhereInput[];
    id?: StringFilter<'PushSubscription'> | string;
    userId?: StringFilter<'PushSubscription'> | string;
    endpoint?: StringFilter<'PushSubscription'> | string;
    p256dh?: StringFilter<'PushSubscription'> | string;
    auth?: StringFilter<'PushSubscription'> | string;
    createdAt?: DateTimeFilter<'PushSubscription'> | Date | string;
    updatedAt?: DateTimeFilter<'PushSubscription'> | Date | string;
  };

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    update: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      NotificationCreateWithoutUserInput,
      NotificationUncheckedCreateWithoutUserInput
    >;
  };

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput;
    data: XOR<
      NotificationUpdateWithoutUserInput,
      NotificationUncheckedUpdateWithoutUserInput
    >;
  };

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput;
    data: XOR<
      NotificationUpdateManyMutationInput,
      NotificationUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    OR?: NotificationScalarWhereInput[];
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[];
    id?: StringFilter<'Notification'> | string;
    userId?: StringFilter<'Notification'> | string;
    title?: StringFilter<'Notification'> | string;
    message?: StringFilter<'Notification'> | string;
    type?: StringFilter<'Notification'> | string;
    read?: BoolFilter<'Notification'> | boolean;
    link?: StringNullableFilter<'Notification'> | string | null;
    createdAt?: DateTimeFilter<'Notification'> | Date | string;
  };

  export type PropertyUpsertWithoutUserInput = {
    update: XOR<
      PropertyUpdateWithoutUserInput,
      PropertyUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PropertyCreateWithoutUserInput,
      PropertyUncheckedCreateWithoutUserInput
    >;
    where?: PropertyWhereInput;
  };

  export type PropertyUpdateToOneWithWhereWithoutUserInput = {
    where?: PropertyWhereInput;
    data: XOR<
      PropertyUpdateWithoutUserInput,
      PropertyUncheckedUpdateWithoutUserInput
    >;
  };

  export type PropertyUpdateWithoutUserInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PropertyUncheckedUpdateWithoutUserInput = {
    block?: StringFieldUpdateOperationsInput | string;
    floor?: StringFieldUpdateOperationsInput | string;
    flatNumber?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpsertWithoutApprovalsInput = {
    update: XOR<
      UserUpdateWithoutApprovalsInput,
      UserUncheckedUpdateWithoutApprovalsInput
    >;
    create: XOR<
      UserCreateWithoutApprovalsInput,
      UserUncheckedCreateWithoutApprovalsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutApprovalsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutApprovalsInput,
      UserUncheckedUpdateWithoutApprovalsInput
    >;
  };

  export type UserUpdateWithoutApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutApprovalsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: UserWhereUniqueInput;
    update: XOR<
      UserUpdateWithoutApprovedByInput,
      UserUncheckedUpdateWithoutApprovedByInput
    >;
    create: XOR<
      UserCreateWithoutApprovedByInput,
      UserUncheckedCreateWithoutApprovedByInput
    >;
  };

  export type UserUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: UserWhereUniqueInput;
    data: XOR<
      UserUpdateWithoutApprovedByInput,
      UserUncheckedUpdateWithoutApprovedByInput
    >;
  };

  export type UserUpdateManyWithWhereWithoutApprovedByInput = {
    where: UserScalarWhereInput;
    data: XOR<
      UserUpdateManyMutationInput,
      UserUncheckedUpdateManyWithoutApprovedByInput
    >;
  };

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[];
    OR?: UserScalarWhereInput[];
    NOT?: UserScalarWhereInput | UserScalarWhereInput[];
    id?: StringFilter<'User'> | string;
    email?: StringFilter<'User'> | string;
    phone?: StringNullableFilter<'User'> | string | null;
    name?: StringFilter<'User'> | string;
    password?: StringNullableFilter<'User'> | string | null;
    role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
    status?: EnumUserStatusFilter<'User'> | $Enums.UserStatus;
    rejectionReason?: StringNullableFilter<'User'> | string | null;
    provider?: EnumAuthProviderFilter<'User'> | $Enums.AuthProvider;
    image?: StringNullableFilter<'User'> | string | null;
    createdAt?: DateTimeFilter<'User'> | Date | string;
    updatedAt?: DateTimeFilter<'User'> | Date | string;
    approvedById?: StringNullableFilter<'User'> | string | null;
    notificationsEnabled?: BoolFilter<'User'> | boolean;
  };

  export type AnnouncementUpsertWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput;
    update: XOR<
      AnnouncementUpdateWithoutAuthorInput,
      AnnouncementUncheckedUpdateWithoutAuthorInput
    >;
    create: XOR<
      AnnouncementCreateWithoutAuthorInput,
      AnnouncementUncheckedCreateWithoutAuthorInput
    >;
  };

  export type AnnouncementUpdateWithWhereUniqueWithoutAuthorInput = {
    where: AnnouncementWhereUniqueInput;
    data: XOR<
      AnnouncementUpdateWithoutAuthorInput,
      AnnouncementUncheckedUpdateWithoutAuthorInput
    >;
  };

  export type AnnouncementUpdateManyWithWhereWithoutAuthorInput = {
    where: AnnouncementScalarWhereInput;
    data: XOR<
      AnnouncementUpdateManyMutationInput,
      AnnouncementUncheckedUpdateManyWithoutAuthorInput
    >;
  };

  export type AnnouncementScalarWhereInput = {
    AND?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    OR?: AnnouncementScalarWhereInput[];
    NOT?: AnnouncementScalarWhereInput | AnnouncementScalarWhereInput[];
    id?: StringFilter<'Announcement'> | string;
    title?: StringFilter<'Announcement'> | string;
    content?: StringFilter<'Announcement'> | string;
    imageUrl?: StringNullableFilter<'Announcement'> | string | null;
    authorId?: StringFilter<'Announcement'> | string;
    commentsEnabled?: BoolFilter<'Announcement'> | boolean;
    isPinned?: BoolFilter<'Announcement'> | boolean;
    pinnedAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    expiresAt?: DateTimeNullableFilter<'Announcement'> | Date | string | null;
    createdAt?: DateTimeFilter<'Announcement'> | Date | string;
    updatedAt?: DateTimeFilter<'Announcement'> | Date | string;
  };

  export type AnnouncementLikeUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnouncementLikeWhereUniqueInput;
    update: XOR<
      AnnouncementLikeUpdateWithoutUserInput,
      AnnouncementLikeUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AnnouncementLikeCreateWithoutUserInput,
      AnnouncementLikeUncheckedCreateWithoutUserInput
    >;
  };

  export type AnnouncementLikeUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnouncementLikeWhereUniqueInput;
    data: XOR<
      AnnouncementLikeUpdateWithoutUserInput,
      AnnouncementLikeUncheckedUpdateWithoutUserInput
    >;
  };

  export type AnnouncementLikeUpdateManyWithWhereWithoutUserInput = {
    where: AnnouncementLikeScalarWhereInput;
    data: XOR<
      AnnouncementLikeUpdateManyMutationInput,
      AnnouncementLikeUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AnnouncementLikeScalarWhereInput = {
    AND?: AnnouncementLikeScalarWhereInput | AnnouncementLikeScalarWhereInput[];
    OR?: AnnouncementLikeScalarWhereInput[];
    NOT?: AnnouncementLikeScalarWhereInput | AnnouncementLikeScalarWhereInput[];
    id?: StringFilter<'AnnouncementLike'> | string;
    announcementId?: StringFilter<'AnnouncementLike'> | string;
    userId?: StringFilter<'AnnouncementLike'> | string;
    createdAt?: DateTimeFilter<'AnnouncementLike'> | Date | string;
  };

  export type AnnouncementCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: AnnouncementCommentWhereUniqueInput;
    update: XOR<
      AnnouncementCommentUpdateWithoutUserInput,
      AnnouncementCommentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      AnnouncementCommentCreateWithoutUserInput,
      AnnouncementCommentUncheckedCreateWithoutUserInput
    >;
  };

  export type AnnouncementCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: AnnouncementCommentWhereUniqueInput;
    data: XOR<
      AnnouncementCommentUpdateWithoutUserInput,
      AnnouncementCommentUncheckedUpdateWithoutUserInput
    >;
  };

  export type AnnouncementCommentUpdateManyWithWhereWithoutUserInput = {
    where: AnnouncementCommentScalarWhereInput;
    data: XOR<
      AnnouncementCommentUpdateManyMutationInput,
      AnnouncementCommentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type AnnouncementCommentScalarWhereInput = {
    AND?:
      | AnnouncementCommentScalarWhereInput
      | AnnouncementCommentScalarWhereInput[];
    OR?: AnnouncementCommentScalarWhereInput[];
    NOT?:
      | AnnouncementCommentScalarWhereInput
      | AnnouncementCommentScalarWhereInput[];
    id?: StringFilter<'AnnouncementComment'> | string;
    content?: StringFilter<'AnnouncementComment'> | string;
    announcementId?: StringFilter<'AnnouncementComment'> | string;
    userId?: StringFilter<'AnnouncementComment'> | string;
    createdAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
    updatedAt?: DateTimeFilter<'AnnouncementComment'> | Date | string;
  };

  export type PollUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PollWhereUniqueInput;
    update: XOR<
      PollUpdateWithoutCreatedByInput,
      PollUncheckedUpdateWithoutCreatedByInput
    >;
    create: XOR<
      PollCreateWithoutCreatedByInput,
      PollUncheckedCreateWithoutCreatedByInput
    >;
  };

  export type PollUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PollWhereUniqueInput;
    data: XOR<
      PollUpdateWithoutCreatedByInput,
      PollUncheckedUpdateWithoutCreatedByInput
    >;
  };

  export type PollUpdateManyWithWhereWithoutCreatedByInput = {
    where: PollScalarWhereInput;
    data: XOR<
      PollUpdateManyMutationInput,
      PollUncheckedUpdateManyWithoutCreatedByInput
    >;
  };

  export type PollScalarWhereInput = {
    AND?: PollScalarWhereInput | PollScalarWhereInput[];
    OR?: PollScalarWhereInput[];
    NOT?: PollScalarWhereInput | PollScalarWhereInput[];
    id?: StringFilter<'Poll'> | string;
    question?: StringFilter<'Poll'> | string;
    description?: StringNullableFilter<'Poll'> | string | null;
    isAnonymous?: BoolFilter<'Poll'> | boolean;
    isPinned?: BoolFilter<'Poll'> | boolean;
    pinnedAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
    endsAt?: DateTimeNullableFilter<'Poll'> | Date | string | null;
    createdAt?: DateTimeFilter<'Poll'> | Date | string;
    updatedAt?: DateTimeFilter<'Poll'> | Date | string;
    createdById?: StringFilter<'Poll'> | string;
    announcementId?: StringNullableFilter<'Poll'> | string | null;
  };

  export type PollVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput;
    update: XOR<
      PollVoteUpdateWithoutUserInput,
      PollVoteUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PollVoteCreateWithoutUserInput,
      PollVoteUncheckedCreateWithoutUserInput
    >;
  };

  export type PollVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: PollVoteWhereUniqueInput;
    data: XOR<
      PollVoteUpdateWithoutUserInput,
      PollVoteUncheckedUpdateWithoutUserInput
    >;
  };

  export type PollVoteUpdateManyWithWhereWithoutUserInput = {
    where: PollVoteScalarWhereInput;
    data: XOR<
      PollVoteUpdateManyMutationInput,
      PollVoteUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PollVoteScalarWhereInput = {
    AND?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
    OR?: PollVoteScalarWhereInput[];
    NOT?: PollVoteScalarWhereInput | PollVoteScalarWhereInput[];
    id?: StringFilter<'PollVote'> | string;
    pollId?: StringFilter<'PollVote'> | string;
    optionId?: StringFilter<'PollVote'> | string;
    userId?: StringFilter<'PollVote'> | string;
    createdAt?: DateTimeFilter<'PollVote'> | Date | string;
  };

  export type FacilityBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: FacilityBookingWhereUniqueInput;
    update: XOR<
      FacilityBookingUpdateWithoutUserInput,
      FacilityBookingUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      FacilityBookingCreateWithoutUserInput,
      FacilityBookingUncheckedCreateWithoutUserInput
    >;
  };

  export type FacilityBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: FacilityBookingWhereUniqueInput;
    data: XOR<
      FacilityBookingUpdateWithoutUserInput,
      FacilityBookingUncheckedUpdateWithoutUserInput
    >;
  };

  export type FacilityBookingUpdateManyWithWhereWithoutUserInput = {
    where: FacilityBookingScalarWhereInput;
    data: XOR<
      FacilityBookingUpdateManyMutationInput,
      FacilityBookingUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type FacilityBookingScalarWhereInput = {
    AND?: FacilityBookingScalarWhereInput | FacilityBookingScalarWhereInput[];
    OR?: FacilityBookingScalarWhereInput[];
    NOT?: FacilityBookingScalarWhereInput | FacilityBookingScalarWhereInput[];
    id?: StringFilter<'FacilityBooking'> | string;
    userId?: StringFilter<'FacilityBooking'> | string;
    facilityId?: StringFilter<'FacilityBooking'> | string;
    startTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
    endTime?: DateTimeFilter<'FacilityBooking'> | Date | string;
    purpose?: StringNullableFilter<'FacilityBooking'> | string | null;
    status?:
      | EnumFacilityBookingStatusFilter<'FacilityBooking'>
      | $Enums.FacilityBookingStatus;
    totalCost?: FloatNullableFilter<'FacilityBooking'> | number | null;
    notes?: StringNullableFilter<'FacilityBooking'> | string | null;
    createdAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
    updatedAt?: DateTimeFilter<'FacilityBooking'> | Date | string;
  };

  export type ComplaintUpsertWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput;
    update: XOR<
      ComplaintUpdateWithoutUserInput,
      ComplaintUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      ComplaintCreateWithoutUserInput,
      ComplaintUncheckedCreateWithoutUserInput
    >;
  };

  export type ComplaintUpdateWithWhereUniqueWithoutUserInput = {
    where: ComplaintWhereUniqueInput;
    data: XOR<
      ComplaintUpdateWithoutUserInput,
      ComplaintUncheckedUpdateWithoutUserInput
    >;
  };

  export type ComplaintUpdateManyWithWhereWithoutUserInput = {
    where: ComplaintScalarWhereInput;
    data: XOR<
      ComplaintUpdateManyMutationInput,
      ComplaintUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type ComplaintScalarWhereInput = {
    AND?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[];
    OR?: ComplaintScalarWhereInput[];
    NOT?: ComplaintScalarWhereInput | ComplaintScalarWhereInput[];
    id?: StringFilter<'Complaint'> | string;
    title?: StringFilter<'Complaint'> | string;
    description?: StringFilter<'Complaint'> | string;
    type?: EnumComplaintTypeFilter<'Complaint'> | $Enums.ComplaintType;
    status?: EnumComplaintStatusFilter<'Complaint'> | $Enums.ComplaintStatus;
    userId?: StringFilter<'Complaint'> | string;
    resolvedAt?: DateTimeNullableFilter<'Complaint'> | Date | string | null;
    resolvedBy?: StringNullableFilter<'Complaint'> | string | null;
    rating?: IntNullableFilter<'Complaint'> | number | null;
    feedback?: StringNullableFilter<'Complaint'> | string | null;
    images?: StringNullableListFilter<'Complaint'>;
    createdAt?: DateTimeFilter<'Complaint'> | Date | string;
    updatedAt?: DateTimeFilter<'Complaint'> | Date | string;
  };

  export type PaymentUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    update: XOR<
      PaymentUpdateWithoutUserInput,
      PaymentUncheckedUpdateWithoutUserInput
    >;
    create: XOR<
      PaymentCreateWithoutUserInput,
      PaymentUncheckedCreateWithoutUserInput
    >;
  };

  export type PaymentUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentWhereUniqueInput;
    data: XOR<
      PaymentUpdateWithoutUserInput,
      PaymentUncheckedUpdateWithoutUserInput
    >;
  };

  export type PaymentUpdateManyWithWhereWithoutUserInput = {
    where: PaymentScalarWhereInput;
    data: XOR<
      PaymentUpdateManyMutationInput,
      PaymentUncheckedUpdateManyWithoutUserInput
    >;
  };

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    OR?: PaymentScalarWhereInput[];
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[];
    id?: StringFilter<'Payment'> | string;
    userId?: StringFilter<'Payment'> | string;
    amount?: FloatFilter<'Payment'> | number;
    type?: EnumPaymentTypeFilter<'Payment'> | $Enums.PaymentType;
    description?: StringFilter<'Payment'> | string;
    status?: EnumPaymentStatusFilter<'Payment'> | $Enums.PaymentStatus;
    dueDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    paidDate?: DateTimeNullableFilter<'Payment'> | Date | string | null;
    paymentMethod?:
      | EnumPaymentMethodNullableFilter<'Payment'>
      | $Enums.PaymentMethod
      | null;
    transactionId?: StringNullableFilter<'Payment'> | string | null;
    razorpayOrderId?: StringNullableFilter<'Payment'> | string | null;
    razorpayPaymentId?: StringNullableFilter<'Payment'> | string | null;
    receiptUrl?: StringNullableFilter<'Payment'> | string | null;
    createdAt?: DateTimeFilter<'Payment'> | Date | string;
    updatedAt?: DateTimeFilter<'Payment'> | Date | string;
  };

  export type CommunityFinanceUpsertWithWhereUniqueWithoutRecordedByInput = {
    where: CommunityFinanceWhereUniqueInput;
    update: XOR<
      CommunityFinanceUpdateWithoutRecordedByInput,
      CommunityFinanceUncheckedUpdateWithoutRecordedByInput
    >;
    create: XOR<
      CommunityFinanceCreateWithoutRecordedByInput,
      CommunityFinanceUncheckedCreateWithoutRecordedByInput
    >;
  };

  export type CommunityFinanceUpdateWithWhereUniqueWithoutRecordedByInput = {
    where: CommunityFinanceWhereUniqueInput;
    data: XOR<
      CommunityFinanceUpdateWithoutRecordedByInput,
      CommunityFinanceUncheckedUpdateWithoutRecordedByInput
    >;
  };

  export type CommunityFinanceUpdateManyWithWhereWithoutRecordedByInput = {
    where: CommunityFinanceScalarWhereInput;
    data: XOR<
      CommunityFinanceUpdateManyMutationInput,
      CommunityFinanceUncheckedUpdateManyWithoutRecordedByInput
    >;
  };

  export type CommunityFinanceScalarWhereInput = {
    AND?: CommunityFinanceScalarWhereInput | CommunityFinanceScalarWhereInput[];
    OR?: CommunityFinanceScalarWhereInput[];
    NOT?: CommunityFinanceScalarWhereInput | CommunityFinanceScalarWhereInput[];
    id?: StringFilter<'CommunityFinance'> | string;
    amount?: FloatFilter<'CommunityFinance'> | number;
    type?: StringFilter<'CommunityFinance'> | string;
    category?: StringFilter<'CommunityFinance'> | string;
    description?: StringNullableFilter<'CommunityFinance'> | string | null;
    date?: DateTimeFilter<'CommunityFinance'> | Date | string;
    recordedById?: StringFilter<'CommunityFinance'> | string;
    createdAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
    updatedAt?: DateTimeFilter<'CommunityFinance'> | Date | string;
  };

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput;
    update: XOR<
      MessageUpdateWithoutSenderInput,
      MessageUncheckedUpdateWithoutSenderInput
    >;
    create: XOR<
      MessageCreateWithoutSenderInput,
      MessageUncheckedCreateWithoutSenderInput
    >;
  };

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput;
    data: XOR<
      MessageUpdateWithoutSenderInput,
      MessageUncheckedUpdateWithoutSenderInput
    >;
  };

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput;
    data: XOR<
      MessageUpdateManyMutationInput,
      MessageUncheckedUpdateManyWithoutSenderInput
    >;
  };

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[];
    OR?: MessageScalarWhereInput[];
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[];
    id?: StringFilter<'Message'> | string;
    content?: StringFilter<'Message'> | string;
    senderId?: StringFilter<'Message'> | string;
    createdAt?: DateTimeFilter<'Message'> | Date | string;
    updatedAt?: DateTimeFilter<'Message'> | Date | string;
  };

  export type UserCreateWithoutRefreshTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutRefreshTokensInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutRefreshTokensInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
  };

  export type UserUpsertWithoutRefreshTokensInput = {
    update: XOR<
      UserUpdateWithoutRefreshTokensInput,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
    create: XOR<
      UserCreateWithoutRefreshTokensInput,
      UserUncheckedCreateWithoutRefreshTokensInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRefreshTokensInput,
      UserUncheckedUpdateWithoutRefreshTokensInput
    >;
  };

  export type UserUpdateWithoutRefreshTokensInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutRefreshTokensInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutPushSubscriptionsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutPushSubscriptionsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutPushSubscriptionsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPushSubscriptionsInput,
      UserUncheckedCreateWithoutPushSubscriptionsInput
    >;
  };

  export type UserUpsertWithoutPushSubscriptionsInput = {
    update: XOR<
      UserUpdateWithoutPushSubscriptionsInput,
      UserUncheckedUpdateWithoutPushSubscriptionsInput
    >;
    create: XOR<
      UserCreateWithoutPushSubscriptionsInput,
      UserUncheckedCreateWithoutPushSubscriptionsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPushSubscriptionsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPushSubscriptionsInput,
      UserUncheckedUpdateWithoutPushSubscriptionsInput
    >;
  };

  export type UserUpdateWithoutPushSubscriptionsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutPushSubscriptionsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
  };

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
    create: XOR<
      UserCreateWithoutNotificationsInput,
      UserUncheckedCreateWithoutNotificationsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutNotificationsInput,
      UserUncheckedUpdateWithoutNotificationsInput
    >;
  };

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutPropertyInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutPropertyInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutPropertyInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPropertyInput,
      UserUncheckedCreateWithoutPropertyInput
    >;
  };

  export type UserUpsertWithoutPropertyInput = {
    update: XOR<
      UserUpdateWithoutPropertyInput,
      UserUncheckedUpdateWithoutPropertyInput
    >;
    create: XOR<
      UserCreateWithoutPropertyInput,
      UserUncheckedCreateWithoutPropertyInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPropertyInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPropertyInput,
      UserUncheckedUpdateWithoutPropertyInput
    >;
  };

  export type UserUpdateWithoutPropertyInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutPropertyInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutAnnouncementsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutAnnouncementsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutAnnouncementsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAnnouncementsInput,
      UserUncheckedCreateWithoutAnnouncementsInput
    >;
  };

  export type AnnouncementLikeCreateWithoutAnnouncementInput = {
    id?: string;
    createdAt?: Date | string;
    user: UserCreateNestedOneWithoutAnnouncementLikesInput;
  };

  export type AnnouncementLikeUncheckedCreateWithoutAnnouncementInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementLikeCreateOrConnectWithoutAnnouncementInput = {
    where: AnnouncementLikeWhereUniqueInput;
    create: XOR<
      AnnouncementLikeCreateWithoutAnnouncementInput,
      AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementLikeCreateManyAnnouncementInputEnvelope = {
    data:
      | AnnouncementLikeCreateManyAnnouncementInput
      | AnnouncementLikeCreateManyAnnouncementInput[];
  };

  export type AnnouncementCommentCreateWithoutAnnouncementInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutAnnouncementCommentsInput;
  };

  export type AnnouncementCommentUncheckedCreateWithoutAnnouncementInput = {
    id?: string;
    content: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementCommentCreateOrConnectWithoutAnnouncementInput = {
    where: AnnouncementCommentWhereUniqueInput;
    create: XOR<
      AnnouncementCommentCreateWithoutAnnouncementInput,
      AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementCommentCreateManyAnnouncementInputEnvelope = {
    data:
      | AnnouncementCommentCreateManyAnnouncementInput
      | AnnouncementCommentCreateManyAnnouncementInput[];
  };

  export type PollCreateWithoutAnnouncementInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedPollsInput;
    options?: PollOptionCreateNestedManyWithoutPollInput;
    votes?: PollVoteCreateNestedManyWithoutPollInput;
  };

  export type PollUncheckedCreateWithoutAnnouncementInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput;
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput;
  };

  export type PollCreateOrConnectWithoutAnnouncementInput = {
    where: PollWhereUniqueInput;
    create: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
  };

  export type UserUpsertWithoutAnnouncementsInput = {
    update: XOR<
      UserUpdateWithoutAnnouncementsInput,
      UserUncheckedUpdateWithoutAnnouncementsInput
    >;
    create: XOR<
      UserCreateWithoutAnnouncementsInput,
      UserUncheckedCreateWithoutAnnouncementsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAnnouncementsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAnnouncementsInput,
      UserUncheckedUpdateWithoutAnnouncementsInput
    >;
  };

  export type UserUpdateWithoutAnnouncementsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutAnnouncementsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type AnnouncementLikeUpsertWithWhereUniqueWithoutAnnouncementInput = {
    where: AnnouncementLikeWhereUniqueInput;
    update: XOR<
      AnnouncementLikeUpdateWithoutAnnouncementInput,
      AnnouncementLikeUncheckedUpdateWithoutAnnouncementInput
    >;
    create: XOR<
      AnnouncementLikeCreateWithoutAnnouncementInput,
      AnnouncementLikeUncheckedCreateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementLikeUpdateWithWhereUniqueWithoutAnnouncementInput = {
    where: AnnouncementLikeWhereUniqueInput;
    data: XOR<
      AnnouncementLikeUpdateWithoutAnnouncementInput,
      AnnouncementLikeUncheckedUpdateWithoutAnnouncementInput
    >;
  };

  export type AnnouncementLikeUpdateManyWithWhereWithoutAnnouncementInput = {
    where: AnnouncementLikeScalarWhereInput;
    data: XOR<
      AnnouncementLikeUpdateManyMutationInput,
      AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementInput
    >;
  };

  export type AnnouncementCommentUpsertWithWhereUniqueWithoutAnnouncementInput =
    {
      where: AnnouncementCommentWhereUniqueInput;
      update: XOR<
        AnnouncementCommentUpdateWithoutAnnouncementInput,
        AnnouncementCommentUncheckedUpdateWithoutAnnouncementInput
      >;
      create: XOR<
        AnnouncementCommentCreateWithoutAnnouncementInput,
        AnnouncementCommentUncheckedCreateWithoutAnnouncementInput
      >;
    };

  export type AnnouncementCommentUpdateWithWhereUniqueWithoutAnnouncementInput =
    {
      where: AnnouncementCommentWhereUniqueInput;
      data: XOR<
        AnnouncementCommentUpdateWithoutAnnouncementInput,
        AnnouncementCommentUncheckedUpdateWithoutAnnouncementInput
      >;
    };

  export type AnnouncementCommentUpdateManyWithWhereWithoutAnnouncementInput = {
    where: AnnouncementCommentScalarWhereInput;
    data: XOR<
      AnnouncementCommentUpdateManyMutationInput,
      AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementInput
    >;
  };

  export type PollUpsertWithoutAnnouncementInput = {
    update: XOR<
      PollUpdateWithoutAnnouncementInput,
      PollUncheckedUpdateWithoutAnnouncementInput
    >;
    create: XOR<
      PollCreateWithoutAnnouncementInput,
      PollUncheckedCreateWithoutAnnouncementInput
    >;
    where?: PollWhereInput;
  };

  export type PollUpdateToOneWithWhereWithoutAnnouncementInput = {
    where?: PollWhereInput;
    data: XOR<
      PollUpdateWithoutAnnouncementInput,
      PollUncheckedUpdateWithoutAnnouncementInput
    >;
  };

  export type PollUpdateWithoutAnnouncementInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput;
    options?: PollOptionUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUpdateManyWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateWithoutAnnouncementInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput;
  };

  export type AnnouncementCreateWithoutLikesInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutAnnouncementsInput;
    comments?: AnnouncementCommentCreateNestedManyWithoutAnnouncementInput;
    poll?: PollCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementUncheckedCreateWithoutLikesInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    authorId: string;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    comments?: AnnouncementCommentUncheckedCreateNestedManyWithoutAnnouncementInput;
    poll?: PollUncheckedCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementCreateOrConnectWithoutLikesInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutLikesInput,
      AnnouncementUncheckedCreateWithoutLikesInput
    >;
  };

  export type UserCreateWithoutAnnouncementLikesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutAnnouncementLikesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutAnnouncementLikesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAnnouncementLikesInput,
      UserUncheckedCreateWithoutAnnouncementLikesInput
    >;
  };

  export type AnnouncementUpsertWithoutLikesInput = {
    update: XOR<
      AnnouncementUpdateWithoutLikesInput,
      AnnouncementUncheckedUpdateWithoutLikesInput
    >;
    create: XOR<
      AnnouncementCreateWithoutLikesInput,
      AnnouncementUncheckedCreateWithoutLikesInput
    >;
    where?: AnnouncementWhereInput;
  };

  export type AnnouncementUpdateToOneWithWhereWithoutLikesInput = {
    where?: AnnouncementWhereInput;
    data: XOR<
      AnnouncementUpdateWithoutLikesInput,
      AnnouncementUncheckedUpdateWithoutLikesInput
    >;
  };

  export type AnnouncementUpdateWithoutLikesInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput;
    comments?: AnnouncementCommentUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateWithoutLikesInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: StringFieldUpdateOperationsInput | string;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    comments?: AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUncheckedUpdateOneWithoutAnnouncementNestedInput;
  };

  export type UserUpsertWithoutAnnouncementLikesInput = {
    update: XOR<
      UserUpdateWithoutAnnouncementLikesInput,
      UserUncheckedUpdateWithoutAnnouncementLikesInput
    >;
    create: XOR<
      UserCreateWithoutAnnouncementLikesInput,
      UserUncheckedCreateWithoutAnnouncementLikesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAnnouncementLikesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAnnouncementLikesInput,
      UserUncheckedUpdateWithoutAnnouncementLikesInput
    >;
  };

  export type UserUpdateWithoutAnnouncementLikesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutAnnouncementLikesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type AnnouncementCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutAnnouncementsInput;
    likes?: AnnouncementLikeCreateNestedManyWithoutAnnouncementInput;
    poll?: PollCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementUncheckedCreateWithoutCommentsInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    authorId: string;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    likes?: AnnouncementLikeUncheckedCreateNestedManyWithoutAnnouncementInput;
    poll?: PollUncheckedCreateNestedOneWithoutAnnouncementInput;
  };

  export type AnnouncementCreateOrConnectWithoutCommentsInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutCommentsInput,
      AnnouncementUncheckedCreateWithoutCommentsInput
    >;
  };

  export type UserCreateWithoutAnnouncementCommentsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutAnnouncementCommentsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutAnnouncementCommentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutAnnouncementCommentsInput,
      UserUncheckedCreateWithoutAnnouncementCommentsInput
    >;
  };

  export type AnnouncementUpsertWithoutCommentsInput = {
    update: XOR<
      AnnouncementUpdateWithoutCommentsInput,
      AnnouncementUncheckedUpdateWithoutCommentsInput
    >;
    create: XOR<
      AnnouncementCreateWithoutCommentsInput,
      AnnouncementUncheckedCreateWithoutCommentsInput
    >;
    where?: AnnouncementWhereInput;
  };

  export type AnnouncementUpdateToOneWithWhereWithoutCommentsInput = {
    where?: AnnouncementWhereInput;
    data: XOR<
      AnnouncementUpdateWithoutCommentsInput,
      AnnouncementUncheckedUpdateWithoutCommentsInput
    >;
  };

  export type AnnouncementUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput;
    likes?: AnnouncementLikeUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateWithoutCommentsInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: StringFieldUpdateOperationsInput | string;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUncheckedUpdateOneWithoutAnnouncementNestedInput;
  };

  export type UserUpsertWithoutAnnouncementCommentsInput = {
    update: XOR<
      UserUpdateWithoutAnnouncementCommentsInput,
      UserUncheckedUpdateWithoutAnnouncementCommentsInput
    >;
    create: XOR<
      UserCreateWithoutAnnouncementCommentsInput,
      UserUncheckedCreateWithoutAnnouncementCommentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutAnnouncementCommentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutAnnouncementCommentsInput,
      UserUncheckedUpdateWithoutAnnouncementCommentsInput
    >;
  };

  export type UserUpdateWithoutAnnouncementCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutAnnouncementCommentsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutCreatedPollsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutCreatedPollsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutCreatedPollsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutCreatedPollsInput,
      UserUncheckedCreateWithoutCreatedPollsInput
    >;
  };

  export type PollOptionCreateWithoutPollInput = {
    id?: string;
    text: string;
    votes?: PollVoteCreateNestedManyWithoutOptionInput;
  };

  export type PollOptionUncheckedCreateWithoutPollInput = {
    id?: string;
    text: string;
    votes?: PollVoteUncheckedCreateNestedManyWithoutOptionInput;
  };

  export type PollOptionCreateOrConnectWithoutPollInput = {
    where: PollOptionWhereUniqueInput;
    create: XOR<
      PollOptionCreateWithoutPollInput,
      PollOptionUncheckedCreateWithoutPollInput
    >;
  };

  export type PollOptionCreateManyPollInputEnvelope = {
    data: PollOptionCreateManyPollInput | PollOptionCreateManyPollInput[];
  };

  export type PollVoteCreateWithoutPollInput = {
    id?: string;
    createdAt?: Date | string;
    option: PollOptionCreateNestedOneWithoutVotesInput;
    user: UserCreateNestedOneWithoutPollVotesInput;
  };

  export type PollVoteUncheckedCreateWithoutPollInput = {
    id?: string;
    optionId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollVoteCreateOrConnectWithoutPollInput = {
    where: PollVoteWhereUniqueInput;
    create: XOR<
      PollVoteCreateWithoutPollInput,
      PollVoteUncheckedCreateWithoutPollInput
    >;
  };

  export type PollVoteCreateManyPollInputEnvelope = {
    data: PollVoteCreateManyPollInput | PollVoteCreateManyPollInput[];
  };

  export type AnnouncementCreateWithoutPollInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    author: UserCreateNestedOneWithoutAnnouncementsInput;
    likes?: AnnouncementLikeCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentCreateNestedManyWithoutAnnouncementInput;
  };

  export type AnnouncementUncheckedCreateWithoutPollInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    authorId: string;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    likes?: AnnouncementLikeUncheckedCreateNestedManyWithoutAnnouncementInput;
    comments?: AnnouncementCommentUncheckedCreateNestedManyWithoutAnnouncementInput;
  };

  export type AnnouncementCreateOrConnectWithoutPollInput = {
    where: AnnouncementWhereUniqueInput;
    create: XOR<
      AnnouncementCreateWithoutPollInput,
      AnnouncementUncheckedCreateWithoutPollInput
    >;
  };

  export type UserUpsertWithoutCreatedPollsInput = {
    update: XOR<
      UserUpdateWithoutCreatedPollsInput,
      UserUncheckedUpdateWithoutCreatedPollsInput
    >;
    create: XOR<
      UserCreateWithoutCreatedPollsInput,
      UserUncheckedCreateWithoutCreatedPollsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutCreatedPollsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutCreatedPollsInput,
      UserUncheckedUpdateWithoutCreatedPollsInput
    >;
  };

  export type UserUpdateWithoutCreatedPollsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutCreatedPollsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type PollOptionUpsertWithWhereUniqueWithoutPollInput = {
    where: PollOptionWhereUniqueInput;
    update: XOR<
      PollOptionUpdateWithoutPollInput,
      PollOptionUncheckedUpdateWithoutPollInput
    >;
    create: XOR<
      PollOptionCreateWithoutPollInput,
      PollOptionUncheckedCreateWithoutPollInput
    >;
  };

  export type PollOptionUpdateWithWhereUniqueWithoutPollInput = {
    where: PollOptionWhereUniqueInput;
    data: XOR<
      PollOptionUpdateWithoutPollInput,
      PollOptionUncheckedUpdateWithoutPollInput
    >;
  };

  export type PollOptionUpdateManyWithWhereWithoutPollInput = {
    where: PollOptionScalarWhereInput;
    data: XOR<
      PollOptionUpdateManyMutationInput,
      PollOptionUncheckedUpdateManyWithoutPollInput
    >;
  };

  export type PollOptionScalarWhereInput = {
    AND?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[];
    OR?: PollOptionScalarWhereInput[];
    NOT?: PollOptionScalarWhereInput | PollOptionScalarWhereInput[];
    id?: StringFilter<'PollOption'> | string;
    text?: StringFilter<'PollOption'> | string;
    pollId?: StringFilter<'PollOption'> | string;
  };

  export type PollVoteUpsertWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput;
    update: XOR<
      PollVoteUpdateWithoutPollInput,
      PollVoteUncheckedUpdateWithoutPollInput
    >;
    create: XOR<
      PollVoteCreateWithoutPollInput,
      PollVoteUncheckedCreateWithoutPollInput
    >;
  };

  export type PollVoteUpdateWithWhereUniqueWithoutPollInput = {
    where: PollVoteWhereUniqueInput;
    data: XOR<
      PollVoteUpdateWithoutPollInput,
      PollVoteUncheckedUpdateWithoutPollInput
    >;
  };

  export type PollVoteUpdateManyWithWhereWithoutPollInput = {
    where: PollVoteScalarWhereInput;
    data: XOR<
      PollVoteUpdateManyMutationInput,
      PollVoteUncheckedUpdateManyWithoutPollInput
    >;
  };

  export type AnnouncementUpsertWithoutPollInput = {
    update: XOR<
      AnnouncementUpdateWithoutPollInput,
      AnnouncementUncheckedUpdateWithoutPollInput
    >;
    create: XOR<
      AnnouncementCreateWithoutPollInput,
      AnnouncementUncheckedCreateWithoutPollInput
    >;
    where?: AnnouncementWhereInput;
  };

  export type AnnouncementUpdateToOneWithWhereWithoutPollInput = {
    where?: AnnouncementWhereInput;
    data: XOR<
      AnnouncementUpdateWithoutPollInput,
      AnnouncementUncheckedUpdateWithoutPollInput
    >;
  };

  export type AnnouncementUpdateWithoutPollInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    author?: UserUpdateOneRequiredWithoutAnnouncementsNestedInput;
    likes?: AnnouncementLikeUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUpdateManyWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateWithoutPollInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    authorId?: StringFieldUpdateOperationsInput | string;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementNestedInput;
  };

  export type PollCreateWithoutOptionsInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedPollsInput;
    votes?: PollVoteCreateNestedManyWithoutPollInput;
    announcement?: AnnouncementCreateNestedOneWithoutPollInput;
  };

  export type PollUncheckedCreateWithoutOptionsInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    announcementId?: string | null;
    votes?: PollVoteUncheckedCreateNestedManyWithoutPollInput;
  };

  export type PollCreateOrConnectWithoutOptionsInput = {
    where: PollWhereUniqueInput;
    create: XOR<
      PollCreateWithoutOptionsInput,
      PollUncheckedCreateWithoutOptionsInput
    >;
  };

  export type PollVoteCreateWithoutOptionInput = {
    id?: string;
    createdAt?: Date | string;
    poll: PollCreateNestedOneWithoutVotesInput;
    user: UserCreateNestedOneWithoutPollVotesInput;
  };

  export type PollVoteUncheckedCreateWithoutOptionInput = {
    id?: string;
    pollId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollVoteCreateOrConnectWithoutOptionInput = {
    where: PollVoteWhereUniqueInput;
    create: XOR<
      PollVoteCreateWithoutOptionInput,
      PollVoteUncheckedCreateWithoutOptionInput
    >;
  };

  export type PollVoteCreateManyOptionInputEnvelope = {
    data: PollVoteCreateManyOptionInput | PollVoteCreateManyOptionInput[];
  };

  export type PollUpsertWithoutOptionsInput = {
    update: XOR<
      PollUpdateWithoutOptionsInput,
      PollUncheckedUpdateWithoutOptionsInput
    >;
    create: XOR<
      PollCreateWithoutOptionsInput,
      PollUncheckedCreateWithoutOptionsInput
    >;
    where?: PollWhereInput;
  };

  export type PollUpdateToOneWithWhereWithoutOptionsInput = {
    where?: PollWhereInput;
    data: XOR<
      PollUpdateWithoutOptionsInput,
      PollUncheckedUpdateWithoutOptionsInput
    >;
  };

  export type PollUpdateWithoutOptionsInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput;
    votes?: PollVoteUpdateManyWithoutPollNestedInput;
    announcement?: AnnouncementUpdateOneWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateWithoutOptionsInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput;
  };

  export type PollVoteUpsertWithWhereUniqueWithoutOptionInput = {
    where: PollVoteWhereUniqueInput;
    update: XOR<
      PollVoteUpdateWithoutOptionInput,
      PollVoteUncheckedUpdateWithoutOptionInput
    >;
    create: XOR<
      PollVoteCreateWithoutOptionInput,
      PollVoteUncheckedCreateWithoutOptionInput
    >;
  };

  export type PollVoteUpdateWithWhereUniqueWithoutOptionInput = {
    where: PollVoteWhereUniqueInput;
    data: XOR<
      PollVoteUpdateWithoutOptionInput,
      PollVoteUncheckedUpdateWithoutOptionInput
    >;
  };

  export type PollVoteUpdateManyWithWhereWithoutOptionInput = {
    where: PollVoteScalarWhereInput;
    data: XOR<
      PollVoteUpdateManyMutationInput,
      PollVoteUncheckedUpdateManyWithoutOptionInput
    >;
  };

  export type PollCreateWithoutVotesInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdBy: UserCreateNestedOneWithoutCreatedPollsInput;
    options?: PollOptionCreateNestedManyWithoutPollInput;
    announcement?: AnnouncementCreateNestedOneWithoutPollInput;
  };

  export type PollUncheckedCreateWithoutVotesInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    createdById: string;
    announcementId?: string | null;
    options?: PollOptionUncheckedCreateNestedManyWithoutPollInput;
  };

  export type PollCreateOrConnectWithoutVotesInput = {
    where: PollWhereUniqueInput;
    create: XOR<
      PollCreateWithoutVotesInput,
      PollUncheckedCreateWithoutVotesInput
    >;
  };

  export type PollOptionCreateWithoutVotesInput = {
    id?: string;
    text: string;
    poll: PollCreateNestedOneWithoutOptionsInput;
  };

  export type PollOptionUncheckedCreateWithoutVotesInput = {
    id?: string;
    text: string;
    pollId: string;
  };

  export type PollOptionCreateOrConnectWithoutVotesInput = {
    where: PollOptionWhereUniqueInput;
    create: XOR<
      PollOptionCreateWithoutVotesInput,
      PollOptionUncheckedCreateWithoutVotesInput
    >;
  };

  export type UserCreateWithoutPollVotesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutPollVotesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutPollVotesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPollVotesInput,
      UserUncheckedCreateWithoutPollVotesInput
    >;
  };

  export type PollUpsertWithoutVotesInput = {
    update: XOR<
      PollUpdateWithoutVotesInput,
      PollUncheckedUpdateWithoutVotesInput
    >;
    create: XOR<
      PollCreateWithoutVotesInput,
      PollUncheckedCreateWithoutVotesInput
    >;
    where?: PollWhereInput;
  };

  export type PollUpdateToOneWithWhereWithoutVotesInput = {
    where?: PollWhereInput;
    data: XOR<
      PollUpdateWithoutVotesInput,
      PollUncheckedUpdateWithoutVotesInput
    >;
  };

  export type PollUpdateWithoutVotesInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdBy?: UserUpdateOneRequiredWithoutCreatedPollsNestedInput;
    options?: PollOptionUpdateManyWithoutPollNestedInput;
    announcement?: AnnouncementUpdateOneWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateWithoutVotesInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdById?: StringFieldUpdateOperationsInput | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput;
  };

  export type PollOptionUpsertWithoutVotesInput = {
    update: XOR<
      PollOptionUpdateWithoutVotesInput,
      PollOptionUncheckedUpdateWithoutVotesInput
    >;
    create: XOR<
      PollOptionCreateWithoutVotesInput,
      PollOptionUncheckedCreateWithoutVotesInput
    >;
    where?: PollOptionWhereInput;
  };

  export type PollOptionUpdateToOneWithWhereWithoutVotesInput = {
    where?: PollOptionWhereInput;
    data: XOR<
      PollOptionUpdateWithoutVotesInput,
      PollOptionUncheckedUpdateWithoutVotesInput
    >;
  };

  export type PollOptionUpdateWithoutVotesInput = {
    text?: StringFieldUpdateOperationsInput | string;
    poll?: PollUpdateOneRequiredWithoutOptionsNestedInput;
  };

  export type PollOptionUncheckedUpdateWithoutVotesInput = {
    text?: StringFieldUpdateOperationsInput | string;
    pollId?: StringFieldUpdateOperationsInput | string;
  };

  export type UserUpsertWithoutPollVotesInput = {
    update: XOR<
      UserUpdateWithoutPollVotesInput,
      UserUncheckedUpdateWithoutPollVotesInput
    >;
    create: XOR<
      UserCreateWithoutPollVotesInput,
      UserUncheckedCreateWithoutPollVotesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPollVotesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPollVotesInput,
      UserUncheckedUpdateWithoutPollVotesInput
    >;
  };

  export type UserUpdateWithoutPollVotesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutPollVotesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type FacilityBookingCreateWithoutFacilityInput = {
    id?: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    user: UserCreateNestedOneWithoutFacilityBookingsInput;
  };

  export type FacilityBookingUncheckedCreateWithoutFacilityInput = {
    id?: string;
    userId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityBookingCreateOrConnectWithoutFacilityInput = {
    where: FacilityBookingWhereUniqueInput;
    create: XOR<
      FacilityBookingCreateWithoutFacilityInput,
      FacilityBookingUncheckedCreateWithoutFacilityInput
    >;
  };

  export type FacilityBookingCreateManyFacilityInputEnvelope = {
    data:
      | FacilityBookingCreateManyFacilityInput
      | FacilityBookingCreateManyFacilityInput[];
  };

  export type FacilityBookingUpsertWithWhereUniqueWithoutFacilityInput = {
    where: FacilityBookingWhereUniqueInput;
    update: XOR<
      FacilityBookingUpdateWithoutFacilityInput,
      FacilityBookingUncheckedUpdateWithoutFacilityInput
    >;
    create: XOR<
      FacilityBookingCreateWithoutFacilityInput,
      FacilityBookingUncheckedCreateWithoutFacilityInput
    >;
  };

  export type FacilityBookingUpdateWithWhereUniqueWithoutFacilityInput = {
    where: FacilityBookingWhereUniqueInput;
    data: XOR<
      FacilityBookingUpdateWithoutFacilityInput,
      FacilityBookingUncheckedUpdateWithoutFacilityInput
    >;
  };

  export type FacilityBookingUpdateManyWithWhereWithoutFacilityInput = {
    where: FacilityBookingScalarWhereInput;
    data: XOR<
      FacilityBookingUpdateManyMutationInput,
      FacilityBookingUncheckedUpdateManyWithoutFacilityInput
    >;
  };

  export type UserCreateWithoutFacilityBookingsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutFacilityBookingsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutFacilityBookingsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutFacilityBookingsInput,
      UserUncheckedCreateWithoutFacilityBookingsInput
    >;
  };

  export type FacilityCreateWithoutBookingsInput = {
    id?: string;
    name: string;
    description?: string | null;
    capacity?: number | null;
    hourlyRate?: number | null;
    isActive?: boolean;
    amenities?: FacilityCreateamenitiesInput | string[];
    rules?: string | null;
    images?: FacilityCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityUncheckedCreateWithoutBookingsInput = {
    id?: string;
    name: string;
    description?: string | null;
    capacity?: number | null;
    hourlyRate?: number | null;
    isActive?: boolean;
    amenities?: FacilityCreateamenitiesInput | string[];
    rules?: string | null;
    images?: FacilityCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityCreateOrConnectWithoutBookingsInput = {
    where: FacilityWhereUniqueInput;
    create: XOR<
      FacilityCreateWithoutBookingsInput,
      FacilityUncheckedCreateWithoutBookingsInput
    >;
  };

  export type UserUpsertWithoutFacilityBookingsInput = {
    update: XOR<
      UserUpdateWithoutFacilityBookingsInput,
      UserUncheckedUpdateWithoutFacilityBookingsInput
    >;
    create: XOR<
      UserCreateWithoutFacilityBookingsInput,
      UserUncheckedCreateWithoutFacilityBookingsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutFacilityBookingsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutFacilityBookingsInput,
      UserUncheckedUpdateWithoutFacilityBookingsInput
    >;
  };

  export type UserUpdateWithoutFacilityBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutFacilityBookingsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type FacilityUpsertWithoutBookingsInput = {
    update: XOR<
      FacilityUpdateWithoutBookingsInput,
      FacilityUncheckedUpdateWithoutBookingsInput
    >;
    create: XOR<
      FacilityCreateWithoutBookingsInput,
      FacilityUncheckedCreateWithoutBookingsInput
    >;
    where?: FacilityWhereInput;
  };

  export type FacilityUpdateToOneWithWhereWithoutBookingsInput = {
    where?: FacilityWhereInput;
    data: XOR<
      FacilityUpdateWithoutBookingsInput,
      FacilityUncheckedUpdateWithoutBookingsInput
    >;
  };

  export type FacilityUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityUncheckedUpdateWithoutBookingsInput = {
    name?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    capacity?: NullableIntFieldUpdateOperationsInput | number | null;
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null;
    isActive?: BoolFieldUpdateOperationsInput | boolean;
    amenities?: FacilityUpdateamenitiesInput | string[];
    rules?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: FacilityUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserCreateWithoutComplaintsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutComplaintsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutComplaintsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutComplaintsInput,
      UserUncheckedCreateWithoutComplaintsInput
    >;
  };

  export type UserUpsertWithoutComplaintsInput = {
    update: XOR<
      UserUpdateWithoutComplaintsInput,
      UserUncheckedUpdateWithoutComplaintsInput
    >;
    create: XOR<
      UserCreateWithoutComplaintsInput,
      UserUncheckedCreateWithoutComplaintsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutComplaintsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutComplaintsInput,
      UserUncheckedUpdateWithoutComplaintsInput
    >;
  };

  export type UserUpdateWithoutComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutComplaintsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutPaymentsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutPaymentsInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutPaymentsInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutPaymentsInput,
      UserUncheckedCreateWithoutPaymentsInput
    >;
  };

  export type UserUpsertWithoutPaymentsInput = {
    update: XOR<
      UserUpdateWithoutPaymentsInput,
      UserUncheckedUpdateWithoutPaymentsInput
    >;
    create: XOR<
      UserCreateWithoutPaymentsInput,
      UserUncheckedCreateWithoutPaymentsInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutPaymentsInput,
      UserUncheckedUpdateWithoutPaymentsInput
    >;
  };

  export type UserUpdateWithoutPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutPaymentsInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutRecordedFinancesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    messages?: MessageCreateNestedManyWithoutSenderInput;
  };

  export type UserUncheckedCreateWithoutRecordedFinancesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput;
  };

  export type UserCreateOrConnectWithoutRecordedFinancesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutRecordedFinancesInput,
      UserUncheckedCreateWithoutRecordedFinancesInput
    >;
  };

  export type UserUpsertWithoutRecordedFinancesInput = {
    update: XOR<
      UserUpdateWithoutRecordedFinancesInput,
      UserUncheckedUpdateWithoutRecordedFinancesInput
    >;
    create: XOR<
      UserCreateWithoutRecordedFinancesInput,
      UserUncheckedCreateWithoutRecordedFinancesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutRecordedFinancesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutRecordedFinancesInput,
      UserUncheckedUpdateWithoutRecordedFinancesInput
    >;
  };

  export type UserUpdateWithoutRecordedFinancesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutRecordedFinancesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserCreateWithoutMessagesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionCreateNestedManyWithoutUserInput;
    notifications?: NotificationCreateNestedManyWithoutUserInput;
    property?: PropertyCreateNestedOneWithoutUserInput;
    approvedBy?: UserCreateNestedOneWithoutApprovalsInput;
    approvals?: UserCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentCreateNestedManyWithoutUserInput;
    createdPolls?: PollCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingCreateNestedManyWithoutUserInput;
    complaints?: ComplaintCreateNestedManyWithoutUserInput;
    payments?: PaymentCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceCreateNestedManyWithoutRecordedByInput;
  };

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    approvedById?: string | null;
    notificationsEnabled?: boolean;
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutUserInput;
    pushSubscriptions?: PushSubscriptionUncheckedCreateNestedManyWithoutUserInput;
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput;
    property?: PropertyUncheckedCreateNestedOneWithoutUserInput;
    approvals?: UserUncheckedCreateNestedManyWithoutApprovedByInput;
    announcements?: AnnouncementUncheckedCreateNestedManyWithoutAuthorInput;
    announcementLikes?: AnnouncementLikeUncheckedCreateNestedManyWithoutUserInput;
    announcementComments?: AnnouncementCommentUncheckedCreateNestedManyWithoutUserInput;
    createdPolls?: PollUncheckedCreateNestedManyWithoutCreatedByInput;
    pollVotes?: PollVoteUncheckedCreateNestedManyWithoutUserInput;
    facilityBookings?: FacilityBookingUncheckedCreateNestedManyWithoutUserInput;
    complaints?: ComplaintUncheckedCreateNestedManyWithoutUserInput;
    payments?: PaymentUncheckedCreateNestedManyWithoutUserInput;
    recordedFinances?: CommunityFinanceUncheckedCreateNestedManyWithoutRecordedByInput;
  };

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput;
    create: XOR<
      UserCreateWithoutMessagesInput,
      UserUncheckedCreateWithoutMessagesInput
    >;
  };

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<
      UserUpdateWithoutMessagesInput,
      UserUncheckedUpdateWithoutMessagesInput
    >;
    create: XOR<
      UserCreateWithoutMessagesInput,
      UserUncheckedCreateWithoutMessagesInput
    >;
    where?: UserWhereInput;
  };

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput;
    data: XOR<
      UserUpdateWithoutMessagesInput,
      UserUncheckedUpdateWithoutMessagesInput
    >;
  };

  export type UserUpdateWithoutMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvedBy?: UserUpdateOneWithoutApprovalsNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
  };

  export type UserUncheckedUpdateWithoutMessagesInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
  };

  export type RefreshTokenCreateManyUserInput = {
    id?: string;
    token: string;
    expiresAt: Date | string;
    revoked?: boolean;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PushSubscriptionCreateManyUserInput = {
    id?: string;
    endpoint: string;
    p256dh: string;
    auth: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type NotificationCreateManyUserInput = {
    id?: string;
    title: string;
    message: string;
    type: string;
    read?: boolean;
    link?: string | null;
    createdAt?: Date | string;
  };

  export type UserCreateManyApprovedByInput = {
    id?: string;
    email: string;
    phone?: string | null;
    name: string;
    password?: string | null;
    role?: $Enums.UserRole;
    status?: $Enums.UserStatus;
    rejectionReason?: string | null;
    provider?: $Enums.AuthProvider;
    image?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    notificationsEnabled?: boolean;
  };

  export type AnnouncementCreateManyAuthorInput = {
    id?: string;
    title: string;
    content: string;
    imageUrl?: string | null;
    commentsEnabled?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    expiresAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementLikeCreateManyUserInput = {
    id?: string;
    announcementId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementCommentCreateManyUserInput = {
    id?: string;
    content: string;
    announcementId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PollCreateManyCreatedByInput = {
    id?: string;
    question: string;
    description?: string | null;
    isAnonymous?: boolean;
    isPinned?: boolean;
    pinnedAt?: Date | string | null;
    endsAt?: Date | string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
    announcementId?: string | null;
  };

  export type PollVoteCreateManyUserInput = {
    id?: string;
    pollId: string;
    optionId: string;
    createdAt?: Date | string;
  };

  export type FacilityBookingCreateManyUserInput = {
    id?: string;
    facilityId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type ComplaintCreateManyUserInput = {
    id?: string;
    title: string;
    description: string;
    type: $Enums.ComplaintType;
    status?: $Enums.ComplaintStatus;
    resolvedAt?: Date | string | null;
    resolvedBy?: string | null;
    rating?: number | null;
    feedback?: string | null;
    images?: ComplaintCreateimagesInput | string[];
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type PaymentCreateManyUserInput = {
    id?: string;
    amount: number;
    type: $Enums.PaymentType;
    description: string;
    status?: $Enums.PaymentStatus;
    dueDate?: Date | string | null;
    paidDate?: Date | string | null;
    paymentMethod?: $Enums.PaymentMethod | null;
    transactionId?: string | null;
    razorpayOrderId?: string | null;
    razorpayPaymentId?: string | null;
    receiptUrl?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type CommunityFinanceCreateManyRecordedByInput = {
    id?: string;
    amount: number;
    type?: string;
    category: string;
    description?: string | null;
    date?: Date | string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type MessageCreateManySenderInput = {
    id?: string;
    content: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type RefreshTokenUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type RefreshTokenUncheckedUpdateManyWithoutUserInput = {
    token?: StringFieldUpdateOperationsInput | string;
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    revoked?: BoolFieldUpdateOperationsInput | boolean;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUpdateWithoutUserInput = {
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateWithoutUserInput = {
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PushSubscriptionUncheckedUpdateManyWithoutUserInput = {
    endpoint?: StringFieldUpdateOperationsInput | string;
    p256dh?: StringFieldUpdateOperationsInput | string;
    auth?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    message?: StringFieldUpdateOperationsInput | string;
    type?: StringFieldUpdateOperationsInput | string;
    read?: BoolFieldUpdateOperationsInput | boolean;
    link?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type UserUpdateWithoutApprovedByInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUpdateManyWithoutUserNestedInput;
    property?: PropertyUpdateOneWithoutUserNestedInput;
    approvals?: UserUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUpdateManyWithoutUserNestedInput;
    payments?: PaymentUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateWithoutApprovedByInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutUserNestedInput;
    pushSubscriptions?: PushSubscriptionUncheckedUpdateManyWithoutUserNestedInput;
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput;
    property?: PropertyUncheckedUpdateOneWithoutUserNestedInput;
    approvals?: UserUncheckedUpdateManyWithoutApprovedByNestedInput;
    announcements?: AnnouncementUncheckedUpdateManyWithoutAuthorNestedInput;
    announcementLikes?: AnnouncementLikeUncheckedUpdateManyWithoutUserNestedInput;
    announcementComments?: AnnouncementCommentUncheckedUpdateManyWithoutUserNestedInput;
    createdPolls?: PollUncheckedUpdateManyWithoutCreatedByNestedInput;
    pollVotes?: PollVoteUncheckedUpdateManyWithoutUserNestedInput;
    facilityBookings?: FacilityBookingUncheckedUpdateManyWithoutUserNestedInput;
    complaints?: ComplaintUncheckedUpdateManyWithoutUserNestedInput;
    payments?: PaymentUncheckedUpdateManyWithoutUserNestedInput;
    recordedFinances?: CommunityFinanceUncheckedUpdateManyWithoutRecordedByNestedInput;
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput;
  };

  export type UserUncheckedUpdateManyWithoutApprovedByInput = {
    email?: StringFieldUpdateOperationsInput | string;
    phone?: NullableStringFieldUpdateOperationsInput | string | null;
    name?: StringFieldUpdateOperationsInput | string;
    password?: NullableStringFieldUpdateOperationsInput | string | null;
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
    status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null;
    provider?: EnumAuthProviderFieldUpdateOperationsInput | $Enums.AuthProvider;
    image?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    notificationsEnabled?: BoolFieldUpdateOperationsInput | boolean;
  };

  export type AnnouncementUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: AnnouncementLikeUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    likes?: AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementNestedInput;
    comments?: AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementNestedInput;
    poll?: PollUncheckedUpdateOneWithoutAnnouncementNestedInput;
  };

  export type AnnouncementUncheckedUpdateManyWithoutAuthorInput = {
    title?: StringFieldUpdateOperationsInput | string;
    content?: StringFieldUpdateOperationsInput | string;
    imageUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    commentsEnabled?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    expiresAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcement?: AnnouncementUpdateOneRequiredWithoutLikesNestedInput;
  };

  export type AnnouncementLikeUncheckedUpdateWithoutUserInput = {
    announcementId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeUncheckedUpdateManyWithoutUserInput = {
    announcementId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcement?: AnnouncementUpdateOneRequiredWithoutCommentsNestedInput;
  };

  export type AnnouncementCommentUncheckedUpdateWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string;
    announcementId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentUncheckedUpdateManyWithoutUserInput = {
    content?: StringFieldUpdateOperationsInput | string;
    announcementId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollUpdateWithoutCreatedByInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    options?: PollOptionUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUpdateManyWithoutPollNestedInput;
    announcement?: AnnouncementUpdateOneWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateWithoutCreatedByInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
    options?: PollOptionUncheckedUpdateManyWithoutPollNestedInput;
    votes?: PollVoteUncheckedUpdateManyWithoutPollNestedInput;
  };

  export type PollUncheckedUpdateManyWithoutCreatedByInput = {
    question?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    isAnonymous?: BoolFieldUpdateOperationsInput | boolean;
    isPinned?: BoolFieldUpdateOperationsInput | boolean;
    pinnedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    endsAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    announcementId?: NullableStringFieldUpdateOperationsInput | string | null;
  };

  export type PollVoteUpdateWithoutUserInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    poll?: PollUpdateOneRequiredWithoutVotesNestedInput;
    option?: PollOptionUpdateOneRequiredWithoutVotesNestedInput;
  };

  export type PollVoteUncheckedUpdateWithoutUserInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    optionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteUncheckedUpdateManyWithoutUserInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    optionId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingUpdateWithoutUserInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    facility?: FacilityUpdateOneRequiredWithoutBookingsNestedInput;
  };

  export type FacilityBookingUncheckedUpdateWithoutUserInput = {
    facilityId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingUncheckedUpdateManyWithoutUserInput = {
    facilityId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintUncheckedUpdateWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type ComplaintUncheckedUpdateManyWithoutUserInput = {
    title?: StringFieldUpdateOperationsInput | string;
    description?: StringFieldUpdateOperationsInput | string;
    type?: EnumComplaintTypeFieldUpdateOperationsInput | $Enums.ComplaintType;
    status?:
      | EnumComplaintStatusFieldUpdateOperationsInput
      | $Enums.ComplaintStatus;
    resolvedAt?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
    rating?: NullableIntFieldUpdateOperationsInput | number | null;
    feedback?: NullableStringFieldUpdateOperationsInput | string | null;
    images?: ComplaintUpdateimagesInput | string[];
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PaymentUncheckedUpdateManyWithoutUserInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType;
    description?: StringFieldUpdateOperationsInput | string;
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus;
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
    paidDate?:
      | NullableDateTimeFieldUpdateOperationsInput
      | Date
      | string
      | null;
    paymentMethod?:
      | NullableEnumPaymentMethodFieldUpdateOperationsInput
      | $Enums.PaymentMethod
      | null;
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayOrderId?: NullableStringFieldUpdateOperationsInput | string | null;
    razorpayPaymentId?:
      | NullableStringFieldUpdateOperationsInput
      | string
      | null;
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceUpdateWithoutRecordedByInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceUncheckedUpdateWithoutRecordedByInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type CommunityFinanceUncheckedUpdateManyWithoutRecordedByInput = {
    amount?: FloatFieldUpdateOperationsInput | number;
    type?: StringFieldUpdateOperationsInput | string;
    category?: StringFieldUpdateOperationsInput | string;
    description?: NullableStringFieldUpdateOperationsInput | string | null;
    date?: DateTimeFieldUpdateOperationsInput | Date | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageUncheckedUpdateWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeCreateManyAnnouncementInput = {
    id?: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type AnnouncementCommentCreateManyAnnouncementInput = {
    id?: string;
    content: string;
    userId: string;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type AnnouncementLikeUpdateWithoutAnnouncementInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAnnouncementLikesNestedInput;
  };

  export type AnnouncementLikeUncheckedUpdateWithoutAnnouncementInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementLikeUncheckedUpdateManyWithoutAnnouncementInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentUpdateWithoutAnnouncementInput = {
    content?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutAnnouncementCommentsNestedInput;
  };

  export type AnnouncementCommentUncheckedUpdateWithoutAnnouncementInput = {
    content?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type AnnouncementCommentUncheckedUpdateManyWithoutAnnouncementInput = {
    content?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollOptionCreateManyPollInput = {
    id?: string;
    text: string;
  };

  export type PollVoteCreateManyPollInput = {
    id?: string;
    optionId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollOptionUpdateWithoutPollInput = {
    text?: StringFieldUpdateOperationsInput | string;
    votes?: PollVoteUpdateManyWithoutOptionNestedInput;
  };

  export type PollOptionUncheckedUpdateWithoutPollInput = {
    text?: StringFieldUpdateOperationsInput | string;
    votes?: PollVoteUncheckedUpdateManyWithoutOptionNestedInput;
  };

  export type PollOptionUncheckedUpdateManyWithoutPollInput = {
    text?: StringFieldUpdateOperationsInput | string;
  };

  export type PollVoteUpdateWithoutPollInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    option?: PollOptionUpdateOneRequiredWithoutVotesNestedInput;
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput;
  };

  export type PollVoteUncheckedUpdateWithoutPollInput = {
    optionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteUncheckedUpdateManyWithoutPollInput = {
    optionId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteCreateManyOptionInput = {
    id?: string;
    pollId: string;
    userId: string;
    createdAt?: Date | string;
  };

  export type PollVoteUpdateWithoutOptionInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    poll?: PollUpdateOneRequiredWithoutVotesNestedInput;
    user?: UserUpdateOneRequiredWithoutPollVotesNestedInput;
  };

  export type PollVoteUncheckedUpdateWithoutOptionInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type PollVoteUncheckedUpdateManyWithoutOptionInput = {
    pollId?: StringFieldUpdateOperationsInput | string;
    userId?: StringFieldUpdateOperationsInput | string;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingCreateManyFacilityInput = {
    id?: string;
    userId: string;
    startTime: Date | string;
    endTime: Date | string;
    purpose?: string | null;
    status?: $Enums.FacilityBookingStatus;
    totalCost?: number | null;
    notes?: string | null;
    createdAt?: Date | string;
    updatedAt?: Date | string;
  };

  export type FacilityBookingUpdateWithoutFacilityInput = {
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    user?: UserUpdateOneRequiredWithoutFacilityBookingsNestedInput;
  };

  export type FacilityBookingUncheckedUpdateWithoutFacilityInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  export type FacilityBookingUncheckedUpdateManyWithoutFacilityInput = {
    userId?: StringFieldUpdateOperationsInput | string;
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string;
    purpose?: NullableStringFieldUpdateOperationsInput | string | null;
    status?:
      | EnumFacilityBookingStatusFieldUpdateOperationsInput
      | $Enums.FacilityBookingStatus;
    totalCost?: NullableFloatFieldUpdateOperationsInput | number | null;
    notes?: NullableStringFieldUpdateOperationsInput | string | null;
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
  };

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number;
  };

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF;
}
